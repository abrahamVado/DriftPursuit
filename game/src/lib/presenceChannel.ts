'use client'

import type { PresenceSnapshot } from '@/engine/bootstrap'

type BroadcastChannelLike = {
  postMessage(data: unknown): void
  close(): void
  addEventListener(type: 'message', listener: (event: MessageEventLike) => void): void
  removeEventListener(type: 'message', listener: (event: MessageEventLike) => void): void
}

type MessageEventLike = { data: unknown }

export type PresenceEnvelope =
  | { type: 'update'; clientId: string; snapshot: PresenceSnapshot; emittedAt: number }
  | { type: 'leave'; clientId: string; vehicleId: string; emittedAt: number }

export type PresenceListener = (message: PresenceEnvelope) => void

export type PresenceChannelOptions = {
  clientId: string
  channelName?: string
  now?: () => number
  factory?: (name: string) => BroadcastChannelLike | null
}

export type PresenceChannel = {
  publish: (snapshot: PresenceSnapshot | null | undefined) => void
  announceDeparture: (vehicleId: string | null | undefined) => void
  subscribe: (listener: PresenceListener) => () => void
  close: () => void
}

const DEFAULT_CHANNEL_NAME = 'driftpursuit-presence'

function defaultFactory(name: string): BroadcastChannelLike | null {
  //1.- Prefer the native BroadcastChannel implementation when available in the browser runtime.
  if (typeof window !== 'undefined' && 'BroadcastChannel' in window) {
    const ChannelCtor = (window as unknown as { BroadcastChannel?: typeof BroadcastChannel }).BroadcastChannel
    if (ChannelCtor) {
      return new ChannelCtor(name)
    }
  }
  return null
}

function coerceSnapshot(snapshot: PresenceSnapshot | null | undefined): PresenceSnapshot | null {
  //1.- Validate the payload shape so malformed messages never hit downstream Three.js plumbing.
  if (!snapshot || typeof snapshot.vehicle_id !== 'string' || snapshot.vehicle_id.trim() === '') {
    return null
  }
  const { position, orientation } = snapshot
  if (!position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
    return null
  }
  if (
    !orientation ||
    typeof orientation.yaw_deg !== 'number' ||
    typeof orientation.pitch_deg !== 'number' ||
    typeof orientation.roll_deg !== 'number'
  ) {
    return null
  }
  return {
    vehicle_id: snapshot.vehicle_id,
    position: { x: position.x, y: position.y, z: position.z },
    orientation: {
      yaw_deg: orientation.yaw_deg,
      pitch_deg: orientation.pitch_deg,
      roll_deg: orientation.roll_deg
    }
  }
}

function isPresenceEnvelope(input: unknown): input is PresenceEnvelope {
  //1.- Confirm the discriminant and essential fields exist before handing the message to listeners.
  if (!input || typeof input !== 'object') {
    return false
  }
  const envelope = input as PresenceEnvelope
  if (envelope.type === 'update') {
    return typeof envelope.clientId === 'string' && coerceSnapshot(envelope.snapshot) !== null
  }
  if (envelope.type === 'leave') {
    return typeof envelope.clientId === 'string' && typeof envelope.vehicleId === 'string'
  }
  return false
}

export function createPresenceChannel(options: PresenceChannelOptions): PresenceChannel {
  const clientId = options.clientId?.trim() ?? ''
  const channelName = options.channelName?.trim() || DEFAULT_CHANNEL_NAME
  const now = options.now ?? (() => Date.now())
  const listeners = new Set<PresenceListener>()
  const factory = options.factory ?? defaultFactory
  const channel = factory(channelName)

  const dispatchLocal = (message: PresenceEnvelope) => {
    for (const listener of listeners) {
      listener(message)
    }
  }

  const handleMessage = (event: MessageEventLike) => {
    //1.- Parse inbound frames and drop echoes generated by this tab.
    if (!event) {
      return
    }
    const payload = (event as MessageEventLike).data
    if (!isPresenceEnvelope(payload)) {
      return
    }
    if (payload.clientId === clientId) {
      return
    }
    dispatchLocal(payload)
  }

  if (channel) {
    //2.- Subscribe to the shared channel so the hub fan-outs to all active listeners.
    channel.addEventListener('message', handleMessage)
  }

  const publish = (snapshot: PresenceSnapshot | null | undefined) => {
    //3.- Broadcast valid updates while continuing to support the no-channel fallback for tests.
    const payload = coerceSnapshot(snapshot)
    if (!payload) {
      return
    }
    const envelope: PresenceEnvelope = {
      type: 'update',
      clientId,
      snapshot: payload,
      emittedAt: now()
    }
    if (channel) {
      channel.postMessage(envelope)
    } else {
      dispatchLocal(envelope)
    }
  }

  const announceDeparture = (vehicleId: string | null | undefined) => {
    //4.- Inform peers that the remote vehicle should despawn when the tab closes or navigates away.
    if (!vehicleId || vehicleId.trim() === '') {
      return
    }
    const envelope: PresenceEnvelope = {
      type: 'leave',
      clientId,
      vehicleId,
      emittedAt: now()
    }
    if (channel) {
      channel.postMessage(envelope)
    } else {
      dispatchLocal(envelope)
    }
  }

  const subscribe = (listener: PresenceListener) => {
    //5.- Register the callback and expose an unsubscribe helper for React effect clean-up.
    if (listener) {
      listeners.add(listener)
    }
    return () => {
      if (listener) {
        listeners.delete(listener)
      }
    }
  }

  const close = () => {
    //6.- Release the shared channel and purge listeners when the gameplay scene tears down.
    listeners.clear()
    if (channel) {
      channel.removeEventListener('message', handleMessage)
      channel.close()
    }
  }

  return { publish, announceDeparture, subscribe, close }
}
