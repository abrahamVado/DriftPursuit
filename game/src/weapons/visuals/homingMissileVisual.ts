import * as THREE from 'three'
import type { HomingMissileState } from '@/weapons/homingMissile'

export type MissilePalette = {
  body: number
  emissive: number
  trail: number
}

const BASE_FORWARD = new THREE.Vector3(0, 0, 1)
const TMP_FORWARD = new THREE.Vector3()

export type HomingMissileVisual = {
  update: (missiles: VisualMissileState[]) => void
  dispose: () => void
  readonly group: THREE.Group
}

type MissileRenderState = {
  mesh: THREE.Group
  trail: THREE.Line
  flame: THREE.Mesh
  smoke: THREE.Mesh
}

type VisualMissileState = HomingMissileState & {
  stage?: 'ejecting' | 'burning'
  stageMs?: number
}

export function createHomingMissileVisual(scene: THREE.Scene, palette: MissilePalette = {
  body: 0xd36f39,
  emissive: 0xff6b2f,
  trail: 0xffc48a,
}): HomingMissileVisual {
  const group = new THREE.Group()
  scene.add(group)

  const bodyMaterial = new THREE.MeshStandardMaterial({
    color: palette.body,
    metalness: 0.35,
    roughness: 0.4,
    emissive: new THREE.Color(palette.emissive),
    emissiveIntensity: 0.4,
  })
  const finMaterial = new THREE.MeshStandardMaterial({ color: 0x333845, metalness: 0.15, roughness: 0.6 })
  const trailMaterial = new THREE.LineBasicMaterial({
    color: palette.trail,
    transparent: true,
    opacity: 0.55,
    blending: THREE.AdditiveBlending,
  })

  const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.32, 1.4, 10, 1, true)
  const noseGeometry = new THREE.ConeGeometry(0.32, 0.7, 10, 1)
  const finGeometry = new THREE.BoxGeometry(0.05, 0.4, 0.25)
  const flameGeometry = new THREE.ConeGeometry(0.18, 0.9, 12, 1)
  const smokeGeometry = new THREE.CylinderGeometry(0.08, 0.22, 1.4, 8, 1, true)

  const flameMaterial = new THREE.MeshBasicMaterial({
    color: palette.emissive,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
  })
  const smokeMaterial = new THREE.MeshBasicMaterial({
    color: 0x444f63,
    transparent: true,
    opacity: 0.45,
    depthWrite: false,
    blending: THREE.NormalBlending,
    side: THREE.DoubleSide,
  })

  const renderStates = new Map<number, MissileRenderState>()

  function buildMissile(): MissileRenderState {
    //1.- Construct a reusable missile rig so pooled projectiles share GPU buffers.
    const missileGroup = new THREE.Group()

    const body = new THREE.Mesh(bodyGeometry, bodyMaterial)
    body.rotation.x = Math.PI / 2
    missileGroup.add(body)

    const nose = new THREE.Mesh(noseGeometry, bodyMaterial)
    nose.position.z = -1
    missileGroup.add(nose)

    for (let i = 0; i < 4; i++) {
      const fin = new THREE.Mesh(finGeometry, finMaterial)
      fin.position.set(0, Math.sin((i * Math.PI) / 2) * 0.35, Math.cos((i * Math.PI) / 2) * 0.35)
      fin.rotation.x = Math.PI / 2
      fin.rotation.y = (i * Math.PI) / 2
      missileGroup.add(fin)
    }

    const trailGeometry = new THREE.BufferGeometry()
    const trail = new THREE.Line(trailGeometry, trailMaterial)
    missileGroup.add(trail)

    const flame = new THREE.Mesh(flameGeometry, flameMaterial)
    flame.position.z = 0.75
    flame.rotation.x = Math.PI
    missileGroup.add(flame)

    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial.clone())
    smoke.position.z = 0.9
    smoke.rotation.x = Math.PI / 2
    missileGroup.add(smoke)

    group.add(missileGroup)

    return { mesh: missileGroup, trail, flame, smoke }
  }

  function update(missiles: VisualMissileState[]) {
    const seen = new Set<number>()

    for (const missile of missiles) {
      seen.add(missile.id)
      let renderState = renderStates.get(missile.id)
      if (!renderState) {
        //2.- Spawn a visual shell when the simulation reports a new missile instance.
        renderState = buildMissile()
        renderStates.set(missile.id, renderState)
      }

      //3.- Snap the rig to the authoritative kinematic state generated by the weapon logic.
      renderState.mesh.position.copy(missile.position)

      TMP_FORWARD.copy(missile.velocity)
      if (TMP_FORWARD.lengthSq() < 1e-6) {
        TMP_FORWARD.set(0, 0, 1)
      }
      TMP_FORWARD.normalize()
      renderState.mesh.quaternion.setFromUnitVectors(BASE_FORWARD, TMP_FORWARD)

      const burning = missile.stage === 'burning'
      renderState.flame.visible = burning
      renderState.smoke.visible = burning
      if (burning){
        const stageMs = missile.stageMs ?? 0
        const intensity = Math.min(1, stageMs / 400)
        renderState.flame.scale.setScalar(0.7 + intensity * 0.6)
        renderState.smoke.scale.set(1 + intensity * 0.8, 1 + intensity * 0.8, 1)
        const smokeMat = renderState.smoke.material as THREE.MeshBasicMaterial
        smokeMat.opacity = 0.3 + intensity * 0.3
      }

      //4.- Rebuild the exhaust ribbon so contrails appear where guidance history says they were.
      const points = missile.smokeTrail.length > 0 ? missile.smokeTrail : [missile.position]
      renderState.trail.geometry.setFromPoints(points)
    }

    for (const [id, renderState] of renderStates) {
      if (seen.has(id)) continue
      //5.- Clean up visuals for detonated missiles to keep the pool lean.
      group.remove(renderState.mesh)
      renderState.trail.geometry.dispose()
      renderStates.delete(id)
    }
  }

  function dispose() {
    //6.- Release pooled assets when the owning controller tears down the weapon systems.
    for (const [, renderState] of renderStates) {
      group.remove(renderState.mesh)
      renderState.trail.geometry.dispose()
    }
    renderStates.clear()
    scene.remove(group)
    bodyGeometry.dispose()
    noseGeometry.dispose()
    finGeometry.dispose()
    flameGeometry.dispose()
    smokeGeometry.dispose()
    bodyMaterial.dispose()
    finMaterial.dispose()
    trailMaterial.dispose()
    flameMaterial.dispose()
    smokeMaterial.dispose()
  }

  return { update, dispose, group }
}
