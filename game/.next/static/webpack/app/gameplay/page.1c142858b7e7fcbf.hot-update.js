"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/enemies/stellated-octahedron/behavior.ts":
/*!******************************************************!*\
  !*** ./src/enemies/stellated-octahedron/behavior.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEnemy: () => (/* binding */ createEnemy),\n/* harmony export */   updateEnemies: () => (/* binding */ updateEnemies)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/utils/BufferGeometryUtils.js */ \"(app-pages-browser)/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nfunction disposeMeshLike(object) {\n    // 1. Traverse any composed mesh tree and release GPU buffers and materials.\n    const disposedMaterials = new Set();\n    object.traverse((child)=>{\n        if (!(child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh)) return;\n        child.geometry.dispose();\n        const material = child.material;\n        if (Array.isArray(material)) {\n            for (const mat of material){\n                if (!disposedMaterials.has(mat)) {\n                    var _mat_dispose;\n                    (_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                    disposedMaterials.add(mat);\n                }\n            }\n        } else if (!disposedMaterials.has(material)) {\n            var _material_dispose;\n            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n            disposedMaterials.add(material);\n        }\n    });\n}\nfunction buildStellatedOctahedron() {\n    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6, variant = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'pursuer';\n    const group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n    // 1. Generate two tetrahedron geometries and mirror one to reproduce the stellated octahedron shell.\n    const primary = new three__WEBPACK_IMPORTED_MODULE_1__.TetrahedronGeometry(size * 0.8, 1); // Higher detail for sharper edges\n    const mirrored = primary.clone();\n    mirrored.rotateX(Math.PI);\n    mirrored.rotateZ(Math.PI / 2);\n    // 2. Merge both buffer geometries using the supported helper to avoid the removed Geometry.merge API.\n    const merged = (0,three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.mergeGeometries)([\n        primary,\n        mirrored\n    ], false);\n    if (!merged) throw new Error('Failed to merge stellated octahedron geometry');\n    // 3. Dispose the temporary parts.\n    primary.dispose();\n    mirrored.dispose();\n    // Enhanced body material: Dynamic based on variant for visual distinction\n    let bodyColor = 0xff5533; // Base orange-red\n    let emissive = 0x220000;\n    let roughness = 0.6;\n    let metalness = 0.2;\n    switch(variant){\n        case 'strafer':\n            bodyColor = 0x00ff88; // Neon green for agile flanker\n            emissive = 0x004400;\n            roughness = 0.4;\n            metalness = 0.4;\n            break;\n        case 'sentry':\n            bodyColor = 0x8b0000; // Dark red for stationary turret\n            emissive = 0x440000;\n            roughness = 0.8;\n            metalness = 0.1;\n            break;\n    }\n    const bodyMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n        color: bodyColor,\n        metalness,\n        roughness,\n        emissive,\n        emissiveIntensity: 0.3 // Pulsing glow potential\n    });\n    const body = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(merged, bodyMaterial);\n    group.add(body);\n    // Add menacing spikes: Procedural, variant-specific count and style for danger\n    const spikeGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.ConeGeometry(0.4, 2, 5);\n    const spikeMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n        color: 0x111111,\n        roughness: 0.1,\n        metalness: 0.95 // Razor-sharp reflection\n    });\n    const spikeCount = variant === 'sentry' ? 8 : variant === 'strafer' ? 12 : 6; // More for aggressive variants\n    for(let i = 0; i < spikeCount; i++){\n        const angle = i / spikeCount * Math.PI * 2;\n        const radius = size * 0.7;\n        const heightOffset = (Math.random() - 0.5) * 0.5;\n        const spikePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(Math.cos(angle) * radius, heightOffset, Math.sin(angle) * radius);\n        const spike = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(spikeGeometry, spikeMaterial);\n        spike.position.copy(spikePos);\n        // Orient spikes radially outward\n        spike.lookAt(spikePos.clone().multiplyScalar(2));\n        spike.rotateX(Math.PI); // Flip to point out\n        group.add(spike);\n        // Secondary barbs on spikes for extra threat\n        if (Math.random() > 0.3) {\n            const barb = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(new three__WEBPACK_IMPORTED_MODULE_1__.BoxGeometry(0.2, 0.2, 1.5), spikeMaterial);\n            barb.position.copy(spikePos.clone().add(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, -1)));\n            barb.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);\n            group.add(barb);\n        }\n    }\n    // Glowing core: Emissive sphere for a volatile energy heart\n    const coreGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(size * 0.3, 12, 8);\n    const coreMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n        color: 0xff0000,\n        emissive: 0xff0000,\n        emissiveIntensity: 0.6,\n        transparent: true,\n        opacity: 0.8\n    });\n    const core = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(coreGeometry, coreMaterial);\n    core.position.set(0, 0, 0);\n    group.add(core);\n    // Variant-specific accents\n    if (variant === 'strafer') {\n        // Side vents for speed implication\n        const ventGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BoxGeometry(1.5, 0.3, 3);\n        const ventMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n            color: 0x00ff88,\n            emissive: 0x004400\n        });\n        const leftVent = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(ventGeometry, ventMaterial);\n        leftVent.position.set(-size * 0.6, 0, 0);\n        group.add(leftVent);\n        const rightVent = leftVent.clone();\n        rightVent.position.set(size * 0.6, 0, 0);\n        group.add(rightVent);\n    } else if (variant === 'sentry') {\n        // Turret base for grounded feel\n        const baseGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CylinderGeometry(size * 0.9, size * 1.1, 0.5, 8);\n        const baseMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n            color: 0x333333,\n            roughness: 0.9\n        });\n        const base = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(baseGeometry, baseMaterial);\n        base.position.set(0, -size * 0.6, 0);\n        group.add(base);\n    }\n    // Animation hook: Subtle idle rotation and pulse\n    group.userData = {\n        originalEmissive: bodyMaterial.emissive.clone(),\n        pulseTime: 0,\n        variant\n    };\n    return group;\n}\nfunction createEnemy(scene, position) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var _scene;\n    // 1. Materialise the mesh, position it, and append it to the active scene graph.\n    const mesh = buildStellatedOctahedron(5, options.variant);\n    mesh.position.copy(position);\n    scene.add(mesh);\n    const vel = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    const dir = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    var _options_difficulty;\n    const difficulty = (_options_difficulty = options.difficulty) !== null && _options_difficulty !== void 0 ? _options_difficulty : (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_0__.getDifficultyState)();\n    const hpBase = 40 * difficulty.enemyHpMultiplier;\n    const acceleration = 18 + difficulty.enemyDpsMultiplier * 6 + (options.variant === 'strafer' ? 4 : 0);\n    const maxSpeed = 36 + difficulty.enemyDpsMultiplier * 8 + (options.variant === 'strafer' ? 10 : 0);\n    const obj = {\n        mesh,\n        hp: hpBase,\n        difficulty,\n        target: undefined,\n        update (dt) {\n            var _mesh_children_;\n            // Enhanced update: Add idle animation and variant-specific behaviors\n            const userData = mesh.userData;\n            userData.pulseTime += dt;\n            // Pulse emissive for threat\n            const pulse = 0.2 + Math.sin(userData.pulseTime * 3) * 0.1;\n            if ((_mesh_children_ = mesh.children[0]) === null || _mesh_children_ === void 0 ? void 0 : _mesh_children_.material) {\n                mesh.children[0].material.emissiveIntensity = 0.3 + pulse * 0.2;\n            }\n            if (userData.variant === 'sentry') {\n                // Sentry: Slow turret rotation only when targeting\n                if (this.target) mesh.rotation.y += dt * 0.5;\n            } else {\n                // Others: Gentle idle spin\n                mesh.rotation.y += dt * 0.01;\n            }\n            if (this.target) {\n                dir.copy(this.target.position).sub(mesh.position);\n                const distance = dir.length() || 1;\n                dir.normalize();\n                const aimAssist = three__WEBPACK_IMPORTED_MODULE_1__.MathUtils.lerp(0.6, 1, difficulty.enemyAccuracy);\n                vel.addScaledVector(dir, acceleration * aimAssist * dt);\n                (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_0__.applyEnvironmentVectorAttenuation)(vel);\n                const clamped = Math.min(maxSpeed, maxSpeed * (distance > 180 ? 1.1 : 1));\n                vel.clampLength(0, clamped);\n                mesh.position.addScaledVector(vel, dt);\n                mesh.lookAt(this.target.position);\n                // Strafer: Zigzag pattern for evasion\n                if (userData.variant === 'strafer' && Math.random() < 0.02) {\n                    vel.add(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3((Math.random() - 0.5) * 20, 0, 0));\n                }\n            }\n        },\n        onDeath () {\n            scene.remove(mesh);\n            disposeMeshLike(mesh);\n        }\n    };\n    // 2. Track the enemy so the wave manager can iterate and update per frame.\n    ;\n    var ___enemies;\n    (___enemies = (_scene = scene).__enemies) !== null && ___enemies !== void 0 ? ___enemies : _scene.__enemies = [];\n    ;\n    scene.__enemies.push(obj);\n    return obj;\n}\nfunction updateEnemies(scene, dt, difficulty) {\n    // 1. Advance each tracked enemy AI using the shared scene registry.\n    const arr = scene.__enemies;\n    if (!arr) return;\n    for (const e of arr){\n        e.difficulty = difficulty;\n        e.update(dt);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lbmVtaWVzL3N0ZWxsYXRlZC1vY3RhaGVkcm9uL2JlaGF2aW9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCO0FBQ21EO0FBQ1U7QUFRNUYsU0FBU0ksZ0JBQWdCQyxNQUFzQjtJQUM3Qyw0RUFBNEU7SUFDNUUsTUFBTUMsb0JBQW9CLElBQUlDO0lBQzlCRixPQUFPRyxRQUFRLENBQUMsQ0FBQ0M7UUFDZixJQUFJLENBQUVBLENBQUFBLGlCQUFpQlQsdUNBQVUsR0FBRztRQUNwQ1MsTUFBTUUsUUFBUSxDQUFDQyxPQUFPO1FBQ3RCLE1BQU1DLFdBQVdKLE1BQU1JLFFBQVE7UUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixXQUFXO1lBQzNCLEtBQUssTUFBTUcsT0FBT0gsU0FBVTtnQkFDMUIsSUFBSSxDQUFDUCxrQkFBa0JXLEdBQUcsQ0FBQ0QsTUFBTTt3QkFDL0JBO3FCQUFBQSxlQUFBQSxJQUFJSixPQUFPLGNBQVhJLG1DQUFBQSxrQkFBQUE7b0JBQ0FWLGtCQUFrQlksR0FBRyxDQUFDRjtnQkFDeEI7WUFDRjtRQUNGLE9BQU8sSUFBSSxDQUFDVixrQkFBa0JXLEdBQUcsQ0FBQ0osV0FBVztnQkFDM0NBO2FBQUFBLG9CQUFBQSxTQUFTRCxPQUFPLGNBQWhCQyx3Q0FBQUEsdUJBQUFBO1lBQ0FQLGtCQUFrQlksR0FBRyxDQUFDTDtRQUN4QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTTTtRQUF5QkMsT0FBQUEsaUVBQU8sR0FBR0MsVUFBQUEsaUVBQVU7SUFDcEQsTUFBTUMsUUFBUSxJQUFJdEIsd0NBQVc7SUFFN0IscUdBQXFHO0lBQ3JHLE1BQU13QixVQUFVLElBQUl4QixzREFBeUIsQ0FBQ29CLE9BQU8sS0FBSyxJQUFJLGtDQUFrQztJQUNoRyxNQUFNTSxXQUFXRixRQUFRRyxLQUFLO0lBQzlCRCxTQUFTRSxPQUFPLENBQUNDLEtBQUtDLEVBQUU7SUFDeEJKLFNBQVNLLE9BQU8sQ0FBQ0YsS0FBS0MsRUFB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RztnQkFDM0Q7WUFDRjtRQUNGO1FBQ0FnRTtZQUNFaEMsTUFBTWlDLE1BQU0sQ0FBQy9CO1lBQ2JqRixnQkFBZ0JpRjtRQUNsQjtJQUNGO0lBRUEsMkVBQTJFOzs7SUFDMUUsZUFBQ0YsU0FBQUEsT0FBY2tDLDREQUFkbEMsT0FBY2tDLFlBQWMsRUFBRTs7SUFDOUJsQyxNQUFja0MsU0FBUyxDQUFDQyxJQUFJLENBQUN4QjtJQUMvQixPQUFPQTtBQUNUO0FBRU8sU0FBU3lCLGNBQWNwQyxLQUFrQixFQUFFZ0IsRUFBVSxFQUFFWCxVQUFrQztJQUM5RixvRUFBb0U7SUFDcEUsTUFBTWdDLE1BQU0sTUFBZUgsU0FBUztJQUNwQyxJQUFJLENBQUNHLEtBQUs7SUFDVixLQUFLLE1BQU1DLEtBQUtELElBQUs7UUFDbkJDLEVBQUVqQyxVQUFVLEdBQUdBO1FBQ2ZpQyxFQUFFdkIsTUFBTSxDQUFDQztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIi9hcHAvc3JjL2VuZW1pZXMvc3RlbGxhdGVkLW9jdGFoZWRyb24vYmVoYXZpb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgbWVyZ2VHZW9tZXRyaWVzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMnO1xuaW1wb3J0IHsgYXBwbHlFbnZpcm9ubWVudFZlY3RvckF0dGVudWF0aW9uLCBnZXREaWZmaWN1bHR5U3RhdGUgfSBmcm9tICdAL2VuZ2luZS9kaWZmaWN1bHR5JztcblxuZXhwb3J0IHR5cGUgRW5lbXlEaWZmaWN1bHR5Q29udGV4dCA9IFJldHVyblR5cGU8dHlwZW9mIGdldERpZmZpY3VsdHlTdGF0ZT47XG5leHBvcnQgdHlwZSBFbmVteU9wdGlvbnMgPSB7XG4gIGRpZmZpY3VsdHk/OiBFbmVteURpZmZpY3VsdHlDb250ZXh0O1xuICB2YXJpYW50PzogJ3B1cnN1ZXInIHwgJ3N0cmFmZXInIHwgJ3NlbnRyeSc7XG59O1xuXG5mdW5jdGlvbiBkaXNwb3NlTWVzaExpa2Uob2JqZWN0OiBUSFJFRS5PYmplY3QzRCkge1xuICAvLyAxLiBUcmF2ZXJzZSBhbnkgY29tcG9zZWQgbWVzaCB0cmVlIGFuZCByZWxlYXNlIEdQVSBidWZmZXJzIGFuZCBtYXRlcmlhbHMuXG4gIGNvbnN0IGRpc3Bvc2VkTWF0ZXJpYWxzID0gbmV3IFNldDxUSFJFRS5NYXRlcmlhbD4oKTtcbiAgb2JqZWN0LnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkpIHJldHVybjtcbiAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSB7XG4gICAgICAgIGlmICghZGlzcG9zZWRNYXRlcmlhbHMuaGFzKG1hdCkpIHtcbiAgICAgICAgICBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgZGlzcG9zZWRNYXRlcmlhbHMuYWRkKG1hdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFkaXNwb3NlZE1hdGVyaWFscy5oYXMobWF0ZXJpYWwpKSB7XG4gICAgICBtYXRlcmlhbC5kaXNwb3NlPy4oKTtcbiAgICAgIGRpc3Bvc2VkTWF0ZXJpYWxzLmFkZChtYXRlcmlhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGVsbGF0ZWRPY3RhaGVkcm9uKHNpemUgPSA2LCB2YXJpYW50ID0gJ3B1cnN1ZXInKSB7XG4gIGNvbnN0IGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cbiAgLy8gMS4gR2VuZXJhdGUgdHdvIHRldHJhaGVkcm9uIGdlb21ldHJpZXMgYW5kIG1pcnJvciBvbmUgdG8gcmVwcm9kdWNlIHRoZSBzdGVsbGF0ZWQgb2N0YWhlZHJvbiBzaGVsbC5cbiAgY29uc3QgcHJpbWFyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KHNpemUgKiAwLjgsIDEpOyAvLyBIaWdoZXIgZGV0YWlsIGZvciBzaGFycGVyIGVkZ2VzXG4gIGNvbnN0IG1pcnJvcmVkID0gcHJpbWFyeS5jbG9uZSgpO1xuICBtaXJyb3JlZC5yb3RhdGVYKE1hdGguUEkpO1xuICBtaXJyb3JlZC5yb3RhdGVaKE1hdGguUEkgLyAyKTtcbiAgLy8gMi4gTWVyZ2UgYm90aCBidWZmZXIgZ2VvbWV0cmllcyB1c2luZyB0aGUgc3VwcG9ydGVkIGhlbHBlciB0byBhdm9pZCB0aGUgcmVtb3ZlZCBHZW9tZXRyeS5tZXJnZSBBUEkuXG4gIGNvbnN0IG1lcmdlZCA9IG1lcmdlR2VvbWV0cmllcyhbcHJpbWFyeSwgbWlycm9yZWRdLCBmYWxzZSk7XG4gIGlmICghbWVyZ2VkKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBtZXJnZSBzdGVsbGF0ZWQgb2N0YWhlZHJvbiBnZW9tZXRyeScpO1xuICAvLyAzLiBEaXNwb3NlIHRoZSB0ZW1wb3JhcnkgcGFydHMuXG4gIHByaW1hcnkuZGlzcG9zZSgpO1xuICBtaXJyb3JlZC5kaXNwb3NlKCk7XG5cbiAgLy8gRW5oYW5jZWQgYm9keSBtYXRlcmlhbDogRHluYW1pYyBiYXNlZCBvbiB2YXJpYW50IGZvciB2aXN1YWwgZGlzdGluY3Rpb25cbiAgbGV0IGJvZHlDb2xvciA9IDB4ZmY1NTMzOyAvLyBCYXNlIG9yYW5nZS1yZWRcbiAgbGV0IGVtaXNzaXZlID0gMHgyMjAwMDA7XG4gIGxldCByb3VnaG5lc3MgPSAwLjY7XG4gIGxldCBtZXRhbG5lc3MgPSAwLjI7XG4gIHN3aXRjaCAodmFyaWFudCkge1xuICAgIGNhc2UgJ3N0cmFmZXInOlxuICAgICAgYm9keUNvbG9yID0gMHgwMGZmODg7IC8vIE5lb24gZ3JlZW4gZm9yIGFnaWxlIGZsYW5rZXJcbiAgICAgIGVtaXNzaXZlID0gMHgwMDQ0MDA7XG4gICAgICByb3VnaG5lc3MgPSAwLjQ7XG4gICAgICBtZXRhbG5lc3MgPSAwLjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZW50cnknOlxuICAgICAgYm9keUNvbG9yID0gMHg4YjAwMDA7IC8vIERhcmsgcmVkIGZvciBzdGF0aW9uYXJ5IHR1cnJldFxuICAgICAgZW1pc3NpdmUgPSAweDQ0MDAwMDtcbiAgICAgIHJvdWdobmVzcyA9IDAuODtcbiAgICAgIG1ldGFsbmVzcyA9IDAuMTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IGJvZHlNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgY29sb3I6IGJvZHlDb2xvcixcbiAgICBtZXRhbG5lc3MsXG4gICAgcm91Z2huZXNzLFxuICAgIGVtaXNzaXZlLFxuICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLjMgLy8gUHVsc2luZyBnbG93IHBvdGVudGlhbFxuICB9KTtcbiAgY29uc3QgYm9keSA9IG5ldyBUSFJFRS5NZXNoKG1lcmdlZCwgYm9keU1hdGVyaWFsKTtcbiAgZ3JvdXAuYWRkKGJvZHkpO1xuXG4gIC8vIEFkZCBtZW5hY2luZyBzcGlrZXM6IFByb2NlZHVyYWwsIHZhcmlhbnQtc3BlY2lmaWMgY291bnQgYW5kIHN0eWxlIGZvciBkYW5nZXJcbiAgY29uc3Qgc3Bpa2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5Db25lR2VvbWV0cnkoMC40LCAyLCA1KTtcbiAgY29uc3Qgc3Bpa2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4MTExMTExLFxuICAgIHJvdWdobmVzczogMC4xLFxuICAgIG1ldGFsbmVzczogMC45NSAvLyBSYXpvci1zaGFycCByZWZsZWN0aW9uXG4gIH0pO1xuICBjb25zdCBzcGlrZUNvdW50ID0gdmFyaWFudCA9PT0gJ3NlbnRyeScgPyA4IDogdmFyaWFudCA9PT0gJ3N0cmFmZXInID8gMTIgOiA2OyAvLyBNb3JlIGZvciBhZ2dyZXNzaXZlIHZhcmlhbnRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3Bpa2VDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwaWtlQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgY29uc3QgcmFkaXVzID0gc2l6ZSAqIDAuNztcbiAgICBjb25zdCBoZWlnaHRPZmZzZXQgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjU7XG4gICAgY29uc3Qgc3Bpa2VQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGhlaWdodE9mZnNldCxcbiAgICAgIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1c1xuICAgICk7XG4gICAgY29uc3Qgc3Bpa2UgPSBuZXcgVEhSRUUuTWVzaChzcGlrZUdlb21ldHJ5LCBzcGlrZU1hdGVyaWFsKTtcbiAgICBzcGlrZS5wb3NpdGlvbi5jb3B5KHNwaWtlUG9zKTtcbiAgICAvLyBPcmllbnQgc3Bpa2VzIHJhZGlhbGx5IG91dHdhcmRcbiAgICBzcGlrZS5sb29rQXQoc3Bpa2VQb3MuY2xvbmUoKS5tdWx0aXBseVNjYWxhcigyKSk7XG4gICAgc3Bpa2Uucm90YXRlWChNYXRoLlBJKTsgLy8gRmxpcCB0byBwb2ludCBvdXRcbiAgICBncm91cC5hZGQoc3Bpa2UpO1xuXG4gICAgLy8gU2Vjb25kYXJ5IGJhcmJzIG9uIHNwaWtlcyBmb3IgZXh0cmEgdGhyZWF0XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjMpIHtcbiAgICAgIGNvbnN0IGJhcmIgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgbmV3IFRIUkVFLkJveEdlb21ldHJ5KDAuMiwgMC4yLCAxLjUpLFxuICAgICAgICBzcGlrZU1hdGVyaWFsXG4gICAgICApO1xuICAgICAgYmFyYi5wb3NpdGlvbi5jb3B5KHNwaWtlUG9zLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC0xKSkpO1xuICAgICAgYmFyYi5yb3RhdGlvbi5zZXQoTWF0aC5yYW5kb20oKSAqIE1hdGguUEksIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJLCAwKTtcbiAgICAgIGdyb3VwLmFkZChiYXJiKTtcbiAgICB9XG4gIH1cblxuICAvLyBHbG93aW5nIGNvcmU6IEVtaXNzaXZlIHNwaGVyZSBmb3IgYSB2b2xhdGlsZSBlbmVyZ3kgaGVhcnRcbiAgY29uc3QgY29yZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHNpemUgKiAwLjMsIDEyLCA4KTtcbiAgY29uc3QgY29yZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICBjb2xvcjogMHhmZjAwMDAsXG4gICAgZW1pc3NpdmU6IDB4ZmYwMDAwLFxuICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLjYsXG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgb3BhY2l0eTogMC44XG4gIH0pO1xuICBjb25zdCBjb3JlID0gbmV3IFRIUkVFLk1lc2goY29yZUdlb21ldHJ5LCBjb3JlTWF0ZXJpYWwpO1xuICBjb3JlLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgZ3JvdXAuYWRkKGNvcmUpO1xuXG4gIC8vIFZhcmlhbnQtc3BlY2lmaWMgYWNjZW50c1xuICBpZiAodmFyaWFudCA9PT0gJ3N0cmFmZXInKSB7XG4gICAgLy8gU2lkZSB2ZW50cyBmb3Igc3BlZWQgaW1wbGljYXRpb25cbiAgICBjb25zdCB2ZW50R2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMS41LCAwLjMsIDMpO1xuICAgIGNvbnN0IHZlbnRNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7IGNvbG9yOiAweDAwZmY4OCwgZW1pc3NpdmU6IDB4MDA0NDAwIH0pO1xuICAgIGNvbnN0IGxlZnRWZW50ID0gbmV3IFRIUkVFLk1lc2godmVudEdlb21ldHJ5LCB2ZW50TWF0ZXJpYWwpO1xuICAgIGxlZnRWZW50LnBvc2l0aW9uLnNldCgtc2l6ZSAqIDAuNiwgMCwgMCk7XG4gICAgZ3JvdXAuYWRkKGxlZnRWZW50KTtcbiAgICBjb25zdCByaWdodFZlbnQgPSBsZWZ0VmVudC5jbG9uZSgpO1xuICAgIHJpZ2h0VmVudC5wb3NpdGlvbi5zZXQoc2l6ZSAqIDAuNiwgMCwgMCk7XG4gICAgZ3JvdXAuYWRkKHJpZ2h0VmVudCk7XG4gIH0gZWxzZSBpZiAodmFyaWFudCA9PT0gJ3NlbnRyeScpIHtcbiAgICAvLyBUdXJyZXQgYmFzZSBmb3IgZ3JvdW5kZWQgZmVlbFxuICAgIGNvbnN0IGJhc2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KHNpemUgKiAwLjksIHNpemUgKiAxLjEsIDAuNSwgOCk7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHsgY29sb3I6IDB4MzMzMzMzLCByb3VnaG5lc3M6IDAuOSB9KTtcbiAgICBjb25zdCBiYXNlID0gbmV3IFRIUkVFLk1lc2goYmFzZUdlb21ldHJ5LCBiYXNlTWF0ZXJpYWwpO1xuICAgIGJhc2UucG9zaXRpb24uc2V0KDAsIC1zaXplICogMC42LCAwKTtcbiAgICBncm91cC5hZGQoYmFzZSk7XG4gIH1cblxuICAvLyBBbmltYXRpb24gaG9vazogU3VidGxlIGlkbGUgcm90YXRpb24gYW5kIHB1bHNlXG4gIGdyb3VwLnVzZXJEYXRhID0ge1xuICAgIG9yaWdpbmFsRW1pc3NpdmU6IGJvZHlNYXRlcmlhbC5lbWlzc2l2ZS5jbG9uZSgpLFxuICAgIHB1bHNlVGltZTogMCxcbiAgICB2YXJpYW50XG4gIH07XG5cbiAgcmV0dXJuIGdyb3VwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5lbXkoc2NlbmU6IFRIUkVFLlNjZW5lLCBwb3NpdGlvbjogVEhSRUUuVmVjdG9yMywgb3B0aW9uczogRW5lbXlPcHRpb25zID0ge30pIHtcbiAgLy8gMS4gTWF0ZXJpYWxpc2UgdGhlIG1lc2gsIHBvc2l0aW9uIGl0LCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBhY3RpdmUgc2NlbmUgZ3JhcGguXG4gIGNvbnN0IG1lc2ggPSBidWlsZFN0ZWxsYXRlZE9jdGFoZWRyb24oNSwgb3B0aW9ucy52YXJpYW50KTtcbiAgbWVzaC5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgc2NlbmUuYWRkKG1lc2gpO1xuXG4gIGNvbnN0IHZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGNvbnN0IGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGNvbnN0IGRpZmZpY3VsdHkgPSBvcHRpb25zLmRpZmZpY3VsdHkgPz8gZ2V0RGlmZmljdWx0eVN0YXRlKCk7XG4gIGNvbnN0IGhwQmFzZSA9IDQwICogZGlmZmljdWx0eS5lbmVteUhwTXVsdGlwbGllcjtcbiAgY29uc3QgYWNjZWxlcmF0aW9uID0gMTggKyBkaWZmaWN1bHR5LmVuZW15RHBzTXVsdGlwbGllciAqIDYgKyAob3B0aW9ucy52YXJpYW50ID09PSAnc3RyYWZlcicgPyA0IDogMCk7XG4gIGNvbnN0IG1heFNwZWVkID0gMzYgKyBkaWZmaWN1bHR5LmVuZW15RHBzTXVsdGlwbGllciAqIDggKyAob3B0aW9ucy52YXJpYW50ID09PSAnc3RyYWZlcicgPyAxMCA6IDApO1xuXG4gIGNvbnN0IG9iaiA9IHtcbiAgICBtZXNoLFxuICAgIGhwOiBocEJhc2UsXG4gICAgZGlmZmljdWx0eSxcbiAgICB0YXJnZXQ6IHVuZGVmaW5lZCBhcyBUSFJFRS5PYmplY3QzRCB8IHVuZGVmaW5lZCxcbiAgICB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgICAgLy8gRW5oYW5jZWQgdXBkYXRlOiBBZGQgaWRsZSBhbmltYXRpb24gYW5kIHZhcmlhbnQtc3BlY2lmaWMgYmVoYXZpb3JzXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IG1lc2gudXNlckRhdGE7XG4gICAgICB1c2VyRGF0YS5wdWxzZVRpbWUgKz0gZHQ7XG4gICAgICAvLyBQdWxzZSBlbWlzc2l2ZSBmb3IgdGhyZWF0XG4gICAgICBjb25zdCBwdWxzZSA9IDAuMiArIE1hdGguc2luKHVzZXJEYXRhLnB1bHNlVGltZSAqIDMpICogMC4xO1xuICAgICAgaWYgKG1lc2guY2hpbGRyZW5bMF0/Lm1hdGVyaWFsKSB7IC8vIEJvZHlcbiAgICAgICAgKG1lc2guY2hpbGRyZW5bMF0ubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwpLmVtaXNzaXZlSW50ZW5zaXR5ID0gMC4zICsgcHVsc2UgKiAwLjI7XG4gICAgICB9XG4gICAgICBpZiAodXNlckRhdGEudmFyaWFudCA9PT0gJ3NlbnRyeScpIHtcbiAgICAgICAgLy8gU2VudHJ5OiBTbG93IHR1cnJldCByb3RhdGlvbiBvbmx5IHdoZW4gdGFyZ2V0aW5nXG4gICAgICAgIGlmICh0aGlzLnRhcmdldCkgbWVzaC5yb3RhdGlvbi55ICs9IGR0ICogMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJzOiBHZW50bGUgaWRsZSBzcGluXG4gICAgICAgIG1lc2gucm90YXRpb24ueSArPSBkdCAqIDAuMDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICBkaXIuY29weSh0aGlzLnRhcmdldC5wb3NpdGlvbikuc3ViKG1lc2gucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpci5sZW5ndGgoKSB8fCAxO1xuICAgICAgICBkaXIubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFpbUFzc2lzdCA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKDAuNiwgMSwgZGlmZmljdWx0eS5lbmVteUFjY3VyYWN5KTtcbiAgICAgICAgdmVsLmFkZFNjYWxlZFZlY3RvcihkaXIsIGFjY2VsZXJhdGlvbiAqIGFpbUFzc2lzdCAqIGR0KTtcbiAgICAgICAgYXBwbHlFbnZpcm9ubWVudFZlY3RvckF0dGVudWF0aW9uKHZlbCk7XG4gICAgICAgIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbihtYXhTcGVlZCwgbWF4U3BlZWQgKiAoZGlzdGFuY2UgPiAxODAgPyAxLjEgOiAxKSk7XG4gICAgICAgIHZlbC5jbGFtcExlbmd0aCgwLCBjbGFtcGVkKTtcbiAgICAgICAgbWVzaC5wb3NpdGlvbi5hZGRTY2FsZWRWZWN0b3IodmVsLCBkdCk7XG4gICAgICAgIG1lc2gubG9va0F0KHRoaXMudGFyZ2V0LnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBTdHJhZmVyOiBaaWd6YWcgcGF0dGVybiBmb3IgZXZhc2lvblxuICAgICAgICBpZiAodXNlckRhdGEudmFyaWFudCA9PT0gJ3N0cmFmZXInICYmIE1hdGgucmFuZG9tKCkgPCAwLjAyKSB7XG4gICAgICAgICAgdmVsLmFkZChuZXcgVEhSRUUuVmVjdG9yMygoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkRlYXRoKCkge1xuICAgICAgc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgICAgZGlzcG9zZU1lc2hMaWtlKG1lc2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyAyLiBUcmFjayB0aGUgZW5lbXkgc28gdGhlIHdhdmUgbWFuYWdlciBjYW4gaXRlcmF0ZSBhbmQgdXBkYXRlIHBlciBmcmFtZS5cbiAgOyhzY2VuZSBhcyBhbnkpLl9fZW5lbWllcyA/Pz0gW107XG4gIDsoc2NlbmUgYXMgYW55KS5fX2VuZW1pZXMucHVzaChvYmopO1xuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRW5lbWllcyhzY2VuZTogVEhSRUUuU2NlbmUsIGR0OiBudW1iZXIsIGRpZmZpY3VsdHk6IEVuZW15RGlmZmljdWx0eUNvbnRleHQpIHtcbiAgLy8gMS4gQWR2YW5jZSBlYWNoIHRyYWNrZWQgZW5lbXkgQUkgdXNpbmcgdGhlIHNoYXJlZCBzY2VuZSByZWdpc3RyeS5cbiAgY29uc3QgYXJyID0gKHNjZW5lIGFzIGFueSkuX19lbmVtaWVzIGFzIGFueVtdIHwgdW5kZWZpbmVkO1xuICBpZiAoIWFycikgcmV0dXJuO1xuICBmb3IgKGNvbnN0IGUgb2YgYXJyKSB7XG4gICAgZS5kaWZmaWN1bHR5ID0gZGlmZmljdWx0eTtcbiAgICBlLnVwZGF0ZShkdCk7XG4gIH1cbn0iXSwibmFtZXMiOlsiVEhSRUUiLCJtZXJnZUdlb21ldHJpZXMiLCJhcHBseUVudmlyb25tZW50VmVjdG9yQXR0ZW51YXRpb24iLCJnZXREaWZmaWN1bHR5U3RhdGUiLCJkaXNwb3NlTWVzaExpa2UiLCJvYmplY3QiLCJkaXNwb3NlZE1hdGVyaWFscyIsIlNldCIsInRyYXZlcnNlIiwiY2hpbGQiLCJNZXNoIiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibWF0ZXJpYWwiLCJBcnJheSIsImlzQXJyYXkiLCJtYXQiLCJoYXMiLCJhZGQiLCJidWlsZFN0ZWxsYXRlZE9jdGFoZWRyb24iLCJzaXplIiwidmFyaWFudCIsImdyb3VwIiwiR3JvdXAiLCJwcmltYXJ5IiwiVGV0cmFoZWRyb25HZW9tZXRyeSIsIm1pcnJvcmVkIiwiY2xvbmUiLCJyb3RhdGVYIiwiTWF0aCIsIlBJIiwicm90YXRlWiIsIm1lcmdlZCIsIkVycm9yIiwiYm9keUNvbG9yIiwiZW1pc3NpdmUiLCJyb3VnaG5lc3MiLCJtZXRhbG5lc3MiLCJib2R5TWF0ZXJpYWwiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJib2R5Iiwic3Bpa2VHZW9tZXRyeSIsIkNvbmVHZW9tZXRyeSIsInNwaWtlTWF0ZXJpYWwiLCJzcGlrZUNvdW50IiwiaSIsImFuZ2xlIiwicmFkaXVzIiwiaGVpZ2h0T2Zmc2V0IiwicmFuZG9tIiwic3Bpa2VQb3MiLCJWZWN0b3IzIiwiY29zIiwic2luIiwic3Bpa2UiLCJwb3NpdGlvbiIsImNvcHkiLCJsb29rQXQiLCJtdWx0aXBseVNjYWxhciIsImJhcmIiLCJCb3hHZW9tZXRyeSIsInJvdGF0aW9uIiwic2V0IiwiY29yZUdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJjb3JlTWF0ZXJpYWwiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJjb3JlIiwidmVudEdlb21ldHJ5IiwidmVudE1hdGVyaWFsIiwibGVmdFZlbnQiLCJyaWdodFZlbnQiLCJiYXNlR2VvbWV0cnkiLCJDeWxpbmRlckdlb21ldHJ5IiwiYmFzZU1hdGVyaWFsIiwiYmFzZSIsInVzZXJEYXRhIiwib3JpZ2luYWxFbWlzc2l2ZSIsInB1bHNlVGltZSIsImNyZWF0ZUVuZW15Iiwic2NlbmUiLCJvcHRpb25zIiwibWVzaCIsInZlbCIsImRpciIsImRpZmZpY3VsdHkiLCJocEJhc2UiLCJlbmVteUhwTXVsdGlwbGllciIsImFjY2VsZXJhdGlvbiIsImVuZW15RHBzTXVsdGlwbGllciIsIm1heFNwZWVkIiwib2JqIiwiaHAiLCJ0YXJnZXQiLCJ1bmRlZmluZWQiLCJ1cGRhdGUiLCJkdCIsInB1bHNlIiwiY2hpbGRyZW4iLCJ5Iiwic3ViIiwiZGlzdGFuY2UiLCJsZW5ndGgiLCJub3JtYWxpemUiLCJhaW1Bc3Npc3QiLCJNYXRoVXRpbHMiLCJsZXJwIiwiZW5lbXlBY2N1cmFjeSIsImFkZFNjYWxlZFZlY3RvciIsImNsYW1wZWQiLCJtaW4iLCJjbGFtcExlbmd0aCIsIm9uRGVhdGgiLCJyZW1vdmUiLCJfX2VuZW1pZXMiLCJwdXNoIiwidXBkYXRlRW5lbWllcyIsImFyciIsImUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/enemies/stellated-octahedron/behavior.ts\n"));

/***/ })

});