"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/weapons/gatling.ts":
/*!********************************!*\
  !*** ./src/weapons/gatling.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGatlingSystem: () => (/* binding */ createGatlingSystem),\n/* harmony export */   createGatlingVisual: () => (/* binding */ createGatlingVisual)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst DEFAULT_FORWARD = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);\nconst TMP_DIRECTION = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst TMP_POSITION = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst TMP_QUATERNION = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nfunction createGatlingSystem(options) {\n    const state = {\n        ammo: options.ammo,\n        heat: 0,\n        overheated: false,\n        tracers: [],\n        accumulator: 0\n    };\n    let tracerId = 0;\n    function spawnTracer(context) {\n        const tracer = {\n            id: ++tracerId,\n            origin: context.position.clone(),\n            direction: context.forward.clone(),\n            lifeMs: options.tracerLifeMs\n        };\n        // 1. Impose deterministic spread so tests can predictably assert ray casts.\n        const seed = tracer.id * 12.9898;\n        const yaw = Math.sin(seed) * 0.5 * options.spread;\n        const pitch = Math.sin(seed * 0.5) * 0.5 * options.spread;\n        const rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Euler(pitch, yaw, 0, 'XYZ');\n        tracer.direction.applyEuler(rotation).normalize();\n        if (state.tracers.length >= options.maxTracers) {\n            state.tracers.shift();\n        }\n        state.tracers.push(tracer);\n        return tracer;\n    }\n    function coolDown(dt) {\n        // 2. Dissipate heat over time so prolonged bursts eventually recover.\n        if (state.heat > 0) {\n            state.heat = Math.max(0, state.heat - options.coolRate * dt);\n            if (state.overheated && state.heat <= options.overheatThreshold * 0.25) {\n                state.overheated = false;\n            }\n        }\n    }\n    function update(context, triggerHeld) {\n        const dt = context.dt;\n        for(let i = state.tracers.length - 1; i >= 0; i--){\n            const tracer = state.tracers[i];\n            tracer.lifeMs -= dt * 1000;\n            if (tracer.lifeMs <= 0) {\n                state.tracers.splice(i, 1);\n            }\n        }\n        if (!triggerHeld) {\n            // 3. When idle, only cool the barrels.\n            coolDown(dt);\n            state.accumulator = 0;\n            return {\n                shots: 0\n            };\n        }\n        if (state.overheated || state.ammo <= 0) {\n            coolDown(dt);\n            return {\n                shots: 0\n            };\n        }\n        state.accumulator += dt * options.fireRate;\n        let shots = 0;\n        while(state.accumulator >= 1 && state.ammo > 0 && !state.overheated){\n            spawnTracer(context);\n            state.accumulator -= 1;\n            state.ammo -= 1;\n            state.heat += options.heatPerShot;\n            shots++;\n            if (state.heat >= options.overheatThreshold) {\n                // 4. Flag the weapon as overheated so callers must ease off the trigger.\n                state.overheated = true;\n            }\n        }\n        coolDown(dt);\n        return {\n            shots\n        };\n    }\n    return {\n        update,\n        get state () {\n            return state;\n        },\n        get ammo () {\n            return state.ammo;\n        },\n        get overheated () {\n            return state.overheated;\n        }\n    };\n}\nfunction createGatlingVisual(scene, options) {\n    let palette = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n        tracerColor: 0xffff00\n    };\n    const tracers = [];\n    const tracerSpeed = 200; // Assumed units/sec for tracer travel; tweak as needed\n    const tracerLength = 1; // Fixed segment length for visibility\n    // Pre-create maxTracers meshes for reuse (pooling for perf)\n    for(let i = 0; i < options.maxTracers; i++){\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: palette.tracerColor,\n            transparent: true,\n            opacity: 0.8,\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending,\n            depthWrite: false\n        });\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.1, 0.1, tracerLength);\n        geometry.translate(0, 0, -tracerLength / 2); // Center the segment\n        const tracer = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n        tracer.visible = false;\n        scene.add(tracer);\n        tracers.push(tracer);\n    }\n    let activeTracerIndex = 0; // For cycling through pool\n    function update(state) {\n        // 1. Update existing tracers: Move forward, fade, and hide expired ones.\n        for(let i = 0; i < state.tracers.length; i++){\n            const tracerState = state.tracers[i];\n            const tracerMesh = tracers[activeTracerIndex];\n            activeTracerIndex = (activeTracerIndex + 1) % options.maxTracers;\n            if (tracerState.lifeMs <= 0) {\n                tracerMesh.visible = false;\n                continue;\n            }\n            TMP_DIRECTION.copy(tracerState.direction).normalize();\n            tracerMesh.visible = true;\n            // 2. Position: Start at origin, advance based on elapsed time.\n            const elapsed = (options.tracerLifeMs - tracerState.lifeMs) / 1000; // Sec since spawn\n            TMP_POSITION.copy(tracerState.origin).addScaledVector(TMP_DIRECTION, tracerSpeed * elapsed);\n            tracerMesh.position.copy(TMP_POSITION);\n            // 3. Orient to direction.\n            TMP_QUATERNION.setFromUnitVectors(DEFAULT_FORWARD, TMP_DIRECTION);\n            tracerMesh.quaternion.copy(TMP_QUATERNION);\n            // 4. Fade opacity over life.\n            const progress = 1 - tracerState.lifeMs / options.tracerLifeMs;\n            tracerMesh.material.opacity = 0.8 * (1 - progress);\n            // Optional: Modulate for heat (global overheat tint).\n            if (state.overheated && palette.heatColor) {\n                tracerMesh.material.color.setHex(palette.heatColor);\n            } else {\n                tracerMesh.material.color.setHex(palette.tracerColor);\n            }\n        }\n        // Hide unused tracers.\n        for(let i = state.tracers.length; i < options.maxTracers; i++){\n            tracers[i % options.maxTracers].visible = false;\n        }\n    }\n    function dispose() {\n        // 5. Release GPU buffers when the owning entity despawns to prevent leaks.\n        tracers.forEach((tracer)=>{\n            scene.remove(tracer);\n            tracer.geometry.dispose();\n            tracer.material.dispose();\n        });\n    }\n    return {\n        update,\n        dispose,\n        tracers\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93ZWFwb25zL2dhdGxpbmcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBa0MvQixNQUFNQyxrQkFBa0IsSUFBSUQsMENBQWEsQ0FBQyxHQUFHLEdBQUc7QUFDaEQsTUFBTUcsZ0JBQWdCLElBQUlILDBDQUFhO0FBQ3ZDLE1BQU1JLGVBQWUsSUFBSUosMENBQWE7QUFDdEMsTUFBTUssaUJBQWlCLElBQUlMLDZDQUFnQjtBQUVwQyxTQUFTTyxvQkFBb0JDLE9BQXVCO0lBQ3pELE1BQU1DLFFBQXNCO1FBQzFCQyxNQUFNRixRQUFRRSxJQUFJO1FBQ2xCQyxNQUFNO1FBQ05DLFlBQVk7UUFDWkMsU0FBUyxFQUFFO1FBQ1hDLGFBQWE7SUFDZjtJQUNBLElBQUlDLFdBQVc7SUFFZixTQUFTQyxZQUFZQyxPQUFzQjtRQUN6QyxNQUFNQyxTQUFzQjtZQUMxQkMsSUFBSSxFQUFFSjtZQUNOSyxRQUFRSCxRQUFRSSxRQUFRLENBQUNDLEtBQUs7WUFDOUJDLFdBQVdOLFFBQVFPLE9BQU8sQ0FBQ0YsS0FBSztZQUNoQ0csUUFBUWpCLFFBQVFrQixZQUFZO1FBQzlCO1FBQ0EsNEVBQTRFO1FBQzVFLE1BQU1DLE9BQU9ULE9BQU9DLEVBQUUsR0FBRztRQUN6QixNQUFNUyxNQUFNLEtBQU1FLEdBQUcsQ0FBQ0gsUUFBUSxNQUFPbkIsUUFBUXVCLE1BQU07UUFDbkQsTUFBTUMsUUFBUSxLQUFNRixHQUFHLENBQUNILE9BQU8sT0FBTyxNQUFPbkIsUUFBUXVCLE1BQU07UUFDM0QsTUFBTUUsV0FBVyxJQUFJakMsd0NBQVcsQ0FBQ2dDLE9BQU9KLEtBQUssR0FBRztRQUNoRFYsT0FBT0ssU0FBUyxDQUFDWSxVQUFVLENBQUNGLFVBQVVHLFNBQVM7UUFDL0MsSUFBSTNCLE1BQU1JLE9BQU8sQ0FBQ3dCLE1BQU0sSUFBSTdCLFFBQVE4QixVQUFVLEVBQUU7WUFDOUM3QixNQUFNSSxPQUFPLENBQUMwQixLQUFLO1FBQ3JCO1FBQ0E5QixN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LENBQTZCSSxPQUFPLEdBQUcsTUFBTyxLQUFJa0IsUUFBTztZQUU3RSxzREFBc0Q7WUFDdEQsSUFBSXhFLE1BQU1HLFVBQVUsSUFBSTJDLFFBQVEyQixTQUFTLEVBQUU7Z0JBQ3hDUCxXQUFXaEIsUUFBUSxDQUE2QkUsS0FBSyxDQUFDc0IsTUFBTSxDQUFDNUIsUUFBUTJCLFNBQVM7WUFDakYsT0FBTztnQkFDSlAsV0FBV2hCLFFBQVEsQ0FBNkJFLEtBQUssQ0FBQ3NCLE1BQU0sQ0FBQzVCLFFBQVFDLFdBQVc7WUFDbkY7UUFDRjtRQUVBLHVCQUF1QjtRQUN2QixJQUFLLElBQUlSLElBQUl2QyxNQUFNSSxPQUFPLENBQUN3QixNQUFNLEVBQUVXLElBQUl4QyxRQUFROEIsVUFBVSxFQUFFVSxJQUFLO1lBQzlEbkMsT0FBTyxDQUFDbUMsSUFBSXhDLFFBQVE4QixVQUFVLENBQUMsQ0FBQ2lDLE9BQU8sR0FBRztRQUM1QztJQUNGO0lBRUEsU0FBU2E7UUFDUCwyRUFBMkU7UUFDM0V2RSxRQUFRd0UsT0FBTyxDQUFDbkUsQ0FBQUE7WUFDZG9DLE1BQU1nQyxNQUFNLENBQUNwRTtZQUNiQSxPQUFPaUQsUUFBUSxDQUFDaUIsT0FBTztZQUN2QmxFLE9BQU95QyxRQUFRLENBQUN5QixPQUFPO1FBQ3pCO0lBQ0Y7SUFFQSxPQUFPO1FBQUV0QztRQUFRc0M7UUFBU3ZFO0lBQVE7QUFDcEMiLCJzb3VyY2VzIjpbIi9hcHAvc3JjL3dlYXBvbnMvZ2F0bGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBXZWFwb25Db250ZXh0IH0gZnJvbSAnQC93ZWFwb25zL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgR2F0bGluZ09wdGlvbnMgPSB7XG4gIGZpcmVSYXRlOiBudW1iZXI7XG4gIHNwcmVhZDogbnVtYmVyO1xuICBtYXhUcmFjZXJzOiBudW1iZXI7XG4gIHRyYWNlckxpZmVNczogbnVtYmVyO1xuICBhbW1vOiBudW1iZXI7XG4gIGhlYXRQZXJTaG90OiBudW1iZXI7XG4gIGNvb2xSYXRlOiBudW1iZXI7XG4gIG92ZXJoZWF0VGhyZXNob2xkOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBUcmFjZXJTdGF0ZSA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgb3JpZ2luOiBUSFJFRS5WZWN0b3IzO1xuICBkaXJlY3Rpb246IFRIUkVFLlZlY3RvcjM7XG4gIGxpZmVNczogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgR2F0bGluZ1N0YXRlID0ge1xuICBhbW1vOiBudW1iZXI7XG4gIGhlYXQ6IG51bWJlcjtcbiAgb3ZlcmhlYXRlZDogYm9vbGVhbjtcbiAgdHJhY2VyczogVHJhY2VyU3RhdGVbXTtcbiAgYWNjdW11bGF0b3I6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEdhdGxpbmdQYWxldHRlID0ge1xuICB0cmFjZXJDb2xvcjogbnVtYmVyO1xuICBoZWF0Q29sb3I/OiBudW1iZXI7IC8vIE9wdGlvbmFsIGZvciBvdmVyaGVhdCB0aW50XG59O1xuXG5jb25zdCBERUZBVUxUX0ZPUldBUkQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcbmNvbnN0IFRNUF9ESVJFQ1RJT04gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuY29uc3QgVE1QX1BPU0lUSU9OID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNvbnN0IFRNUF9RVUFURVJOSU9OID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdhdGxpbmdTeXN0ZW0ob3B0aW9uczogR2F0bGluZ09wdGlvbnMpIHtcbiAgY29uc3Qgc3RhdGU6IEdhdGxpbmdTdGF0ZSA9IHtcbiAgICBhbW1vOiBvcHRpb25zLmFtbW8sXG4gICAgaGVhdDogMCxcbiAgICBvdmVyaGVhdGVkOiBmYWxzZSxcbiAgICB0cmFjZXJzOiBbXSxcbiAgICBhY2N1bXVsYXRvcjogMCxcbiAgfTtcbiAgbGV0IHRyYWNlcklkID0gMDtcblxuICBmdW5jdGlvbiBzcGF3blRyYWNlcihjb250ZXh0OiBXZWFwb25Db250ZXh0KSB7XG4gICAgY29uc3QgdHJhY2VyOiBUcmFjZXJTdGF0ZSA9IHtcbiAgICAgIGlkOiArK3RyYWNlcklkLFxuICAgICAgb3JpZ2luOiBjb250ZXh0LnBvc2l0aW9uLmNsb25lKCksXG4gICAgICBkaXJlY3Rpb246IGNvbnRleHQuZm9yd2FyZC5jbG9uZSgpLFxuICAgICAgbGlmZU1zOiBvcHRpb25zLnRyYWNlckxpZmVNcyxcbiAgICB9O1xuICAgIC8vIDEuIEltcG9zZSBkZXRlcm1pbmlzdGljIHNwcmVhZCBzbyB0ZXN0cyBjYW4gcHJlZGljdGFibHkgYXNzZXJ0IHJheSBjYXN0cy5cbiAgICBjb25zdCBzZWVkID0gdHJhY2VyLmlkICogMTIuOTg5ODtcbiAgICBjb25zdCB5YXcgPSAoTWF0aC5zaW4oc2VlZCkgKiAwLjUpICogb3B0aW9ucy5zcHJlYWQ7XG4gICAgY29uc3QgcGl0Y2ggPSAoTWF0aC5zaW4oc2VlZCAqIDAuNSkgKiAwLjUpICogb3B0aW9ucy5zcHJlYWQ7XG4gICAgY29uc3Qgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIocGl0Y2gsIHlhdywgMCwgJ1hZWicpO1xuICAgIHRyYWNlci5kaXJlY3Rpb24uYXBwbHlFdWxlcihyb3RhdGlvbikubm9ybWFsaXplKCk7XG4gICAgaWYgKHN0YXRlLnRyYWNlcnMubGVuZ3RoID49IG9wdGlvbnMubWF4VHJhY2Vycykge1xuICAgICAgc3RhdGUudHJhY2Vycy5zaGlmdCgpO1xuICAgIH1cbiAgICBzdGF0ZS50cmFjZXJzLnB1c2godHJhY2VyKTtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gY29vbERvd24oZHQ6IG51bWJlcikge1xuICAgIC8vIDIuIERpc3NpcGF0ZSBoZWF0IG92ZXIgdGltZSBzbyBwcm9sb25nZWQgYnVyc3RzIGV2ZW50dWFsbHkgcmVjb3Zlci5cbiAgICBpZiAoc3RhdGUuaGVhdCA+IDApIHtcbiAgICAgIHN0YXRlLmhlYXQgPSBNYXRoLm1heCgwLCBzdGF0ZS5oZWF0IC0gb3B0aW9ucy5jb29sUmF0ZSAqIGR0KTtcbiAgICAgIGlmIChzdGF0ZS5vdmVyaGVhdGVkICYmIHN0YXRlLmhlYXQgPD0gb3B0aW9ucy5vdmVyaGVhdFRocmVzaG9sZCAqIDAuMjUpIHtcbiAgICAgICAgc3RhdGUub3ZlcmhlYXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShjb250ZXh0OiBXZWFwb25Db250ZXh0LCB0cmlnZ2VySGVsZDogYm9vbGVhbikge1xuICAgIGNvbnN0IGR0ID0gY29udGV4dC5kdDtcbiAgICBmb3IgKGxldCBpID0gc3RhdGUudHJhY2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdHJhY2VyID0gc3RhdGUudHJhY2Vyc1tpXTtcbiAgICAgIHRyYWNlci5saWZlTXMgLT0gZHQgKiAxMDAwO1xuICAgICAgaWYgKHRyYWNlci5saWZlTXMgPD0gMCkge1xuICAgICAgICBzdGF0ZS50cmFjZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cmlnZ2VySGVsZCkge1xuICAgICAgLy8gMy4gV2hlbiBpZGxlLCBvbmx5IGNvb2wgdGhlIGJhcnJlbHMuXG4gICAgICBjb29sRG93bihkdCk7XG4gICAgICBzdGF0ZS5hY2N1bXVsYXRvciA9IDA7XG4gICAgICByZXR1cm4geyBzaG90czogMCB9O1xuICAgIH1cbiAgICBpZiAoc3RhdGUub3ZlcmhlYXRlZCB8fCBzdGF0ZS5hbW1vIDw9IDApIHtcbiAgICAgIGNvb2xEb3duKGR0KTtcbiAgICAgIHJldHVybiB7IHNob3RzOiAwIH07XG4gICAgfVxuICAgIHN0YXRlLmFjY3VtdWxhdG9yICs9IGR0ICogb3B0aW9ucy5maXJlUmF0ZTtcbiAgICBsZXQgc2hvdHMgPSAwO1xuICAgIHdoaWxlIChzdGF0ZS5hY2N1bXVsYXRvciA+PSAxICYmIHN0YXRlLmFtbW8gPiAwICYmICFzdGF0ZS5vdmVyaGVhdGVkKSB7XG4gICAgICBzcGF3blRyYWNlcihjb250ZXh0KTtcbiAgICAgIHN0YXRlLmFjY3VtdWxhdG9yIC09IDE7XG4gICAgICBzdGF0ZS5hbW1vIC09IDE7XG4gICAgICBzdGF0ZS5oZWF0ICs9IG9wdGlvbnMuaGVhdFBlclNob3Q7XG4gICAgICBzaG90cysrO1xuICAgICAgaWYgKHN0YXRlLmhlYXQgPj0gb3B0aW9ucy5vdmVyaGVhdFRocmVzaG9sZCkge1xuICAgICAgICAvLyA0LiBGbGFnIHRoZSB3ZWFwb24gYXMgb3ZlcmhlYXRlZCBzbyBjYWxsZXJzIG11c3QgZWFzZSBvZmYgdGhlIHRyaWdnZXIuXG4gICAgICAgIHN0YXRlLm92ZXJoZWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb29sRG93bihkdCk7XG4gICAgcmV0dXJuIHsgc2hvdHMgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlLFxuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHN0YXRlOyB9LFxuICAgIGdldCBhbW1vKCkgeyByZXR1cm4gc3RhdGUuYW1tbzsgfSxcbiAgICBnZXQgb3ZlcmhlYXRlZCgpIHsgcmV0dXJuIHN0YXRlLm92ZXJoZWF0ZWQ7IH0sXG4gIH07XG59XG5cbmV4cG9ydCB0eXBlIEdhdGxpbmdWaXN1YWwgPSB7XG4gIHVwZGF0ZTogKHN0YXRlOiBHYXRsaW5nU3RhdGUpID0+IHZvaWQ7XG4gIGRpc3Bvc2U6ICgpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IHRyYWNlcnM6IFRIUkVFLk1lc2hbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHYXRsaW5nVmlzdWFsKHNjZW5lOiBUSFJFRS5TY2VuZSwgb3B0aW9uczogR2F0bGluZ09wdGlvbnMsIHBhbGV0dGU6IEdhdGxpbmdQYWxldHRlID0geyB0cmFjZXJDb2xvcjogMHhmZmZmMDAgfSk6IEdhdGxpbmdWaXN1YWwge1xuICBjb25zdCB0cmFjZXJzOiBUSFJFRS5NZXNoW10gPSBbXTtcbiAgY29uc3QgdHJhY2VyU3BlZWQgPSAyMDA7IC8vIEFzc3VtZWQgdW5pdHMvc2VjIGZvciB0cmFjZXIgdHJhdmVsOyB0d2VhayBhcyBuZWVkZWRcbiAgY29uc3QgdHJhY2VyTGVuZ3RoID0gMTsgLy8gRml4ZWQgc2VnbWVudCBsZW5ndGggZm9yIHZpc2liaWxpdHlcblxuICAvLyBQcmUtY3JlYXRlIG1heFRyYWNlcnMgbWVzaGVzIGZvciByZXVzZSAocG9vbGluZyBmb3IgcGVyZilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLm1heFRyYWNlcnM7IGkrKykge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiBwYWxldHRlLnRyYWNlckNvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDAuMSwgMC4xLCB0cmFjZXJMZW5ndGgpO1xuICAgIGdlb21ldHJ5LnRyYW5zbGF0ZSgwLCAwLCAtdHJhY2VyTGVuZ3RoIC8gMik7IC8vIENlbnRlciB0aGUgc2VnbWVudFxuICAgIGNvbnN0IHRyYWNlciA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdHJhY2VyLnZpc2libGUgPSBmYWxzZTtcbiAgICBzY2VuZS5hZGQodHJhY2VyKTtcbiAgICB0cmFjZXJzLnB1c2godHJhY2VyKTtcbiAgfVxuXG4gIGxldCBhY3RpdmVUcmFjZXJJbmRleCA9IDA7IC8vIEZvciBjeWNsaW5nIHRocm91Z2ggcG9vbFxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZTogR2F0bGluZ1N0YXRlKSB7XG4gICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIHRyYWNlcnM6IE1vdmUgZm9yd2FyZCwgZmFkZSwgYW5kIGhpZGUgZXhwaXJlZCBvbmVzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhY2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHJhY2VyU3RhdGUgPSBzdGF0ZS50cmFjZXJzW2ldO1xuICAgICAgY29uc3QgdHJhY2VyTWVzaCA9IHRyYWNlcnNbYWN0aXZlVHJhY2VySW5kZXhdO1xuICAgICAgYWN0aXZlVHJhY2VySW5kZXggPSAoYWN0aXZlVHJhY2VySW5kZXggKyAxKSAlIG9wdGlvbnMubWF4VHJhY2VycztcblxuICAgICAgaWYgKHRyYWNlclN0YXRlLmxpZmVNcyA8PSAwKSB7XG4gICAgICAgIHRyYWNlck1lc2gudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgVE1QX0RJUkVDVElPTi5jb3B5KHRyYWNlclN0YXRlLmRpcmVjdGlvbikubm9ybWFsaXplKCk7XG4gICAgICB0cmFjZXJNZXNoLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAvLyAyLiBQb3NpdGlvbjogU3RhcnQgYXQgb3JpZ2luLCBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZS5cbiAgICAgIGNvbnN0IGVsYXBzZWQgPSAob3B0aW9ucy50cmFjZXJMaWZlTXMgLSB0cmFjZXJTdGF0ZS5saWZlTXMpIC8gMTAwMDsgLy8gU2VjIHNpbmNlIHNwYXduXG4gICAgICBUTVBfUE9TSVRJT04uY29weSh0cmFjZXJTdGF0ZS5vcmlnaW4pLmFkZFNjYWxlZFZlY3RvcihUTVBfRElSRUNUSU9OLCB0cmFjZXJTcGVlZCAqIGVsYXBzZWQpO1xuICAgICAgdHJhY2VyTWVzaC5wb3NpdGlvbi5jb3B5KFRNUF9QT1NJVElPTik7XG5cbiAgICAgIC8vIDMuIE9yaWVudCB0byBkaXJlY3Rpb24uXG4gICAgICBUTVBfUVVBVEVSTklPTi5zZXRGcm9tVW5pdFZlY3RvcnMoREVGQVVMVF9GT1JXQVJELCBUTVBfRElSRUNUSU9OKTtcbiAgICAgIHRyYWNlck1lc2gucXVhdGVybmlvbi5jb3B5KFRNUF9RVUFURVJOSU9OKTtcblxuICAgICAgLy8gNC4gRmFkZSBvcGFjaXR5IG92ZXIgbGlmZS5cbiAgICAgIGNvbnN0IHByb2dyZXNzID0gMSAtICh0cmFjZXJTdGF0ZS5saWZlTXMgLyBvcHRpb25zLnRyYWNlckxpZmVNcyk7XG4gICAgICAodHJhY2VyTWVzaC5tYXRlcmlhbCBhcyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuOCAqICgxIC0gcHJvZ3Jlc3MpO1xuXG4gICAgICAvLyBPcHRpb25hbDogTW9kdWxhdGUgZm9yIGhlYXQgKGdsb2JhbCBvdmVyaGVhdCB0aW50KS5cbiAgICAgIGlmIChzdGF0ZS5vdmVyaGVhdGVkICYmIHBhbGV0dGUuaGVhdENvbG9yKSB7XG4gICAgICAgICh0cmFjZXJNZXNoLm1hdGVyaWFsIGFzIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKS5jb2xvci5zZXRIZXgocGFsZXR0ZS5oZWF0Q29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHRyYWNlck1lc2gubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLnNldEhleChwYWxldHRlLnRyYWNlckNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIaWRlIHVudXNlZCB0cmFjZXJzLlxuICAgIGZvciAobGV0IGkgPSBzdGF0ZS50cmFjZXJzLmxlbmd0aDsgaSA8IG9wdGlvbnMubWF4VHJhY2VyczsgaSsrKSB7XG4gICAgICB0cmFjZXJzW2kgJSBvcHRpb25zLm1heFRyYWNlcnNdLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIDUuIFJlbGVhc2UgR1BVIGJ1ZmZlcnMgd2hlbiB0aGUgb3duaW5nIGVudGl0eSBkZXNwYXducyB0byBwcmV2ZW50IGxlYWtzLlxuICAgIHRyYWNlcnMuZm9yRWFjaCh0cmFjZXIgPT4ge1xuICAgICAgc2NlbmUucmVtb3ZlKHRyYWNlcik7XG4gICAgICB0cmFjZXIuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdHJhY2VyLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7IHVwZGF0ZSwgZGlzcG9zZSwgdHJhY2VycyB9O1xufSJdLCJuYW1lcyI6WyJUSFJFRSIsIkRFRkFVTFRfRk9SV0FSRCIsIlZlY3RvcjMiLCJUTVBfRElSRUNUSU9OIiwiVE1QX1BPU0lUSU9OIiwiVE1QX1FVQVRFUk5JT04iLCJRdWF0ZXJuaW9uIiwiY3JlYXRlR2F0bGluZ1N5c3RlbSIsIm9wdGlvbnMiLCJzdGF0ZSIsImFtbW8iLCJoZWF0Iiwib3ZlcmhlYXRlZCIsInRyYWNlcnMiLCJhY2N1bXVsYXRvciIsInRyYWNlcklkIiwic3Bhd25UcmFjZXIiLCJjb250ZXh0IiwidHJhY2VyIiwiaWQiLCJvcmlnaW4iLCJwb3NpdGlvbiIsImNsb25lIiwiZGlyZWN0aW9uIiwiZm9yd2FyZCIsImxpZmVNcyIsInRyYWNlckxpZmVNcyIsInNlZWQiLCJ5YXciLCJNYXRoIiwic2luIiwic3ByZWFkIiwicGl0Y2giLCJyb3RhdGlvbiIsIkV1bGVyIiwiYXBwbHlFdWxlciIsIm5vcm1hbGl6ZSIsImxlbmd0aCIsIm1heFRyYWNlcnMiLCJzaGlmdCIsInB1c2giLCJjb29sRG93biIsImR0IiwibWF4IiwiY29vbFJhdGUiLCJvdmVyaGVhdFRocmVzaG9sZCIsInVwZGF0ZSIsInRyaWdnZXJIZWxkIiwiaSIsInNwbGljZSIsInNob3RzIiwiZmlyZVJhdGUiLCJoZWF0UGVyU2hvdCIsImNyZWF0ZUdhdGxpbmdWaXN1YWwiLCJzY2VuZSIsInBhbGV0dGUiLCJ0cmFjZXJDb2xvciIsInRyYWNlclNwZWVkIiwidHJhY2VyTGVuZ3RoIiwibWF0ZXJpYWwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsImNvbG9yIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsImdlb21ldHJ5IiwiQm94R2VvbWV0cnkiLCJ0cmFuc2xhdGUiLCJNZXNoIiwidmlzaWJsZSIsImFkZCIsImFjdGl2ZVRyYWNlckluZGV4IiwidHJhY2VyU3RhdGUiLCJ0cmFjZXJNZXNoIiwiY29weSIsImVsYXBzZWQiLCJhZGRTY2FsZWRWZWN0b3IiLCJzZXRGcm9tVW5pdFZlY3RvcnMiLCJxdWF0ZXJuaW9uIiwicHJvZ3Jlc3MiLCJoZWF0Q29sb3IiLCJzZXRIZXgiLCJkaXNwb3NlIiwiZm9yRWFjaCIsInJlbW92ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/weapons/gatling.ts\n"));

/***/ })

});