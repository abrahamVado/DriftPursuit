"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 512;\nconst VERTS_NEAR = 64; // High detail for close chunks\nconst VERTS_FAR = 32; // Low detail for distant chunks\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS_NEAR = 2; // High-detail ring\nconst ACTIVE_RADIUS_FAR = 4; // Low-detail outer ring\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    })\n};\nfunction buildChunk(ix, iz, detailLevel) {\n    const verts = detailLevel === 'near' ? VERTS_NEAR : VERTS_FAR;\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, verts, verts);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // Optional: UV scaling or noise for texture tiling\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 4, uv.getY(i) * 4); // Tile texture 4x for variety\n    }\n    uv.needsUpdate = true;\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(g, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false; // Terrain doesn't cast\n    mesh.userData = {\n        ix,\n        iz,\n        detailLevel,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        }\n    };\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations idempotently with proper disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        obj.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                child.geometry.dispose();\n                const material = child.material;\n                if (Array.isArray(material)) {\n                    var _mat_dispose;\n                    for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                } else {\n                    var _material_dispose;\n                    (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                }\n            }\n        });\n    }\n    mesh.userData.decorations = [];\n    const { propDensity } = envCache; // windStrength no longer used\n    const propCount = Math.max(0, Math.round(propDensity * 16)); // Increased density for richness\n    const windCount = 0; // Always 0 - wind removed\n    // Rocks: Use InstancedMesh for batching (perf win for many props)\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1); // Slight detail\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5; // Slight elevation var\n            tmpPos.set(localX, y, localZ);\n            // Alignment quaternion (up vector to normal)\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, normalVec);\n            // Random rotation quaternion (on top of alignment)\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            // Compose matrix\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Removed entirely\n    // Add subtle fog plane for atmospheric depth (per chunk, low poly) - Adjusted opacity without wind\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0; // No longer used for wind\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        // 1. Mark dirty on env change; rebuild decorations next update.\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    function ensure(ix, iz, detailLevel) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) {\n            // Upgrade/downgrade detail if needed\n            const existing = chunks.get(k);\n            if (existing.userData.detailLevel !== detailLevel) {\n                scene.remove(existing);\n                disposeChunk(existing);\n                chunks.delete(k);\n            } else {\n                return;\n            }\n        }\n        const mesh = buildChunk(ix, iz, detailLevel);\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > ACTIVE_RADIUS_FAR) {\n                scene.remove(m);\n                disposeChunk(m);\n                chunks.delete(k);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        // Comprehensive disposal: Geoms, mats (skip shared), instances\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            mesh.remove(deco);\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose(); // Releases instance buffer\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    // Don't dispose shared materials here\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            // Dynamic radius based on envCache (e.g., denser fog = smaller radius) - propDensity only now\n            const effectiveNear = Math.max(1, ACTIVE_RADIUS_NEAR);\n            const effectiveFar = Math.max(3, ACTIVE_RADIUS_FAR - envCache.propDensity * 0.2);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // Ensure near chunks (high detail)\n            for(let dz = -effectiveNear; dz <= effectiveNear; dz++){\n                for(let dx = -effectiveNear; dx <= effectiveNear; dx++){\n                    ensure(cx + dx, cz + dz, 'near');\n                }\n            }\n            // Ensure far chunks (low detail)\n            for(let dz = -effectiveFar; dz <= effectiveFar; dz++){\n                for(let dx = -effectiveFar; dx <= effectiveFar; dx++){\n                    if (Math.max(Math.abs(dx), Math.abs(dz)) > effectiveNear) {\n                        ensure(cx + dx, cz + dz, 'far');\n                    }\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                }\n                environmentDirty = false;\n            }\n        // Animate wind columns - Removed\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            // 1. Cleanup: Unsub, prune all, dispose shared mats.\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            // Dispose shared materials\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLGFBQWEsSUFBSSwrQkFBK0I7QUFDdEQsTUFBTUMsWUFBWSxJQUFJLGdDQUFnQztBQUN0RCxNQUFNQyxPQUFPSCxhQUFhO0FBQzFCLE1BQU1JLHFCQUFxQixHQUFHLG1CQUFtQjtBQUNqRCxNQUFNQyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFFckQsU0FBU0MsSUFBSUMsRUFBVSxFQUFFQyxFQUFVO0lBQUksT0FBTyxHQUFTQSxPQUFORCxJQUFHLEtBQU0sT0FBSEM7QUFBTTtBQUM3RCxTQUFTQyxRQUFRQyxDQUFTO0lBQUksT0FBT0MsS0FBS0MsS0FBSyxDQUFDRixJQUFJVjtBQUFhO0FBRWpFLElBQUlhLFdBQVdmLHNFQUFrQkEsR0FBR2dCLFdBQVc7QUFFL0MsaUVBQWlFO0FBQ2pFLE1BQU1DLGtCQUFrQjtJQUN0QkMsU0FBUyxJQUFJckIsdURBQTBCLENBQUM7UUFDdEN1QixPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsV0FBVztJQUViO0lBQ0FDLE1BQU0sSUFBSTFCLHVEQUEwQixDQUFDO1FBQ25DdUIsT0FBTztRQUNQQyxXQUFXO1FBQ1hDLFdBQVc7SUFDYjtBQUVGO0FBRUEsU0FBU0UsV0FBV2YsRUFBVSxFQUFFQyxFQUFVLEVBQUVlLFdBQTJCO0lBQ3JFLE1BQU1DLFFBQVFELGdCQUFnQixTQUFTdEIsYUFBYUM7SUFDcEQsTUFBTXVCLElBQUksSUFBSTlCLGdEQUFtQixDQUFDSyxZQUFZQSxZQUFZd0IsT0FBT0E7SUFDakVDLEVBQUVFLE9BQU8sQ0FBQyxDQUFDaEIsS0FBS2lCLEVBQUUsR0FBRztJQUVyQixNQUFNQyxNQUFNSixFQUFFSyxVQUFVLENBQUNDLFFBQVE7SUFDakMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLEtBQUssRUFB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QUFBLGtDQUFBQTtZQUNBLEtBQUssTUFBTVksS0FBS2pCLE9BQU82QixNQUFNLEdBQUk7Z0JBQy9CakIsYUFBYUs7WUFDZjtZQUNBakIsT0FBT2lDLEtBQUs7WUFFWiwyQkFBMkI7WUFDM0JDLE9BQU9MLE1BQU0sQ0FBQ3RJLGlCQUFpQjRJLE9BQU8sQ0FBQ3pGLENBQUFBO2dCQUNyQyxJQUFJRixNQUFNQyxPQUFPLENBQUNDLE1BQU07b0JBQ3RCQSxJQUFJeUYsT0FBTyxDQUFDbEIsQ0FBQUEsSUFBS0EsRUFBRTNFLE9BQU87Z0JBQzVCLE9BQU87b0JBQ0xJLElBQUlKLE9BQU87Z0JBQ2I7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2FwcC9zcmMvd29ybGQvY2h1bmtzL3N0cmVhbWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGhlaWdodEF0LCBub3JtYWxBdCB9IGZyb20gJy4vZ2VuZXJhdGVIZWlnaHQnO1xuaW1wb3J0IHsgZ2V0RGlmZmljdWx0eVN0YXRlLCBvbkRpZmZpY3VsdHlDaGFuZ2UgfSBmcm9tICdAL2VuZ2luZS9kaWZmaWN1bHR5JztcblxuY29uc3QgQ0hVTktfU0laRSA9IDUxMjtcbmNvbnN0IFZFUlRTX05FQVIgPSA2NDsgLy8gSGlnaCBkZXRhaWwgZm9yIGNsb3NlIGNodW5rc1xuY29uc3QgVkVSVFNfRkFSID0gMzI7IC8vIExvdyBkZXRhaWwgZm9yIGRpc3RhbnQgY2h1bmtzXG5jb25zdCBIQUxGID0gQ0hVTktfU0laRSAvIDI7XG5jb25zdCBBQ1RJVkVfUkFESVVTX05FQVIgPSAyOyAvLyBIaWdoLWRldGFpbCByaW5nXG5jb25zdCBBQ1RJVkVfUkFESVVTX0ZBUiA9IDQ7IC8vIExvdy1kZXRhaWwgb3V0ZXIgcmluZ1xuXG5mdW5jdGlvbiBrZXkoaXg6IG51bWJlciwgaXo6IG51bWJlcikgeyByZXR1cm4gYCR7aXh9LCR7aXp9YDsgfVxuZnVuY3Rpb24gdG9DaHVuayh4OiBudW1iZXIpIHsgcmV0dXJuIE1hdGguZmxvb3IoeCAvIENIVU5LX1NJWkUpOyB9XG5cbmxldCBlbnZDYWNoZSA9IGdldERpZmZpY3VsdHlTdGF0ZSgpLmVudmlyb25tZW50O1xuXG4vLyBTaGFyZWQgbWF0ZXJpYWxzIGZvciBlZmZpY2llbmN5IChkaXNwb3NlIG9uIHN0cmVhbWVyIHRlYXJkb3duKVxuY29uc3Qgc2hhcmVkTWF0ZXJpYWxzID0ge1xuICB0ZXJyYWluOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDUwNmE1MixcbiAgICByb3VnaG5lc3M6IDAuOTUsXG4gICAgbWV0YWxuZXNzOiAwLjAsXG4gICAgLy8gT3B0aW9uYWw6IEFkZCBtYXAvdGV4dHVyZSBpZiBhdmFpbGFibGU6IG1hcDogdGVycmFpblRleHR1cmUsXG4gIH0pLFxuICByb2NrOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDRhNGY0NCxcbiAgICByb3VnaG5lc3M6IDAuOCxcbiAgICBtZXRhbG5lc3M6IDAuMSxcbiAgfSksXG4gIC8vIHdpbmQ6IFJlbW92ZWQgLSBubyBsb25nZXIgbmVlZGVkXG59O1xuXG5mdW5jdGlvbiBidWlsZENodW5rKGl4OiBudW1iZXIsIGl6OiBudW1iZXIsIGRldGFpbExldmVsOiAnbmVhcicgfCAnZmFyJykge1xuICBjb25zdCB2ZXJ0cyA9IGRldGFpbExldmVsID09PSAnbmVhcicgPyBWRVJUU19ORUFSIDogVkVSVFNfRkFSO1xuICBjb25zdCBnID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSwgQ0hVTktfU0laRSwgdmVydHMsIHZlcnRzKTtcbiAgZy5yb3RhdGVYKC1NYXRoLlBJIC8gMik7XG5cbiAgY29uc3QgcG9zID0gZy5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHZ4ID0gcG9zLmdldFgoaSkgKyBpeCAqIENIVU5LX1NJWkU7XG4gICAgY29uc3QgdnogPSBwb3MuZ2V0WihpKSArIGl6ICogQ0hVTktfU0laRTtcbiAgICBjb25zdCBoID0gaGVpZ2h0QXQodngsIHZ6KTtcbiAgICBwb3Muc2V0WShpLCBoKTtcbiAgfVxuICBwb3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gT3B0aW9uYWw6IFVWIHNjYWxpbmcgb3Igbm9pc2UgZm9yIHRleHR1cmUgdGlsaW5nXG4gIGNvbnN0IHV2ID0gZy5hdHRyaWJ1dGVzLnV2IGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1di5jb3VudDsgaSsrKSB7XG4gICAgdXYuc2V0WFkoaSwgdXYuZ2V0WChpKSAqIDQsIHV2LmdldFkoaSkgKiA0KTsgLy8gVGlsZSB0ZXh0dXJlIDR4IGZvciB2YXJpZXR5XG4gIH1cbiAgdXYubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnLCBzaGFyZWRNYXRlcmlhbHMudGVycmFpbik7XG4gIG1lc2gucG9zaXRpb24uc2V0KGl4ICogQ0hVTktfU0laRSwgMCwgaXogKiBDSFVOS19TSVpFKTtcbiAgbWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgbWVzaC5jYXN0U2hhZG93ID0gZmFsc2U7IC8vIFRlcnJhaW4gZG9lc24ndCBjYXN0XG4gIG1lc2gudXNlckRhdGEgPSB7XG4gICAgaXgsXG4gICAgaXosXG4gICAgZGV0YWlsTGV2ZWwsXG4gICAgZGVjb3JhdGlvbnM6IFtdIGFzIFRIUkVFLk9iamVjdDNEW10sXG4gICAgaW5zdGFuY2VDb3VudHM6IHsgcm9ja3M6IDAsIHdpbmRzOiAwIH0sIC8vIEZvciBpbnN0YW5jZWQgY2xlYW51cFxuICB9O1xuXG4gIGRlY29yYXRlQ2h1bmsobWVzaCk7XG4gIHJldHVybiBtZXNoO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZUNodW5rKG1lc2g6IFRIUkVFLk1lc2gpIHtcbiAgLy8gMS4gQ2xlYXIgZXhpc3RpbmcgZGVjb3JhdGlvbnMgaWRlbXBvdGVudGx5IHdpdGggcHJvcGVyIGRpc3Bvc2FsLlxuICBjb25zdCBwcmV2aW91cyA9IG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPz8gW107XG4gIGZvciAoY29uc3Qgb2JqIG9mIHByZXZpb3VzKSB7XG4gICAgbWVzaC5yZW1vdmUob2JqKTtcbiAgICBvYmoudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXQgb2YgbWF0ZXJpYWwpIG1hdC5kaXNwb3NlPy4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlPy4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPSBbXTtcblxuICBjb25zdCB7IHByb3BEZW5zaXR5IH0gPSBlbnZDYWNoZTsgLy8gd2luZFN0cmVuZ3RoIG5vIGxvbmdlciB1c2VkXG4gIGNvbnN0IHByb3BDb3VudCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQocHJvcERlbnNpdHkgKiAxNikpOyAvLyBJbmNyZWFzZWQgZGVuc2l0eSBmb3IgcmljaG5lc3NcbiAgY29uc3Qgd2luZENvdW50ID0gMDsgLy8gQWx3YXlzIDAgLSB3aW5kIHJlbW92ZWRcblxuICAvLyBSb2NrczogVXNlIEluc3RhbmNlZE1lc2ggZm9yIGJhdGNoaW5nIChwZXJmIHdpbiBmb3IgbWFueSBwcm9wcylcbiAgaWYgKHByb3BDb3VudCA+IDApIHtcbiAgICBjb25zdCByb2NrR2VvID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoMS41ICsgTWF0aC5yYW5kb20oKSAqIDIuNSwgMSk7IC8vIFNsaWdodCBkZXRhaWxcbiAgICBjb25zdCByb2NrSW5zdGFuY2VzID0gbmV3IFRIUkVFLkluc3RhbmNlZE1lc2gocm9ja0dlbywgc2hhcmVkTWF0ZXJpYWxzLnJvY2ssIHByb3BDb3VudCk7XG4gICAgY29uc3Qgcm9ja01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgY29uc3QgdG1wUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0bXBRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICBjb25zdCB0bXBTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBsb2NhbFggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBDSFVOS19TSVpFO1xuICAgICAgY29uc3QgbG9jYWxaID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRTtcbiAgICAgIGNvbnN0IHdvcmxkWCA9IG1lc2gudXNlckRhdGEuaXggKiBDSFVOS19TSVpFICsgbG9jYWxYO1xuICAgICAgY29uc3Qgd29ybGRaID0gbWVzaC51c2VyRGF0YS5peiAqIENIVU5LX1NJWkUgKyBsb2NhbFo7XG4gICAgICBjb25zdCBiYXNlSGVpZ2h0ID0gaGVpZ2h0QXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3QgeSA9IGJhc2VIZWlnaHQgLSBtZXNoLnBvc2l0aW9uLnkgKyAxICsgTWF0aC5yYW5kb20oKSAqIDAuNTsgLy8gU2xpZ2h0IGVsZXZhdGlvbiB2YXJcbiAgICAgIHRtcFBvcy5zZXQobG9jYWxYLCB5LCBsb2NhbFopO1xuXG4gICAgICAvLyBBbGlnbm1lbnQgcXVhdGVybmlvbiAodXAgdmVjdG9yIHRvIG5vcm1hbClcbiAgICAgIGNvbnN0IG5vcm0gPSBub3JtYWxBdCh3b3JsZFgsIHdvcmxkWik7XG4gICAgICBjb25zdCB1cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICAgICAgY29uc3Qgbm9ybWFsVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMobm9ybS54LCBub3JtLnksIG5vcm0ueikubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnRRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnModXAsIG5vcm1hbFZlYyk7XG5cbiAgICAgIC8vIFJhbmRvbSByb3RhdGlvbiBxdWF0ZXJuaW9uIChvbiB0b3Agb2YgYWxpZ25tZW50KVxuICAgICAgY29uc3QgcmFuZG9tRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICdYWVonXG4gICAgICApO1xuICAgICAgY29uc3QgcmFuZG9tUXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKHJhbmRvbUV1bGVyKTtcbiAgICAgIHRtcFF1YXQuY29weShhbGlnbm1lbnRRdWF0KS5tdWx0aXBseShyYW5kb21RdWF0KTtcblxuICAgICAgLy8gU2NhbGVcbiAgICAgIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDtcbiAgICAgIHRtcFNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcblxuICAgICAgLy8gQ29tcG9zZSBtYXRyaXhcbiAgICAgIHJvY2tNYXRyaXguY29tcG9zZSh0bXBQb3MsIHRtcFF1YXQsIHRtcFNjYWxlKTtcbiAgICAgIHJvY2tJbnN0YW5jZXMuc2V0TWF0cml4QXQoaSwgcm9ja01hdHJpeCk7XG4gICAgfVxuICAgIHJvY2tJbnN0YW5jZXMuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJvY2tJbnN0YW5jZXMuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgcm9ja0luc3RhbmNlcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG4gICAgbWVzaC5hZGQocm9ja0luc3RhbmNlcyk7XG4gICAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucy5wdXNoKHJvY2tJbnN0YW5jZXMpO1xuICAgIG1lc2gudXNlckRhdGEuaW5zdGFuY2VDb3VudHMucm9ja3MgPSBwcm9wQ291bnQ7XG4gIH1cblxuICAvLyBXaW5kIGNvbHVtbnM6IFJlbW92ZWQgZW50aXJlbHlcblxuICAvLyBBZGQgc3VidGxlIGZvZyBwbGFuZSBmb3IgYXRtb3NwaGVyaWMgZGVwdGggKHBlciBjaHVuaywgbG93IHBvbHkpIC0gQWRqdXN0ZWQgb3BhY2l0eSB3aXRob3V0IHdpbmRcbiAgY29uc3QgZm9nR2VvID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSAqIDEuMiwgQ0hVTktfU0laRSAqIDEuMiwgMSwgMSk7XG4gIGNvbnN0IGZvZ01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4ODhjY2ZmLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIG9wYWNpdHk6IDAuMDUsIC8vIEZpeGVkIGxvdyB2YWx1ZSwgbm8gd2luZCB0aWUtaW5cbiAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICB9KTtcbiAgY29uc3QgZm9nID0gbmV3IFRIUkVFLk1lc2goZm9nR2VvLCBmb2dNYXQpO1xuICBmb2cucG9zaXRpb24uc2V0KDAsIDIwLCAwKTtcbiAgZm9nLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gIG1lc2guYWRkKGZvZyk7XG4gIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMucHVzaChmb2cpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtZXIoc2NlbmU6IFRIUkVFLlNjZW5lKSB7XG4gIGNvbnN0IGNodW5rcyA9IG5ldyBNYXA8c3RyaW5nLCBUSFJFRS5NZXNoPigpO1xuICBjb25zdCB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBsZXQgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlO1xuICBsZXQgYW5pbWF0aW9uVGltZSA9IDA7IC8vIE5vIGxvbmdlciB1c2VkIGZvciB3aW5kXG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBvbkRpZmZpY3VsdHlDaGFuZ2UoKHN0YXRlKSA9PiB7XG4gICAgLy8gMS4gTWFyayBkaXJ0eSBvbiBlbnYgY2hhbmdlOyByZWJ1aWxkIGRlY29yYXRpb25zIG5leHQgdXBkYXRlLlxuICAgIGVudkNhY2hlID0gc3RhdGUuZW52aXJvbm1lbnQ7XG4gICAgZW52aXJvbm1lbnREaXJ0eSA9IHRydWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZShpeDogbnVtYmVyLCBpejogbnVtYmVyLCBkZXRhaWxMZXZlbDogJ25lYXInIHwgJ2ZhcicpIHtcbiAgICBjb25zdCBrID0ga2V5KGl4LCBpeik7XG4gICAgaWYgKGNodW5rcy5oYXMoaykpIHtcbiAgICAgIC8vIFVwZ3JhZGUvZG93bmdyYWRlIGRldGFpbCBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gY2h1bmtzLmdldChrKSE7XG4gICAgICBpZiAoZXhpc3RpbmcudXNlckRhdGEuZGV0YWlsTGV2ZWwgIT09IGRldGFpbExldmVsKSB7XG4gICAgICAgIHNjZW5lLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhleGlzdGluZyk7XG4gICAgICAgIGNodW5rcy5kZWxldGUoayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWVzaCA9IGJ1aWxkQ2h1bmsoaXgsIGl6LCBkZXRhaWxMZXZlbCk7XG4gICAgY2h1bmtzLnNldChrLCBtZXNoKTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZShjZW50ZXJYOiBudW1iZXIsIGNlbnRlclo6IG51bWJlcikge1xuICAgIGZvciAoY29uc3QgW2ssIG1dIG9mIGNodW5rcykge1xuICAgICAgY29uc3QgZHggPSB0b0NodW5rKGNlbnRlclgpIC0gbS51c2VyRGF0YS5peDtcbiAgICAgIGNvbnN0IGR6ID0gdG9DaHVuayhjZW50ZXJaKSAtIG0udXNlckRhdGEuaXo7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeikpO1xuICAgICAgaWYgKGRpc3QgPiBBQ1RJVkVfUkFESVVTX0ZBUikge1xuICAgICAgICBzY2VuZS5yZW1vdmUobSk7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhtKTtcbiAgICAgICAgY2h1bmtzLmRlbGV0ZShrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlQ2h1bmsobWVzaDogVEhSRUUuTWVzaCkge1xuICAgIC8vIENvbXByZWhlbnNpdmUgZGlzcG9zYWw6IEdlb21zLCBtYXRzIChza2lwIHNoYXJlZCksIGluc3RhbmNlc1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIGNvbnN0IGRlY29yYXRpb25zID0gbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucyA/PyBbXTtcbiAgICBmb3IgKGNvbnN0IGRlY28gb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIG1lc2gucmVtb3ZlKGRlY28pO1xuICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRNZXNoKSB7XG4gICAgICAgIGRlY28uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICBkZWNvLmRpc3Bvc2UoKTsgLy8gUmVsZWFzZXMgaW5zdGFuY2UgYnVmZmVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNvLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICAgIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXQgb2YgbWF0ZXJpYWwpIG1hdC5kaXNwb3NlPy4oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLmRpc3Bvc2U/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERvbid0IGRpc3Bvc2Ugc2hhcmVkIG1hdGVyaWFscyBoZXJlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZShwb3M6IFRIUkVFLlZlY3RvcjMsIGR0OiBudW1iZXIpIHtcbiAgICAgIGFuaW1hdGlvblRpbWUgKz0gZHQ7XG5cbiAgICAgIC8vIER5bmFtaWMgcmFkaXVzIGJhc2VkIG9uIGVudkNhY2hlIChlLmcuLCBkZW5zZXIgZm9nID0gc21hbGxlciByYWRpdXMpIC0gcHJvcERlbnNpdHkgb25seSBub3dcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZU5lYXIgPSBNYXRoLm1heCgxLCBBQ1RJVkVfUkFESVVTX05FQVIpO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRmFyID0gTWF0aC5tYXgoMywgQUNUSVZFX1JBRElVU19GQVIgLSBlbnZDYWNoZS5wcm9wRGVuc2l0eSAqIDAuMik7XG5cbiAgICAgIGNvbnN0IGN4ID0gdG9DaHVuayhwb3MueCk7XG4gICAgICBjb25zdCBjeiA9IHRvQ2h1bmsocG9zLnopO1xuXG4gICAgICAvLyBFbnN1cmUgbmVhciBjaHVua3MgKGhpZ2ggZGV0YWlsKVxuICAgICAgZm9yIChsZXQgZHogPSAtZWZmZWN0aXZlTmVhcjsgZHogPD0gZWZmZWN0aXZlTmVhcjsgZHorKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC1lZmZlY3RpdmVOZWFyOyBkeCA8PSBlZmZlY3RpdmVOZWFyOyBkeCsrKSB7XG4gICAgICAgICAgZW5zdXJlKGN4ICsgZHgsIGN6ICsgZHosICduZWFyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGZhciBjaHVua3MgKGxvdyBkZXRhaWwpXG4gICAgICBmb3IgKGxldCBkeiA9IC1lZmZlY3RpdmVGYXI7IGR6IDw9IGVmZmVjdGl2ZUZhcjsgZHorKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC1lZmZlY3RpdmVGYXI7IGR4IDw9IGVmZmVjdGl2ZUZhcjsgZHgrKykge1xuICAgICAgICAgIGlmIChNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR6KSkgPiBlZmZlY3RpdmVOZWFyKSB7XG4gICAgICAgICAgICBlbnN1cmUoY3ggKyBkeCwgY3ogKyBkeiwgJ2ZhcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcnVuZShwb3MueCwgcG9zLnopO1xuXG4gICAgICBpZiAoZW52aXJvbm1lbnREaXJ0eSkge1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgICAgZGVjb3JhdGVDaHVuayhtKTtcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGUgd2luZCBjb2x1bW5zIC0gUmVtb3ZlZFxuICAgIH0sXG5cbiAgICBxdWVyeUhlaWdodCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgcmV0dXJuIGhlaWdodEF0KHgsIHopO1xuICAgIH0sXG5cbiAgICBxdWVyeU5vcm1hbCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgY29uc3QgbiA9IG5vcm1hbEF0KHgsIHopO1xuICAgICAgcmV0dXJuIHRtcC5zZXQobi54LCBuLnksIG4ueik7XG4gICAgfSxcblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAvLyAxLiBDbGVhbnVwOiBVbnN1YiwgcHJ1bmUgYWxsLCBkaXNwb3NlIHNoYXJlZCBtYXRzLlxuICAgICAgdW5zdWJzY3JpYmU/LigpO1xuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICB9XG4gICAgICBjaHVua3MuY2xlYXIoKTtcblxuICAgICAgLy8gRGlzcG9zZSBzaGFyZWQgbWF0ZXJpYWxzXG4gICAgICBPYmplY3QudmFsdWVzKHNoYXJlZE1hdGVyaWFscykuZm9yRWFjaChtYXQgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXQpKSB7XG4gICAgICAgICAgbWF0LmZvckVhY2gobSA9PiBtLmRpc3Bvc2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0iXSwibmFtZXMiOlsiVEhSRUUiLCJoZWlnaHRBdCIsIm5vcm1hbEF0IiwiZ2V0RGlmZmljdWx0eVN0YXRlIiwib25EaWZmaWN1bHR5Q2hhbmdlIiwiQ0hVTktfU0laRSIsIlZFUlRTX05FQVIiLCJWRVJUU19GQVIiLCJIQUxGIiwiQUNUSVZFX1JBRElVU19ORUFSIiwiQUNUSVZFX1JBRElVU19GQVIiLCJrZXkiLCJpeCIsIml6IiwidG9DaHVuayIsIngiLCJNYXRoIiwiZmxvb3IiLCJlbnZDYWNoZSIsImVudmlyb25tZW50Iiwic2hhcmVkTWF0ZXJpYWxzIiwidGVycmFpbiIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiY29sb3IiLCJyb3VnaG5lc3MiLCJtZXRhbG5lc3MiLCJyb2NrIiwiYnVpbGRDaHVuayIsImRldGFpbExldmVsIiwidmVydHMiLCJnIiwiUGxhbmVHZW9tZXRyeSIsInJvdGF0ZVgiLCJQSSIsInBvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImkiLCJjb3VudCIsInZ4IiwiZ2V0WCIsInZ6IiwiZ2V0WiIsImgiLCJzZXRZIiwibmVlZHNVcGRhdGUiLCJjb21wdXRlVmVydGV4Tm9ybWFscyIsInV2Iiwic2V0WFkiLCJnZXRZIiwibWVzaCIsIk1lc2giLCJzZXQiLCJyZWNlaXZlU2hhZG93IiwiY2FzdFNoYWRvdyIsInVzZXJEYXRhIiwiZGVjb3JhdGlvbnMiLCJpbnN0YW5jZUNvdW50cyIsInJvY2tzIiwid2luZHMiLCJkZWNvcmF0ZUNodW5rIiwicHJldmlvdXMiLCJvYmoiLCJyZW1vdmUiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibWF0ZXJpYWwiLCJBcnJheSIsImlzQXJyYXkiLCJtYXQiLCJwcm9wRGVuc2l0eSIsInByb3BDb3VudCIsIm1heCIsInJvdW5kIiwid2luZENvdW50Iiwicm9ja0dlbyIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJyYW5kb20iLCJyb2NrSW5zdGFuY2VzIiwiSW5zdGFuY2VkTWVzaCIsInJvY2tNYXRyaXgiLCJNYXRyaXg0IiwidG1wUG9zIiwiVmVjdG9yMyIsInRtcFF1YXQiLCJRdWF0ZXJuaW9uIiwidG1wU2NhbGUiLCJsb2NhbFgiLCJsb2NhbFoiLCJ3b3JsZFgiLCJ3b3JsZFoiLCJiYXNlSGVpZ2h0IiwieSIsIm5vcm0iLCJ1cCIsIm5vcm1hbFZlYyIsInoiLCJub3JtYWxpemUiLCJhbGlnbm1lbnRRdWF0Iiwic2V0RnJvbVVuaXRWZWN0b3JzIiwicmFuZG9tRXVsZXIiLCJFdWxlciIsInJhbmRvbVF1YXQiLCJzZXRGcm9tRXVsZXIiLCJjb3B5IiwibXVsdGlwbHkiLCJzY2FsZSIsImNvbXBvc2UiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4IiwiYWRkIiwicHVzaCIsImZvZ0dlbyIsImZvZ01hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5Iiwic2lkZSIsIkRvdWJsZVNpZGUiLCJmb2ciLCJyb3RhdGlvbiIsImNyZWF0ZVN0cmVhbWVyIiwic2NlbmUiLCJjaHVua3MiLCJNYXAiLCJ0bXAiLCJlbnZpcm9ubWVudERpcnR5IiwiYW5pbWF0aW9uVGltZSIsInVuc3Vic2NyaWJlIiwic3RhdGUiLCJlbnN1cmUiLCJrIiwiaGFzIiwiZXhpc3RpbmciLCJnZXQiLCJkaXNwb3NlQ2h1bmsiLCJkZWxldGUiLCJwcnVuZSIsImNlbnRlclgiLCJjZW50ZXJaIiwibSIsImR4IiwiZHoiLCJkaXN0IiwiYWJzIiwiZGVjbyIsInVwZGF0ZSIsImR0IiwiZWZmZWN0aXZlTmVhciIsImVmZmVjdGl2ZUZhciIsImN4IiwiY3oiLCJ2YWx1ZXMiLCJxdWVyeUhlaWdodCIsInF1ZXJ5Tm9ybWFsIiwibiIsImNsZWFyIiwiT2JqZWN0IiwiZm9yRWFjaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});