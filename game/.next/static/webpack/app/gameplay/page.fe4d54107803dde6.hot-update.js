"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 512;\nconst VERTS = 100; // Fixed medium detail - DISABLE LOD to eliminate switches/flashing\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS = 5; // Increased for more overlap, less boundary issues\nconst FADE_DURATION = 1.0; // Longer fade for smoother transitions\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0,\n        // Texture added: Load a grass/terrain texture for detail\n        map: null,\n        transparent: true,\n        opacity: 1.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    })\n};\nfunction buildChunk(ix, iz) {\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, VERTS, VERTS);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // UV scaling for texture tiling - Increased tiling for seamless repeat\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 8, uv.getY(i) * 8); // Tile 8x for finer detail/variety\n    }\n    uv.needsUpdate = true;\n    // Recompute normals after UV to ensure lighting consistency\n    g.computeVertexNormals();\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(g, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false; // Terrain doesn't cast\n    mesh.frustumCulled = false; // Prevent culling artifacts at edges\n    mesh.userData = {\n        ix,\n        iz,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        },\n        fadeStart: 0,\n        targetOpacity: 0\n    };\n    mesh.material.opacity = 0.0; // Start faded for smooth entry\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations idempotently with proper disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        obj.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                child.geometry.dispose();\n                const material = child.material;\n                if (Array.isArray(material)) {\n                    var _mat_dispose;\n                    for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                } else {\n                    var _material_dispose;\n                    (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                }\n            }\n        });\n    }\n    mesh.userData.decorations = [];\n    const { propDensity } = envCache; // windStrength no longer used\n    const propCount = Math.max(0, Math.round(propDensity * 16)); // Increased density for richness\n    const windCount = 0; // Always 0 - wind removed\n    // Rocks: Use InstancedMesh for batching (perf win for many props)\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1); // Slight detail\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5; // Slight elevation var\n            tmpPos.set(localX, y, localZ);\n            // Alignment quaternion (up vector to normal)\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, normalVec);\n            // Random rotation quaternion (on top of alignment)\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            // Compose matrix\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        rockInstances.frustumCulled = false; // Prevent rock culling issues\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Removed entirely\n    // Add subtle fog plane for atmospheric depth (per chunk, low poly) - Adjusted opacity without wind\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0; // No longer used for wind\n    const clock = new three__WEBPACK_IMPORTED_MODULE_2__.Clock(); // For fade timing\n    // Load texture asynchronously - Specific path for your PNG\n    const loader = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader();\n    loader.load('/textures/32d4a6ff-3da1-4c7c-a742-1d1fa759e394.png', (texture)=>{\n        // Set wrap modes for seamless tiling\n        texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.anisotropy = 16; // Sharper mipmaps under grazing angles\n        texture.encoding = three__WEBPACK_IMPORTED_MODULE_2__.sRGBEncoding; // For color accuracy\n        // Apply to shared material\n        sharedMaterials.terrain.map = texture;\n        sharedMaterials.terrain.needsUpdate = true;\n        // Rebuild all existing chunks on load to apply texture\n        if (chunks.size > 0) {\n            for (const m of chunks.values()){\n                decorateChunk(m); // Triggers material update\n            }\n        }\n        console.log('Terrain texture loaded and applied');\n    }, (progress)=>{\n        console.log(\"Loading texture: \".concat(progress.loaded / progress.total * 100 | 0, \"%\"));\n    }, (error)=>{\n        console.error('Error loading terrain texture:', error);\n    // Fallback: Keep solid color\n    });\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        // 1. Mark dirty on env change; rebuild decorations next update.\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    function ensure(ix, iz) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) return;\n        // New chunk: Create and fade in\n        const mesh = buildChunk(ix, iz);\n        mesh.userData.fadeStart = clock.getElapsedTime();\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > ACTIVE_RADIUS) {\n                // Fade out before prune\n                m.userData.targetOpacity = 0.0;\n                setTimeout(()=>{\n                    if (chunks.has(k)) {\n                        scene.remove(m);\n                        disposeChunk(m);\n                        chunks.delete(k);\n                    }\n                }, FADE_DURATION * 1000);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        // Comprehensive disposal: Geoms, mats (skip shared), instances\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            mesh.remove(deco);\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose(); // Releases instance buffer\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    // Don't dispose shared materials here\n    }\n    // Update fades\n    function updateFades(dt) {\n        const now = clock.getElapsedTime();\n        // Fade in new/existing chunks\n        for (const m of chunks.values()){\n            if (m.userData.fadeStart > 0) {\n                const elapsed = now - m.userData.fadeStart;\n                if (elapsed < FADE_DURATION) {\n                    const progress = elapsed / FADE_DURATION;\n                    m.material.opacity = progress;\n                } else {\n                    m.material.opacity = m.userData.targetOpacity || 1.0;\n                    m.userData.fadeStart = 0; // Done\n                }\n            }\n        }\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            // Dynamic radius based on envCache - propDensity only now\n            const effectiveRadius = Math.max(4, ACTIVE_RADIUS - envCache.propDensity * 0.2);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // Ensure chunks\n            for(let dz = -effectiveRadius; dz <= effectiveRadius; dz++){\n                for(let dx = -effectiveRadius; dx <= effectiveRadius; dx++){\n                    ensure(cx + dx, cz + dz);\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                }\n                environmentDirty = false;\n            }\n            // Animate wind columns - Removed\n            updateFades(dt); // Handle fades\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            // 1. Cleanup: Unsub, prune all, dispose shared mats.\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            // Dispose shared materials (incl. texture if loaded)\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                    if (mat.map) mat.map.dispose(); // Explicitly dispose texture\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLFFBQVEsS0FBSyxtRUFBbUU7QUFDdEYsTUFBTUMsT0FBT0YsYUFBYTtBQUMxQixNQUFNRyxnQkFBZ0IsR0FBRyxtREFBbUQ7QUFDNUUsTUFBTUMsZ0JBQWdCLEtBQUssdUNBQXVDO0FBRWxFLFNBQVNDLElBQUlDLEVBQVUsRUFBRUMsRUFBVTtJQUFJLE9BQU8sR0FBU0EsT0FBTkQsSUFBRyxLQUFNLE9BQUhDO0FBQU07QUFDN0QsU0FBU0MsUUFBUUMsQ0FBUztJQUFJLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0YsSUFBSVQ7QUFBYTtBQUVqRSxJQUFJWSxXQUFXZCxzRUFBa0JBLEdBQUdlLFdBQVc7QUFFL0MsaUVBQWlFO0FBQ2pFLE1BQU1DLGtCQUFrQjtJQUN0QkMsU0FBUyxJQUFJcEIsdURBQTBCLENBQUM7UUFDdENzQixPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsV0FBVztRQUNYLHlEQUF5RDtRQUN6REMsS0FBSztRQUNMQyxhQUFhO1FBQ2JDLFNBQVM7SUFDWDtJQUNBQyxNQUFNLElBQUk1Qix1REFBMEIsQ0FBQztRQUNuQ3NCLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO0lBQ2I7QUFFRjtBQUVBLFNBQVNLLFdBQVdsQixFQUFVLEVBQUVDLEVBQVU7SUFDeEMsTUFBTWtCLElBQUksSUFBSTlCLGdEQUFtQixDQUFDSyxZQUFZQSxZQUFZQyxPQUFPQTtJQUNqRXdCLEVBQUVFLE9BQU8sQ0FBQyxDQUFDakIsS0FBS2tCLEVBQUUsR0FBRztJQUVyQixNQUFNQyxNQUFNSixFQUFFSyxVQUFVLENBQUNDLFFBQVE7SUFDakMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLEtBQUssRUFBRUQsSUFBSztRQUNsQyxNQUFNRSxLQUFLTCxJQUFJTSxJ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SCxFQUFFckssQ0FBQyxFQUFFcUssRUFBRWxGLENBQUMsRUFBRWtGLEVBQUU5RSxDQUFDO1FBQzlCO1FBRUE5QjtZQUNFLHFEQUFxRDtZQUNyRGlGLHdCQUFBQSxrQ0FBQUE7WUFDQSxLQUFLLE1BQU1SLEtBQUtsQixPQUFPbUIsTUFBTSxHQUFJO2dCQUMvQnFCLGFBQWF0QjtZQUNmO1lBQ0FsQixPQUFPc0QsS0FBSztZQUVaLHFEQUFxRDtZQUNyREMsT0FBT3BDLE1BQU0sQ0FBQzlILGlCQUFpQm1LLE9BQU8sQ0FBQzVHLENBQUFBO2dCQUNyQyxJQUFJRixNQUFNQyxPQUFPLENBQUNDLE1BQU07b0JBQ3RCQSxJQUFJNEcsT0FBTyxDQUFDdEMsQ0FBQUEsSUFBS0EsRUFBRXpFLE9BQU87Z0JBQzVCLE9BQU87b0JBQ0xHLElBQUlILE9BQU87b0JBQ1gsSUFBSUcsSUFBSWpELEdBQUcsRUFBRWlELElBQUlqRCxHQUFHLENBQUM4QyxPQUFPLElBQUksNkJBQTZCO2dCQUMvRDtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvYXBwL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgaGVpZ2h0QXQsIG5vcm1hbEF0IH0gZnJvbSAnLi9nZW5lcmF0ZUhlaWdodCc7XG5pbXBvcnQgeyBnZXREaWZmaWN1bHR5U3RhdGUsIG9uRGlmZmljdWx0eUNoYW5nZSB9IGZyb20gJ0AvZW5naW5lL2RpZmZpY3VsdHknO1xuXG5jb25zdCBDSFVOS19TSVpFID0gNTEyO1xuY29uc3QgVkVSVFMgPSAxMDA7IC8vIEZpeGVkIG1lZGl1bSBkZXRhaWwgLSBESVNBQkxFIExPRCB0byBlbGltaW5hdGUgc3dpdGNoZXMvZmxhc2hpbmdcbmNvbnN0IEhBTEYgPSBDSFVOS19TSVpFIC8gMjtcbmNvbnN0IEFDVElWRV9SQURJVVMgPSA1OyAvLyBJbmNyZWFzZWQgZm9yIG1vcmUgb3ZlcmxhcCwgbGVzcyBib3VuZGFyeSBpc3N1ZXNcbmNvbnN0IEZBREVfRFVSQVRJT04gPSAxLjA7IC8vIExvbmdlciBmYWRlIGZvciBzbW9vdGhlciB0cmFuc2l0aW9uc1xuXG5mdW5jdGlvbiBrZXkoaXg6IG51bWJlciwgaXo6IG51bWJlcikgeyByZXR1cm4gYCR7aXh9LCR7aXp9YDsgfVxuZnVuY3Rpb24gdG9DaHVuayh4OiBudW1iZXIpIHsgcmV0dXJuIE1hdGguZmxvb3IoeCAvIENIVU5LX1NJWkUpOyB9XG5cbmxldCBlbnZDYWNoZSA9IGdldERpZmZpY3VsdHlTdGF0ZSgpLmVudmlyb25tZW50O1xuXG4vLyBTaGFyZWQgbWF0ZXJpYWxzIGZvciBlZmZpY2llbmN5IChkaXNwb3NlIG9uIHN0cmVhbWVyIHRlYXJkb3duKVxuY29uc3Qgc2hhcmVkTWF0ZXJpYWxzID0ge1xuICB0ZXJyYWluOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDUwNmE1MixcbiAgICByb3VnaG5lc3M6IDAuOTUsXG4gICAgbWV0YWxuZXNzOiAwLjAsXG4gICAgLy8gVGV4dHVyZSBhZGRlZDogTG9hZCBhIGdyYXNzL3RlcnJhaW4gdGV4dHVyZSBmb3IgZGV0YWlsXG4gICAgbWFwOiBudWxsLCAvLyBXaWxsIGJlIHNldCBhZnRlciBsb2FkaW5nXG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsIC8vIEVuYWJsZSBmb3IgZmFkZVxuICAgIG9wYWNpdHk6IDEuMCxcbiAgfSksXG4gIHJvY2s6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4NGE0ZjQ0LFxuICAgIHJvdWdobmVzczogMC44LFxuICAgIG1ldGFsbmVzczogMC4xLFxuICB9KSxcbiAgLy8gd2luZDogUmVtb3ZlZCAtIG5vIGxvbmdlciBuZWVkZWRcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkQ2h1bmsoaXg6IG51bWJlciwgaXo6IG51bWJlcikge1xuICBjb25zdCBnID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSwgQ0hVTktfU0laRSwgVkVSVFMsIFZFUlRTKTtcbiAgZy5yb3RhdGVYKC1NYXRoLlBJIC8gMik7XG5cbiAgY29uc3QgcG9zID0gZy5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHZ4ID0gcG9zLmdldFgoaSkgKyBpeCAqIENIVU5LX1NJWkU7XG4gICAgY29uc3QgdnogPSBwb3MuZ2V0WihpKSArIGl6ICogQ0hVTktfU0laRTtcbiAgICBjb25zdCBoID0gaGVpZ2h0QXQodngsIHZ6KTtcbiAgICBwb3Muc2V0WShpLCBoKTtcbiAgfVxuICBwb3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gVVYgc2NhbGluZyBmb3IgdGV4dHVyZSB0aWxpbmcgLSBJbmNyZWFzZWQgdGlsaW5nIGZvciBzZWFtbGVzcyByZXBlYXRcbiAgY29uc3QgdXYgPSBnLmF0dHJpYnV0ZXMudXYgYXMgVEhSRUUuQnVmZmVyQXR0cmlidXRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICB1di5zZXRYWShpLCB1di5nZXRYKGkpICogOCwgdXYuZ2V0WShpKSAqIDgpOyAvLyBUaWxlIDh4IGZvciBmaW5lciBkZXRhaWwvdmFyaWV0eVxuICB9XG4gIHV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBSZWNvbXB1dGUgbm9ybWFscyBhZnRlciBVViB0byBlbnN1cmUgbGlnaHRpbmcgY29uc2lzdGVuY3lcbiAgZy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnLCBzaGFyZWRNYXRlcmlhbHMudGVycmFpbik7XG4gIG1lc2gucG9zaXRpb24uc2V0KGl4ICogQ0hVTktfU0laRSwgMCwgaXogKiBDSFVOS19TSVpFKTtcbiAgbWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgbWVzaC5jYXN0U2hhZG93ID0gZmFsc2U7IC8vIFRlcnJhaW4gZG9lc24ndCBjYXN0XG4gIG1lc2guZnJ1c3R1bUN1bGxlZCA9IGZhbHNlOyAvLyBQcmV2ZW50IGN1bGxpbmcgYXJ0aWZhY3RzIGF0IGVkZ2VzXG4gIG1lc2gudXNlckRhdGEgPSB7XG4gICAgaXgsXG4gICAgaXosXG4gICAgZGVjb3JhdGlvbnM6IFtdIGFzIFRIUkVFLk9iamVjdDNEW10sXG4gICAgaW5zdGFuY2VDb3VudHM6IHsgcm9ja3M6IDAsIHdpbmRzOiAwIH0sIC8vIEZvciBpbnN0YW5jZWQgY2xlYW51cFxuICAgIGZhZGVTdGFydDogMCwgLy8gVGltZXN0YW1wIGZvciBmYWRlLWluXG4gICAgdGFyZ2V0T3BhY2l0eTogMCxcbiAgfTtcbiAgbWVzaC5tYXRlcmlhbC5vcGFjaXR5ID0gMC4wOyAvLyBTdGFydCBmYWRlZCBmb3Igc21vb3RoIGVudHJ5XG5cbiAgZGVjb3JhdGVDaHVuayhtZXNoKTtcbiAgcmV0dXJuIG1lc2g7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlQ2h1bmsobWVzaDogVEhSRUUuTWVzaCkge1xuICAvLyAxLiBDbGVhciBleGlzdGluZyBkZWNvcmF0aW9ucyBpZGVtcG90ZW50bHkgd2l0aCBwcm9wZXIgZGlzcG9zYWwuXG4gIGNvbnN0IHByZXZpb3VzID0gbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucyA/PyBbXTtcbiAgZm9yIChjb25zdCBvYmogb2YgcHJldmlvdXMpIHtcbiAgICBtZXNoLnJlbW92ZShvYmopO1xuICAgIG9iai50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgY2hpbGQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1hdCBvZiBtYXRlcmlhbCkgbWF0LmRpc3Bvc2U/LigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGVyaWFsLmRpc3Bvc2U/LigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucyA9IFtdO1xuXG4gIGNvbnN0IHsgcHJvcERlbnNpdHkgfSA9IGVudkNhY2hlOyAvLyB3aW5kU3RyZW5ndGggbm8gbG9uZ2VyIHVzZWRcbiAgY29uc3QgcHJvcENvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChwcm9wRGVuc2l0eSAqIDE2KSk7IC8vIEluY3JlYXNlZCBkZW5zaXR5IGZvciByaWNobmVzc1xuICBjb25zdCB3aW5kQ291bnQgPSAwOyAvLyBBbHdheXMgMCAtIHdpbmQgcmVtb3ZlZFxuXG4gIC8vIFJvY2tzOiBVc2UgSW5zdGFuY2VkTWVzaCBmb3IgYmF0Y2hpbmcgKHBlcmYgd2luIGZvciBtYW55IHByb3BzKVxuICBpZiAocHJvcENvdW50ID4gMCkge1xuICAgIGNvbnN0IHJvY2tHZW8gPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSgxLjUgKyBNYXRoLnJhbmRvbSgpICogMi41LCAxKTsgLy8gU2xpZ2h0IGRldGFpbFxuICAgIGNvbnN0IHJvY2tJbnN0YW5jZXMgPSBuZXcgVEhSRUUuSW5zdGFuY2VkTWVzaChyb2NrR2VvLCBzaGFyZWRNYXRlcmlhbHMucm9jaywgcHJvcENvdW50KTtcbiAgICBjb25zdCByb2NrTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBjb25zdCB0bXBQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHRtcFF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIGNvbnN0IHRtcFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGxvY2FsWCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIENIVU5LX1NJWkU7XG4gICAgICBjb25zdCBsb2NhbFogPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBDSFVOS19TSVpFO1xuICAgICAgY29uc3Qgd29ybGRYID0gbWVzaC51c2VyRGF0YS5peCAqIENIVU5LX1NJWkUgKyBsb2NhbFg7XG4gICAgICBjb25zdCB3b3JsZFogPSBtZXNoLnVzZXJEYXRhLml6ICogQ0hVTktfU0laRSArIGxvY2FsWjtcbiAgICAgIGNvbnN0IGJhc2VIZWlnaHQgPSBoZWlnaHRBdCh3b3JsZFgsIHdvcmxkWik7XG4gICAgICBjb25zdCB5ID0gYmFzZUhlaWdodCAtIG1lc2gucG9zaXRpb24ueSArIDEgKyBNYXRoLnJhbmRvbSgpICogMC41OyAvLyBTbGlnaHQgZWxldmF0aW9uIHZhclxuICAgICAgdG1wUG9zLnNldChsb2NhbFgsIHksIGxvY2FsWik7XG5cbiAgICAgIC8vIEFsaWdubWVudCBxdWF0ZXJuaW9uICh1cCB2ZWN0b3IgdG8gbm9ybWFsKVxuICAgICAgY29uc3Qgbm9ybSA9IG5vcm1hbEF0KHdvcmxkWCwgd29ybGRaKTtcbiAgICAgIGNvbnN0IHVwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICBjb25zdCBub3JtYWxWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMyhub3JtLngsIG5vcm0ueSwgbm9ybS56KS5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudFF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyh1cCwgbm9ybWFsVmVjKTtcblxuICAgICAgLy8gUmFuZG9tIHJvdGF0aW9uIHF1YXRlcm5pb24gKG9uIHRvcCBvZiBhbGlnbm1lbnQpXG4gICAgICBjb25zdCByYW5kb21FdWxlciA9IG5ldyBUSFJFRS5FdWxlcihcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgJ1hZWidcbiAgICAgICk7XG4gICAgICBjb25zdCByYW5kb21RdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIocmFuZG9tRXVsZXIpO1xuICAgICAgdG1wUXVhdC5jb3B5KGFsaWdubWVudFF1YXQpLm11bHRpcGx5KHJhbmRvbVF1YXQpO1xuXG4gICAgICAvLyBTY2FsZVxuICAgICAgY29uc3Qgc2NhbGUgPSAwLjggKyBNYXRoLnJhbmRvbSgpICogMC40O1xuICAgICAgdG1wU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpO1xuXG4gICAgICAvLyBDb21wb3NlIG1hdHJpeFxuICAgICAgcm9ja01hdHJpeC5jb21wb3NlKHRtcFBvcywgdG1wUXVhdCwgdG1wU2NhbGUpO1xuICAgICAgcm9ja0luc3RhbmNlcy5zZXRNYXRyaXhBdChpLCByb2NrTWF0cml4KTtcbiAgICB9XG4gICAgcm9ja0luc3RhbmNlcy5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcm9ja0luc3RhbmNlcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICByb2NrSW5zdGFuY2VzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcbiAgICByb2NrSW5zdGFuY2VzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTsgLy8gUHJldmVudCByb2NrIGN1bGxpbmcgaXNzdWVzXG4gICAgbWVzaC5hZGQocm9ja0luc3RhbmNlcyk7XG4gICAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucy5wdXNoKHJvY2tJbnN0YW5jZXMpO1xuICAgIG1lc2gudXNlckRhdGEuaW5zdGFuY2VDb3VudHMucm9ja3MgPSBwcm9wQ291bnQ7XG4gIH1cblxuICAvLyBXaW5kIGNvbHVtbnM6IFJlbW92ZWQgZW50aXJlbHlcblxuICAvLyBBZGQgc3VidGxlIGZvZyBwbGFuZSBmb3IgYXRtb3NwaGVyaWMgZGVwdGggKHBlciBjaHVuaywgbG93IHBvbHkpIC0gQWRqdXN0ZWQgb3BhY2l0eSB3aXRob3V0IHdpbmRcbiAgY29uc3QgZm9nR2VvID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSAqIDEuMiwgQ0hVTktfU0laRSAqIDEuMiwgMSwgMSk7XG4gIGNvbnN0IGZvZ01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4ODhjY2ZmLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIG9wYWNpdHk6IDAuMDUsIC8vIEZpeGVkIGxvdyB2YWx1ZSwgbm8gd2luZCB0aWUtaW5cbiAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICB9KTtcbiAgY29uc3QgZm9nID0gbmV3IFRIUkVFLk1lc2goZm9nR2VvLCBmb2dNYXQpO1xuICBmb2cucG9zaXRpb24uc2V0KDAsIDIwLCAwKTtcbiAgZm9nLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gIG1lc2guYWRkKGZvZyk7XG4gIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMucHVzaChmb2cpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtZXIoc2NlbmU6IFRIUkVFLlNjZW5lKSB7XG4gIGNvbnN0IGNodW5rcyA9IG5ldyBNYXA8c3RyaW5nLCBUSFJFRS5NZXNoPigpO1xuICBjb25zdCB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBsZXQgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlO1xuICBsZXQgYW5pbWF0aW9uVGltZSA9IDA7IC8vIE5vIGxvbmdlciB1c2VkIGZvciB3aW5kXG4gIGNvbnN0IGNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7IC8vIEZvciBmYWRlIHRpbWluZ1xuXG4gIC8vIExvYWQgdGV4dHVyZSBhc3luY2hyb25vdXNseSAtIFNwZWNpZmljIHBhdGggZm9yIHlvdXIgUE5HXG4gIGNvbnN0IGxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG4gIGxvYWRlci5sb2FkKFxuICAgICcvdGV4dHVyZXMvMzJkNGE2ZmYtM2RhMS00YzdjLWE3NDItMWQxZmE3NTllMzk0LnBuZycsIC8vIFB1YmxpYyBwYXRoIChmcm9tIC9wdWJsaWMvdGV4dHVyZXMvKVxuICAgICh0ZXh0dXJlKSA9PiB7XG4gICAgICAvLyBTZXQgd3JhcCBtb2RlcyBmb3Igc2VhbWxlc3MgdGlsaW5nXG4gICAgICB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSAxNjsgLy8gU2hhcnBlciBtaXBtYXBzIHVuZGVyIGdyYXppbmcgYW5nbGVzXG4gICAgICB0ZXh0dXJlLmVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nOyAvLyBGb3IgY29sb3IgYWNjdXJhY3lcblxuICAgICAgLy8gQXBwbHkgdG8gc2hhcmVkIG1hdGVyaWFsXG4gICAgICBzaGFyZWRNYXRlcmlhbHMudGVycmFpbi5tYXAgPSB0ZXh0dXJlO1xuICAgICAgc2hhcmVkTWF0ZXJpYWxzLnRlcnJhaW4ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAvLyBSZWJ1aWxkIGFsbCBleGlzdGluZyBjaHVua3Mgb24gbG9hZCB0byBhcHBseSB0ZXh0dXJlXG4gICAgICBpZiAoY2h1bmtzLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgICAgICBkZWNvcmF0ZUNodW5rKG0pOyAvLyBUcmlnZ2VycyBtYXRlcmlhbCB1cGRhdGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1RlcnJhaW4gdGV4dHVyZSBsb2FkZWQgYW5kIGFwcGxpZWQnKTtcbiAgICB9LFxuICAgIChwcm9ncmVzcykgPT4ge1xuICAgICAgY29uc29sZS5sb2coYExvYWRpbmcgdGV4dHVyZTogJHsocHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwgKiAxMDAgfCAwKX0lYCk7XG4gICAgfSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdGVycmFpbiB0ZXh0dXJlOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrOiBLZWVwIHNvbGlkIGNvbG9yXG4gICAgfVxuICApO1xuXG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gb25EaWZmaWN1bHR5Q2hhbmdlKChzdGF0ZSkgPT4ge1xuICAgIC8vIDEuIE1hcmsgZGlydHkgb24gZW52IGNoYW5nZTsgcmVidWlsZCBkZWNvcmF0aW9ucyBuZXh0IHVwZGF0ZS5cbiAgICBlbnZDYWNoZSA9IHN0YXRlLmVudmlyb25tZW50O1xuICAgIGVudmlyb25tZW50RGlydHkgPSB0cnVlO1xuICB9KTtcblxuICBmdW5jdGlvbiBlbnN1cmUoaXg6IG51bWJlciwgaXo6IG51bWJlcikge1xuICAgIGNvbnN0IGsgPSBrZXkoaXgsIGl6KTtcbiAgICBpZiAoY2h1bmtzLmhhcyhrKSkgcmV0dXJuO1xuXG4gICAgLy8gTmV3IGNodW5rOiBDcmVhdGUgYW5kIGZhZGUgaW5cbiAgICBjb25zdCBtZXNoID0gYnVpbGRDaHVuayhpeCwgaXopO1xuICAgIG1lc2gudXNlckRhdGEuZmFkZVN0YXJ0ID0gY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICBjaHVua3Muc2V0KGssIG1lc2gpO1xuICAgIHNjZW5lLmFkZChtZXNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lKGNlbnRlclg6IG51bWJlciwgY2VudGVyWjogbnVtYmVyKSB7XG4gICAgZm9yIChjb25zdCBbaywgbV0gb2YgY2h1bmtzKSB7XG4gICAgICBjb25zdCBkeCA9IHRvQ2h1bmsoY2VudGVyWCkgLSBtLnVzZXJEYXRhLml4O1xuICAgICAgY29uc3QgZHogPSB0b0NodW5rKGNlbnRlclopIC0gbS51c2VyRGF0YS5pejtcbiAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR6KSk7XG4gICAgICBpZiAoZGlzdCA+IEFDVElWRV9SQURJVVMpIHtcbiAgICAgICAgLy8gRmFkZSBvdXQgYmVmb3JlIHBydW5lXG4gICAgICAgIG0udXNlckRhdGEudGFyZ2V0T3BhY2l0eSA9IDAuMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNodW5rcy5oYXMoaykpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShtKTtcbiAgICAgICAgICAgIGRpc3Bvc2VDaHVuayhtKTtcbiAgICAgICAgICAgIGNodW5rcy5kZWxldGUoayk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBGQURFX0RVUkFUSU9OICogMTAwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcG9zZUNodW5rKG1lc2g6IFRIUkVFLk1lc2gpIHtcbiAgICAvLyBDb21wcmVoZW5zaXZlIGRpc3Bvc2FsOiBHZW9tcywgbWF0cyAoc2tpcCBzaGFyZWQpLCBpbnN0YW5jZXNcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBjb25zdCBkZWNvcmF0aW9ucyA9IG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPz8gW107XG4gICAgZm9yIChjb25zdCBkZWNvIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICBtZXNoLnJlbW92ZShkZWNvKTtcbiAgICAgIGlmIChkZWNvIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkTWVzaCkge1xuICAgICAgICBkZWNvLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgZGVjby5kaXNwb3NlKCk7IC8vIFJlbGVhc2VzIGluc3RhbmNlIGJ1ZmZlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjby50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEb24ndCBkaXNwb3NlIHNoYXJlZCBtYXRlcmlhbHMgaGVyZVxuICB9XG5cbiAgLy8gVXBkYXRlIGZhZGVzXG4gIGZ1bmN0aW9uIHVwZGF0ZUZhZGVzKGR0OiBudW1iZXIpIHtcbiAgICBjb25zdCBub3cgPSBjbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuXG4gICAgLy8gRmFkZSBpbiBuZXcvZXhpc3RpbmcgY2h1bmtzXG4gICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG0udXNlckRhdGEuZmFkZVN0YXJ0ID4gMCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gbS51c2VyRGF0YS5mYWRlU3RhcnQ7XG4gICAgICAgIGlmIChlbGFwc2VkIDwgRkFERV9EVVJBVElPTikge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gZWxhcHNlZCAvIEZBREVfRFVSQVRJT047XG4gICAgICAgICAgbS5tYXRlcmlhbC5vcGFjaXR5ID0gcHJvZ3Jlc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbS5tYXRlcmlhbC5vcGFjaXR5ID0gbS51c2VyRGF0YS50YXJnZXRPcGFjaXR5IHx8IDEuMDtcbiAgICAgICAgICBtLnVzZXJEYXRhLmZhZGVTdGFydCA9IDA7IC8vIERvbmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlKHBvczogVEhSRUUuVmVjdG9yMywgZHQ6IG51bWJlcikge1xuICAgICAgYW5pbWF0aW9uVGltZSArPSBkdDtcblxuICAgICAgLy8gRHluYW1pYyByYWRpdXMgYmFzZWQgb24gZW52Q2FjaGUgLSBwcm9wRGVuc2l0eSBvbmx5IG5vd1xuICAgICAgY29uc3QgZWZmZWN0aXZlUmFkaXVzID0gTWF0aC5tYXgoNCwgQUNUSVZFX1JBRElVUyAtIGVudkNhY2hlLnByb3BEZW5zaXR5ICogMC4yKTtcblxuICAgICAgY29uc3QgY3ggPSB0b0NodW5rKHBvcy54KTtcbiAgICAgIGNvbnN0IGN6ID0gdG9DaHVuayhwb3Mueik7XG5cbiAgICAgIC8vIEVuc3VyZSBjaHVua3NcbiAgICAgIGZvciAobGV0IGR6ID0gLWVmZmVjdGl2ZVJhZGl1czsgZHogPD0gZWZmZWN0aXZlUmFkaXVzOyBkeisrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLWVmZmVjdGl2ZVJhZGl1czsgZHggPD0gZWZmZWN0aXZlUmFkaXVzOyBkeCsrKSB7XG4gICAgICAgICAgZW5zdXJlKGN4ICsgZHgsIGN6ICsgZHopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBydW5lKHBvcy54LCBwb3Mueik7XG5cbiAgICAgIGlmIChlbnZpcm9ubWVudERpcnR5KSB7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgICAgICBkZWNvcmF0ZUNodW5rKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50RGlydHkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQW5pbWF0ZSB3aW5kIGNvbHVtbnMgLSBSZW1vdmVkXG4gICAgICB1cGRhdGVGYWRlcyhkdCk7IC8vIEhhbmRsZSBmYWRlc1xuICAgIH0sXG5cbiAgICBxdWVyeUhlaWdodCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgcmV0dXJuIGhlaWdodEF0KHgsIHopO1xuICAgIH0sXG5cbiAgICBxdWVyeU5vcm1hbCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgY29uc3QgbiA9IG5vcm1hbEF0KHgsIHopO1xuICAgICAgcmV0dXJuIHRtcC5zZXQobi54LCBuLnksIG4ueik7XG4gICAgfSxcblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAvLyAxLiBDbGVhbnVwOiBVbnN1YiwgcHJ1bmUgYWxsLCBkaXNwb3NlIHNoYXJlZCBtYXRzLlxuICAgICAgdW5zdWJzY3JpYmU/LigpO1xuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICB9XG4gICAgICBjaHVua3MuY2xlYXIoKTtcblxuICAgICAgLy8gRGlzcG9zZSBzaGFyZWQgbWF0ZXJpYWxzIChpbmNsLiB0ZXh0dXJlIGlmIGxvYWRlZClcbiAgICAgIE9iamVjdC52YWx1ZXMoc2hhcmVkTWF0ZXJpYWxzKS5mb3JFYWNoKG1hdCA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdCkpIHtcbiAgICAgICAgICBtYXQuZm9yRWFjaChtID0+IG0uZGlzcG9zZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXQuZGlzcG9zZSgpO1xuICAgICAgICAgIGlmIChtYXQubWFwKSBtYXQubWFwLmRpc3Bvc2UoKTsgLy8gRXhwbGljaXRseSBkaXNwb3NlIHRleHR1cmVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0iXSwibmFtZXMiOlsiVEhSRUUiLCJoZWlnaHRBdCIsIm5vcm1hbEF0IiwiZ2V0RGlmZmljdWx0eVN0YXRlIiwib25EaWZmaWN1bHR5Q2hhbmdlIiwiQ0hVTktfU0laRSIsIlZFUlRTIiwiSEFMRiIsIkFDVElWRV9SQURJVVMiLCJGQURFX0RVUkFUSU9OIiwia2V5IiwiaXgiLCJpeiIsInRvQ2h1bmsiLCJ4IiwiTWF0aCIsImZsb29yIiwiZW52Q2FjaGUiLCJlbnZpcm9ubWVudCIsInNoYXJlZE1hdGVyaWFscyIsInRlcnJhaW4iLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwicm91Z2huZXNzIiwibWV0YWxuZXNzIiwibWFwIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5Iiwicm9jayIsImJ1aWxkQ2h1bmsiLCJnIiwiUGxhbmVHZW9tZXRyeSIsInJvdGF0ZVgiLCJQSSIsInBvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImkiLCJjb3VudCIsInZ4IiwiZ2V0WCIsInZ6IiwiZ2V0WiIsImgiLCJzZXRZIiwibmVlZHNVcGRhdGUiLCJjb21wdXRlVmVydGV4Tm9ybWFscyIsInV2Iiwic2V0WFkiLCJnZXRZIiwibWVzaCIsIk1lc2giLCJzZXQiLCJyZWNlaXZlU2hhZG93IiwiY2FzdFNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ1c2VyRGF0YSIsImRlY29yYXRpb25zIiwiaW5zdGFuY2VDb3VudHMiLCJyb2NrcyIsIndpbmRzIiwiZmFkZVN0YXJ0IiwidGFyZ2V0T3BhY2l0eSIsIm1hdGVyaWFsIiwiZGVjb3JhdGVDaHVuayIsInByZXZpb3VzIiwib2JqIiwicmVtb3ZlIiwidHJhdmVyc2UiLCJjaGlsZCIsImdlb21ldHJ5IiwiZGlzcG9zZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hdCIsInByb3BEZW5zaXR5IiwicHJvcENvdW50IiwibWF4Iiwicm91bmQiLCJ3aW5kQ291bnQiLCJyb2NrR2VvIiwiSWNvc2FoZWRyb25HZW9tZXRyeSIsInJhbmRvbSIsInJvY2tJbnN0YW5jZXMiLCJJbnN0YW5jZWRNZXNoIiwicm9ja01hdHJpeCIsIk1hdHJpeDQiLCJ0bXBQb3MiLCJWZWN0b3IzIiwidG1wUXVhdCIsIlF1YXRlcm5pb24iLCJ0bXBTY2FsZSIsImxvY2FsWCIsImxvY2FsWiIsIndvcmxkWCIsIndvcmxkWiIsImJhc2VIZWlnaHQiLCJ5Iiwibm9ybSIsInVwIiwibm9ybWFsVmVjIiwieiIsIm5vcm1hbGl6ZSIsImFsaWdubWVudFF1YXQiLCJzZXRGcm9tVW5pdFZlY3RvcnMiLCJyYW5kb21FdWxlciIsIkV1bGVyIiwicmFuZG9tUXVhdCIsInNldEZyb21FdWxlciIsImNvcHkiLCJtdWx0aXBseSIsInNjYWxlIiwiY29tcG9zZSIsInNldE1hdHJpeEF0IiwiaW5zdGFuY2VNYXRyaXgiLCJhZGQiLCJwdXNoIiwiZm9nR2VvIiwiZm9nTWF0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzaWRlIiwiRG91YmxlU2lkZSIsImZvZyIsInJvdGF0aW9uIiwiY3JlYXRlU3RyZWFtZXIiLCJzY2VuZSIsImNodW5rcyIsIk1hcCIsInRtcCIsImVudmlyb25tZW50RGlydHkiLCJhbmltYXRpb25UaW1lIiwiY2xvY2siLCJDbG9jayIsImxvYWRlciIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwidGV4dHVyZSIsIndyYXBTIiwiUmVwZWF0V3JhcHBpbmciLCJ3cmFwVCIsImFuaXNvdHJvcHkiLCJlbmNvZGluZyIsInNSR0JFbmNvZGluZyIsInNpemUiLCJtIiwidmFsdWVzIiwiY29uc29sZSIsImxvZyIsInByb2dyZXNzIiwibG9hZGVkIiwidG90YWwiLCJlcnJvciIsInVuc3Vic2NyaWJlIiwic3RhdGUiLCJlbnN1cmUiLCJrIiwiaGFzIiwiZ2V0RWxhcHNlZFRpbWUiLCJwcnVuZSIsImNlbnRlclgiLCJjZW50ZXJaIiwiZHgiLCJkeiIsImRpc3QiLCJhYnMiLCJzZXRUaW1lb3V0IiwiZGlzcG9zZUNodW5rIiwiZGVsZXRlIiwiZGVjbyIsInVwZGF0ZUZhZGVzIiwiZHQiLCJub3ciLCJlbGFwc2VkIiwidXBkYXRlIiwiZWZmZWN0aXZlUmFkaXVzIiwiY3giLCJjeiIsInF1ZXJ5SGVpZ2h0IiwicXVlcnlOb3JtYWwiLCJuIiwiY2xlYXIiLCJPYmplY3QiLCJmb3JFYWNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});