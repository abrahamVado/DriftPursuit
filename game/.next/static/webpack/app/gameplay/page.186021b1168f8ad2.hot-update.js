"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 512;\nconst VERTS_NEAR = 64; // High detail for close chunks\nconst VERTS_FAR = 32; // Low detail for distant chunks\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS_NEAR = 2; // High-detail ring\nconst ACTIVE_RADIUS_FAR = 4; // Low-detail outer ring\nconst FADE_DURATION = 0.5; // Seconds for LOD fade transitions\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0,\n        // Texture added: Load a grass/terrain texture for detail\n        map: null,\n        transparent: true,\n        opacity: 1.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    })\n};\nfunction buildChunk(ix, iz, detailLevel) {\n    const verts = detailLevel === 'near' ? VERTS_NEAR : VERTS_FAR;\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, verts, verts);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // UV scaling for texture tiling - Increased tiling for seamless repeat\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 8, uv.getY(i) * 8); // Tile 8x for finer detail/variety\n    }\n    uv.needsUpdate = true;\n    // Recompute normals after UV to ensure lighting consistency\n    g.computeVertexNormals();\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(g, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false; // Terrain doesn't cast\n    mesh.userData = {\n        ix,\n        iz,\n        detailLevel,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        },\n        fadeStart: 0,\n        targetOpacity: 1.0\n    };\n    mesh.material.opacity = 0.0; // Start faded for smooth entry\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations idempotently with proper disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        obj.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                child.geometry.dispose();\n                const material = child.material;\n                if (Array.isArray(material)) {\n                    var _mat_dispose;\n                    for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                } else {\n                    var _material_dispose;\n                    (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                }\n            }\n        });\n    }\n    mesh.userData.decorations = [];\n    const { propDensity } = envCache; // windStrength no longer used\n    const propCount = Math.max(0, Math.round(propDensity * 16)); // Increased density for richness\n    const windCount = 0; // Always 0 - wind removed\n    // Rocks: Use InstancedMesh for batching (perf win for many props)\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1); // Slight detail\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5; // Slight elevation var\n            tmpPos.set(localX, y, localZ);\n            // Alignment quaternion (up vector to normal)\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, normalVec);\n            // Random rotation quaternion (on top of alignment)\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            // Compose matrix\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Removed entirely\n    // Add subtle fog plane for atmospheric depth (per chunk, low poly) - Adjusted opacity without wind\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0; // No longer used for wind\n    const clock = new three__WEBPACK_IMPORTED_MODULE_2__.Clock(); // For fade timing\n    // Load texture asynchronously - Specific path for your PNG\n    const loader = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader();\n    loader.load('/textures/32d4a6ff-3da1-4c7c-a742-1d1fa759e394.png', (texture)=>{\n        // Set wrap modes for seamless tiling\n        texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.anisotropy = 16; // Sharper mipmaps under grazing angles\n        texture.encoding = three__WEBPACK_IMPORTED_MODULE_2__.sRGBEncoding; // For color accuracy\n        // Apply to shared material\n        sharedMaterials.terrain.map = texture;\n        sharedMaterials.terrain.needsUpdate = true;\n        // Rebuild all existing chunks on load to apply texture\n        if (chunks.size > 0) {\n            for (const m of chunks.values()){\n                decorateChunk(m); // Triggers material update\n            }\n        }\n        console.log('Terrain texture loaded and applied');\n    }, (progress)=>{\n        console.log(\"Loading texture: \".concat(progress.loaded / progress.total * 100 | 0, \"%\"));\n    }, (error)=>{\n        console.error('Error loading terrain texture:', error);\n    // Fallback: Keep solid color\n    });\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        // 1. Mark dirty on env change; rebuild decorations next update.\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    // LOD transition queue: {key, oldMesh, newDetail, startTime}\n    const lodQueue = new Map();\n    function ensure(ix, iz, detailLevel) {\n        const k = key(ix, iz);\n        const existing = chunks.get(k);\n        if (existing && existing.userData.detailLevel === detailLevel) {\n            return;\n        }\n        if (existing) {\n            // Queue LOD switch: Fade out old, create new, fade in\n            lodQueue.set(k, {\n                oldMesh: existing,\n                newDetail: detailLevel,\n                startTime: clock.getElapsedTime()\n            });\n            return;\n        }\n        // New chunk: Create and fade in\n        const mesh = buildChunk(ix, iz, detailLevel);\n        mesh.userData.fadeStart = clock.getElapsedTime();\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > ACTIVE_RADIUS_FAR) {\n                // Fade out before prune\n                m.userData.targetOpacity = 0.0;\n                m.material.opacity = 1.0; // Start fade\n                setTimeout(()=>{\n                    if (chunks.has(k)) {\n                        scene.remove(m);\n                        disposeChunk(m);\n                        chunks.delete(k);\n                    }\n                }, FADE_DURATION * 1000);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        // Comprehensive disposal: Geoms, mats (skip shared), instances\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            mesh.remove(deco);\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose(); // Releases instance buffer\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    // Don't dispose shared materials here\n    }\n    // Update fades and process LOD queue\n    function updateFadesAndLOD(dt) {\n        const now = clock.getElapsedTime();\n        // Process LOD queue\n        for (const [k, queued] of lodQueue){\n            const elapsed = now - queued.startTime;\n            if (elapsed >= FADE_DURATION) {\n                // Fade complete: Remove old, add new\n                scene.remove(queued.oldMesh);\n                disposeChunk(queued.oldMesh);\n                const newMesh = buildChunk(queued.oldMesh.userData.ix, queued.oldMesh.userData.iz, queued.newDetail);\n                newMesh.userData.fadeStart = now;\n                newMesh.position.copy(queued.oldMesh.position); // Match pos\n                chunks.set(k, newMesh);\n                scene.add(newMesh);\n                lodQueue.delete(k);\n            } else {\n                // Fade out old\n                const progress = elapsed / FADE_DURATION;\n                queued.oldMesh.material.opacity = 1.0 - progress;\n            }\n        }\n        // Fade in new/existing chunks\n        for (const m of chunks.values()){\n            if (m.userData.fadeStart > 0) {\n                const elapsed = now - m.userData.fadeStart;\n                if (elapsed < FADE_DURATION) {\n                    const progress = elapsed / FADE_DURATION;\n                    m.material.opacity = progress;\n                } else {\n                    m.material.opacity = m.userData.targetOpacity || 1.0;\n                    m.userData.fadeStart = 0; // Done\n                }\n            }\n        }\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            // Dynamic radius based on envCache (e.g., denser fog = smaller radius) - propDensity only now\n            const effectiveNear = Math.max(1, ACTIVE_RADIUS_NEAR);\n            const effectiveFar = Math.max(3, ACTIVE_RADIUS_FAR - envCache.propDensity * 0.2);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // Ensure near chunks (high detail)\n            for(let dz = -effectiveNear; dz <= effectiveNear; dz++){\n                for(let dx = -effectiveNear; dx <= effectiveNear; dx++){\n                    ensure(cx + dx, cz + dz, 'near');\n                }\n            }\n            // Ensure far chunks (low detail)\n            for(let dz = -effectiveFar; dz <= effectiveFar; dz++){\n                for(let dx = -effectiveFar; dx <= effectiveFar; dx++){\n                    if (Math.max(Math.abs(dx), Math.abs(dz)) > effectiveNear) {\n                        ensure(cx + dx, cz + dz, 'far');\n                    }\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                }\n                environmentDirty = false;\n            }\n            // Animate wind columns - Removed\n            updateFadesAndLOD(dt); // Handle fades and LOD transitions\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            // 1. Cleanup: Unsub, prune all, dispose shared mats.\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            lodQueue.clear();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            // Dispose shared materials (incl. texture if loaded)\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                    if (mat.map) mat.map.dispose(); // Explicitly dispose texture\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLGFBQWEsSUFBSSwrQkFBK0I7QUFDdEQsTUFBTUMsWUFBWSxJQUFJLGdDQUFnQztBQUN0RCxNQUFNQyxPQUFPSCxhQUFhO0FBQzFCLE1BQU1JLHFCQUFxQixHQUFHLG1CQUFtQjtBQUNqRCxNQUFNQyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDckQsTUFBTUMsZ0JBQWdCLEtBQUssbUNBQW1DO0FBRTlELFNBQVNDLElBQUlDLEVBQVUsRUFBRUMsRUFBVTtJQUFJLE9BQU8sR0FBU0EsT0FBTkQsSUFBRyxLQUFNLE9BQUhDO0FBQU07QUFDN0QsU0FBU0MsUUFBUUMsQ0FBUztJQUFJLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0YsSUFBSVg7QUFBYTtBQUVqRSxJQUFJYyxXQUFXaEIsc0VBQWtCQSxHQUFHaUIsV0FBVztBQUUvQyxpRUFBaUU7QUFDakUsTUFBTUMsa0JBQWtCO0lBQ3RCQyxTQUFTLElBQUl0Qix1REFBMEIsQ0FBQztRQUN0Q3dCLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO1FBQ1gseURBQXlEO1FBQ3pEQyxLQUFLO1FBQ0xDLGFBQWE7UUFDYkMsU0FBUztJQUNYO0lBQ0FDLE1BQU0sSUFBSTlCLHVEQUEwQixDQUFDO1FBQ25Dd0IsT0FBTztRQUNQQyxXQUFXO1FBQ1hDLFdBQVc7SUFDYjtBQUVGO0FBRUEsU0FBU0ssV0FBV2xCLEVBQVUsRUFBRUMsRUFBVSxFQUFFa0IsV0FBMkI7SUFDckUsTUFBTUMsUUFBUUQsZ0JBQWdCLFNBQVMxQixhQUFhQztJQUNwRCxNQUFNMkIsSUFBSSxJQUFJbEMsZ0RBQW1CLENBQUNLLFlBQVlBLFlBQVk0QixPQUFPQTtJQUNqRUMsRUFBRUUsT0FBTyxDQUFDLENBQUNuQixLQUFLb0IsRUFBRSxHQUFHO0lBRXJCLE1B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dXJjZXMiOlsiL2FwcC9zcmMvd29ybGQvY2h1bmtzL3N0cmVhbWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGhlaWdodEF0LCBub3JtYWxBdCB9IGZyb20gJy4vZ2VuZXJhdGVIZWlnaHQnO1xuaW1wb3J0IHsgZ2V0RGlmZmljdWx0eVN0YXRlLCBvbkRpZmZpY3VsdHlDaGFuZ2UgfSBmcm9tICdAL2VuZ2luZS9kaWZmaWN1bHR5JztcblxuY29uc3QgQ0hVTktfU0laRSA9IDUxMjtcbmNvbnN0IFZFUlRTX05FQVIgPSA2NDsgLy8gSGlnaCBkZXRhaWwgZm9yIGNsb3NlIGNodW5rc1xuY29uc3QgVkVSVFNfRkFSID0gMzI7IC8vIExvdyBkZXRhaWwgZm9yIGRpc3RhbnQgY2h1bmtzXG5jb25zdCBIQUxGID0gQ0hVTktfU0laRSAvIDI7XG5jb25zdCBBQ1RJVkVfUkFESVVTX05FQVIgPSAyOyAvLyBIaWdoLWRldGFpbCByaW5nXG5jb25zdCBBQ1RJVkVfUkFESVVTX0ZBUiA9IDQ7IC8vIExvdy1kZXRhaWwgb3V0ZXIgcmluZ1xuY29uc3QgRkFERV9EVVJBVElPTiA9IDAuNTsgLy8gU2Vjb25kcyBmb3IgTE9EIGZhZGUgdHJhbnNpdGlvbnNcblxuZnVuY3Rpb24ga2V5KGl4OiBudW1iZXIsIGl6OiBudW1iZXIpIHsgcmV0dXJuIGAke2l4fSwke2l6fWA7IH1cbmZ1bmN0aW9uIHRvQ2h1bmsoeDogbnVtYmVyKSB7IHJldHVybiBNYXRoLmZsb29yKHggLyBDSFVOS19TSVpFKTsgfVxuXG5sZXQgZW52Q2FjaGUgPSBnZXREaWZmaWN1bHR5U3RhdGUoKS5lbnZpcm9ubWVudDtcblxuLy8gU2hhcmVkIG1hdGVyaWFscyBmb3IgZWZmaWNpZW5jeSAoZGlzcG9zZSBvbiBzdHJlYW1lciB0ZWFyZG93bilcbmNvbnN0IHNoYXJlZE1hdGVyaWFscyA9IHtcbiAgdGVycmFpbjogbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICBjb2xvcjogMHg1MDZhNTIsXG4gICAgcm91Z2huZXNzOiAwLjk1LFxuICAgIG1ldGFsbmVzczogMC4wLFxuICAgIC8vIFRleHR1cmUgYWRkZWQ6IExvYWQgYSBncmFzcy90ZXJyYWluIHRleHR1cmUgZm9yIGRldGFpbFxuICAgIG1hcDogbnVsbCwgLy8gV2lsbCBiZSBzZXQgYWZ0ZXIgbG9hZGluZ1xuICAgIHRyYW5zcGFyZW50OiB0cnVlLCAvLyBFbmFibGUgZm9yIGZhZGVcbiAgICBvcGFjaXR5OiAxLjAsXG4gIH0pLFxuICByb2NrOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDRhNGY0NCxcbiAgICByb3VnaG5lc3M6IDAuOCxcbiAgICBtZXRhbG5lc3M6IDAuMSxcbiAgfSksXG4gIC8vIHdpbmQ6IFJlbW92ZWQgLSBubyBsb25nZXIgbmVlZGVkXG59O1xuXG5mdW5jdGlvbiBidWlsZENodW5rKGl4OiBudW1iZXIsIGl6OiBudW1iZXIsIGRldGFpbExldmVsOiAnbmVhcicgfCAnZmFyJykge1xuICBjb25zdCB2ZXJ0cyA9IGRldGFpbExldmVsID09PSAnbmVhcicgPyBWRVJUU19ORUFSIDogVkVSVFNfRkFSO1xuICBjb25zdCBnID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSwgQ0hVTktfU0laRSwgdmVydHMsIHZlcnRzKTtcbiAgZy5yb3RhdGVYKC1NYXRoLlBJIC8gMik7XG5cbiAgY29uc3QgcG9zID0gZy5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHZ4ID0gcG9zLmdldFgoaSkgKyBpeCAqIENIVU5LX1NJWkU7XG4gICAgY29uc3QgdnogPSBwb3MuZ2V0WihpKSArIGl6ICogQ0hVTktfU0laRTtcbiAgICBjb25zdCBoID0gaGVpZ2h0QXQodngsIHZ6KTtcbiAgICBwb3Muc2V0WShpLCBoKTtcbiAgfVxuICBwb3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gVVYgc2NhbGluZyBmb3IgdGV4dHVyZSB0aWxpbmcgLSBJbmNyZWFzZWQgdGlsaW5nIGZvciBzZWFtbGVzcyByZXBlYXRcbiAgY29uc3QgdXYgPSBnLmF0dHJpYnV0ZXMudXYgYXMgVEhSRUUuQnVmZmVyQXR0cmlidXRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICB1di5zZXRYWShpLCB1di5nZXRYKGkpICogOCwgdXYuZ2V0WShpKSAqIDgpOyAvLyBUaWxlIDh4IGZvciBmaW5lciBkZXRhaWwvdmFyaWV0eVxuICB9XG4gIHV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBSZWNvbXB1dGUgbm9ybWFscyBhZnRlciBVViB0byBlbnN1cmUgbGlnaHRpbmcgY29uc2lzdGVuY3lcbiAgZy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnLCBzaGFyZWRNYXRlcmlhbHMudGVycmFpbik7XG4gIG1lc2gucG9zaXRpb24uc2V0KGl4ICogQ0hVTktfU0laRSwgMCwgaXogKiBDSFVOS19TSVpFKTtcbiAgbWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgbWVzaC5jYXN0U2hhZG93ID0gZmFsc2U7IC8vIFRlcnJhaW4gZG9lc24ndCBjYXN0XG4gIG1lc2gudXNlckRhdGEgPSB7XG4gICAgaXgsXG4gICAgaXosXG4gICAgZGV0YWlsTGV2ZWwsXG4gICAgZGVjb3JhdGlvbnM6IFtdIGFzIFRIUkVFLk9iamVjdDNEW10sXG4gICAgaW5zdGFuY2VDb3VudHM6IHsgcm9ja3M6IDAsIHdpbmRzOiAwIH0sIC8vIEZvciBpbnN0YW5jZWQgY2xlYW51cFxuICAgIGZhZGVTdGFydDogMCwgLy8gVGltZXN0YW1wIGZvciBmYWRlLWluXG4gICAgdGFyZ2V0T3BhY2l0eTogMS4wLFxuICB9O1xuICBtZXNoLm1hdGVyaWFsLm9wYWNpdHkgPSAwLjA7IC8vIFN0YXJ0IGZhZGVkIGZvciBzbW9vdGggZW50cnlcblxuICBkZWNvcmF0ZUNodW5rKG1lc2gpO1xuICByZXR1cm4gbWVzaDtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVDaHVuayhtZXNoOiBUSFJFRS5NZXNoKSB7XG4gIC8vIDEuIENsZWFyIGV4aXN0aW5nIGRlY29yYXRpb25zIGlkZW1wb3RlbnRseSB3aXRoIHByb3BlciBkaXNwb3NhbC5cbiAgY29uc3QgcHJldmlvdXMgPSBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID8/IFtdO1xuICBmb3IgKGNvbnN0IG9iaiBvZiBwcmV2aW91cykge1xuICAgIG1lc2gucmVtb3ZlKG9iaik7XG4gICAgb2JqLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ZXJpYWwuZGlzcG9zZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID0gW107XG5cbiAgY29uc3QgeyBwcm9wRGVuc2l0eSB9ID0gZW52Q2FjaGU7IC8vIHdpbmRTdHJlbmd0aCBubyBsb25nZXIgdXNlZFxuICBjb25zdCBwcm9wQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHByb3BEZW5zaXR5ICogMTYpKTsgLy8gSW5jcmVhc2VkIGRlbnNpdHkgZm9yIHJpY2huZXNzXG4gIGNvbnN0IHdpbmRDb3VudCA9IDA7IC8vIEFsd2F5cyAwIC0gd2luZCByZW1vdmVkXG5cbiAgLy8gUm9ja3M6IFVzZSBJbnN0YW5jZWRNZXNoIGZvciBiYXRjaGluZyAocGVyZiB3aW4gZm9yIG1hbnkgcHJvcHMpXG4gIGlmIChwcm9wQ291bnQgPiAwKSB7XG4gICAgY29uc3Qgcm9ja0dlbyA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KDEuNSArIE1hdGgucmFuZG9tKCkgKiAyLjUsIDEpOyAvLyBTbGlnaHQgZGV0YWlsXG4gICAgY29uc3Qgcm9ja0luc3RhbmNlcyA9IG5ldyBUSFJFRS5JbnN0YW5jZWRNZXNoKHJvY2tHZW8sIHNoYXJlZE1hdGVyaWFscy5yb2NrLCBwcm9wQ291bnQpO1xuICAgIGNvbnN0IHJvY2tNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIGNvbnN0IHRtcFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdG1wUXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgY29uc3QgdG1wU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbG9jYWxYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRTtcbiAgICAgIGNvbnN0IGxvY2FsWiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIENIVU5LX1NJWkU7XG4gICAgICBjb25zdCB3b3JsZFggPSBtZXNoLnVzZXJEYXRhLml4ICogQ0hVTktfU0laRSArIGxvY2FsWDtcbiAgICAgIGNvbnN0IHdvcmxkWiA9IG1lc2gudXNlckRhdGEuaXogKiBDSFVOS19TSVpFICsgbG9jYWxaO1xuICAgICAgY29uc3QgYmFzZUhlaWdodCA9IGhlaWdodEF0KHdvcmxkWCwgd29ybGRaKTtcbiAgICAgIGNvbnN0IHkgPSBiYXNlSGVpZ2h0IC0gbWVzaC5wb3NpdGlvbi55ICsgMSArIE1hdGgucmFuZG9tKCkgKiAwLjU7IC8vIFNsaWdodCBlbGV2YXRpb24gdmFyXG4gICAgICB0bXBQb3Muc2V0KGxvY2FsWCwgeSwgbG9jYWxaKTtcblxuICAgICAgLy8gQWxpZ25tZW50IHF1YXRlcm5pb24gKHVwIHZlY3RvciB0byBub3JtYWwpXG4gICAgICBjb25zdCBub3JtID0gbm9ybWFsQXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3QgdXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTtcbiAgICAgIGNvbnN0IG5vcm1hbFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKG5vcm0ueCwgbm9ybS55LCBub3JtLnopLm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgYWxpZ25tZW50UXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKHVwLCBub3JtYWxWZWMpO1xuXG4gICAgICAvLyBSYW5kb20gcm90YXRpb24gcXVhdGVybmlvbiAob24gdG9wIG9mIGFsaWdubWVudClcbiAgICAgIGNvbnN0IHJhbmRvbUV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKFxuICAgICAgICBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICAnWFlaJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhbmRvbVF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21FdWxlcihyYW5kb21FdWxlcik7XG4gICAgICB0bXBRdWF0LmNvcHkoYWxpZ25tZW50UXVhdCkubXVsdGlwbHkocmFuZG9tUXVhdCk7XG5cbiAgICAgIC8vIFNjYWxlXG4gICAgICBjb25zdCBzY2FsZSA9IDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjQ7XG4gICAgICB0bXBTY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cbiAgICAgIC8vIENvbXBvc2UgbWF0cml4XG4gICAgICByb2NrTWF0cml4LmNvbXBvc2UodG1wUG9zLCB0bXBRdWF0LCB0bXBTY2FsZSk7XG4gICAgICByb2NrSW5zdGFuY2VzLnNldE1hdHJpeEF0KGksIHJvY2tNYXRyaXgpO1xuICAgIH1cbiAgICByb2NrSW5zdGFuY2VzLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByb2NrSW5zdGFuY2VzLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgIHJvY2tJbnN0YW5jZXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuICAgIG1lc2guYWRkKHJvY2tJbnN0YW5jZXMpO1xuICAgIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMucHVzaChyb2NrSW5zdGFuY2VzKTtcbiAgICBtZXNoLnVzZXJEYXRhLmluc3RhbmNlQ291bnRzLnJvY2tzID0gcHJvcENvdW50O1xuICB9XG5cbiAgLy8gV2luZCBjb2x1bW5zOiBSZW1vdmVkIGVudGlyZWx5XG5cbiAgLy8gQWRkIHN1YnRsZSBmb2cgcGxhbmUgZm9yIGF0bW9zcGhlcmljIGRlcHRoIChwZXIgY2h1bmssIGxvdyBwb2x5KSAtIEFkanVzdGVkIG9wYWNpdHkgd2l0aG91dCB3aW5kXG4gIGNvbnN0IGZvZ0dlbyA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KENIVU5LX1NJWkUgKiAxLjIsIENIVU5LX1NJWkUgKiAxLjIsIDEsIDEpO1xuICBjb25zdCBmb2dNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDg4Y2NmZixcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBvcGFjaXR5OiAwLjA1LCAvLyBGaXhlZCBsb3cgdmFsdWUsIG5vIHdpbmQgdGllLWluXG4gICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcbiAgfSk7XG4gIGNvbnN0IGZvZyA9IG5ldyBUSFJFRS5NZXNoKGZvZ0dlbywgZm9nTWF0KTtcbiAgZm9nLnBvc2l0aW9uLnNldCgwLCAyMCwgMCk7XG4gIGZvZy5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICBtZXNoLmFkZChmb2cpO1xuICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zLnB1c2goZm9nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWVyKHNjZW5lOiBUSFJFRS5TY2VuZSkge1xuICBjb25zdCBjaHVua3MgPSBuZXcgTWFwPHN0cmluZywgVEhSRUUuTWVzaD4oKTtcbiAgY29uc3QgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgbGV0IGVudmlyb25tZW50RGlydHkgPSBmYWxzZTtcbiAgbGV0IGFuaW1hdGlvblRpbWUgPSAwOyAvLyBObyBsb25nZXIgdXNlZCBmb3Igd2luZFxuICBjb25zdCBjbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpOyAvLyBGb3IgZmFkZSB0aW1pbmdcblxuICAvLyBMb2FkIHRleHR1cmUgYXN5bmNocm9ub3VzbHkgLSBTcGVjaWZpYyBwYXRoIGZvciB5b3VyIFBOR1xuICBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuICBsb2FkZXIubG9hZChcbiAgICAnL3RleHR1cmVzLzMyZDRhNmZmLTNkYTEtNGM3Yy1hNzQyLTFkMWZhNzU5ZTM5NC5wbmcnLCAvLyBQdWJsaWMgcGF0aCAoZnJvbSAvcHVibGljL3RleHR1cmVzLylcbiAgICAodGV4dHVyZSkgPT4ge1xuICAgICAgLy8gU2V0IHdyYXAgbW9kZXMgZm9yIHNlYW1sZXNzIHRpbGluZ1xuICAgICAgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7IC8vIFNoYXJwZXIgbWlwbWFwcyB1bmRlciBncmF6aW5nIGFuZ2xlc1xuICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IFRIUkVFLnNSR0JFbmNvZGluZzsgLy8gRm9yIGNvbG9yIGFjY3VyYWN5XG5cbiAgICAgIC8vIEFwcGx5IHRvIHNoYXJlZCBtYXRlcmlhbFxuICAgICAgc2hhcmVkTWF0ZXJpYWxzLnRlcnJhaW4ubWFwID0gdGV4dHVyZTtcbiAgICAgIHNoYXJlZE1hdGVyaWFscy50ZXJyYWluLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgLy8gUmVidWlsZCBhbGwgZXhpc3RpbmcgY2h1bmtzIG9uIGxvYWQgdG8gYXBwbHkgdGV4dHVyZVxuICAgICAgaWYgKGNodW5rcy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgICAgZGVjb3JhdGVDaHVuayhtKTsgLy8gVHJpZ2dlcnMgbWF0ZXJpYWwgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdUZXJyYWluIHRleHR1cmUgbG9hZGVkIGFuZCBhcHBsaWVkJyk7XG4gICAgfSxcbiAgICAocHJvZ3Jlc3MpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBMb2FkaW5nIHRleHR1cmU6ICR7KHByb2dyZXNzLmxvYWRlZCAvIHByb2dyZXNzLnRvdGFsICogMTAwIHwgMCl9JWApO1xuICAgIH0sXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRlcnJhaW4gdGV4dHVyZTonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjazogS2VlcCBzb2xpZCBjb2xvclxuICAgIH1cbiAgKTtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9IG9uRGlmZmljdWx0eUNoYW5nZSgoc3RhdGUpID0+IHtcbiAgICAvLyAxLiBNYXJrIGRpcnR5IG9uIGVudiBjaGFuZ2U7IHJlYnVpbGQgZGVjb3JhdGlvbnMgbmV4dCB1cGRhdGUuXG4gICAgZW52Q2FjaGUgPSBzdGF0ZS5lbnZpcm9ubWVudDtcbiAgICBlbnZpcm9ubWVudERpcnR5ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgLy8gTE9EIHRyYW5zaXRpb24gcXVldWU6IHtrZXksIG9sZE1lc2gsIG5ld0RldGFpbCwgc3RhcnRUaW1lfVxuICBjb25zdCBsb2RRdWV1ZSA9IG5ldyBNYXA8c3RyaW5nLCB7b2xkTWVzaDogVEhSRUUuTWVzaCwgbmV3RGV0YWlsOiAnbmVhcid8J2ZhcicsIHN0YXJ0VGltZTogbnVtYmVyfT4oKTtcblxuICBmdW5jdGlvbiBlbnN1cmUoaXg6IG51bWJlciwgaXo6IG51bWJlciwgZGV0YWlsTGV2ZWw6ICduZWFyJyB8ICdmYXInKSB7XG4gICAgY29uc3QgayA9IGtleShpeCwgaXopO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gY2h1bmtzLmdldChrKTtcbiAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcudXNlckRhdGEuZGV0YWlsTGV2ZWwgPT09IGRldGFpbExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAvLyBRdWV1ZSBMT0Qgc3dpdGNoOiBGYWRlIG91dCBvbGQsIGNyZWF0ZSBuZXcsIGZhZGUgaW5cbiAgICAgIGxvZFF1ZXVlLnNldChrLCB7b2xkTWVzaDogZXhpc3RpbmcsIG5ld0RldGFpbDogZGV0YWlsTGV2ZWwsIHN0YXJ0VGltZTogY2xvY2suZ2V0RWxhcHNlZFRpbWUoKX0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5ldyBjaHVuazogQ3JlYXRlIGFuZCBmYWRlIGluXG4gICAgY29uc3QgbWVzaCA9IGJ1aWxkQ2h1bmsoaXgsIGl6LCBkZXRhaWxMZXZlbCk7XG4gICAgbWVzaC51c2VyRGF0YS5mYWRlU3RhcnQgPSBjbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgIGNodW5rcy5zZXQoaywgbWVzaCk7XG4gICAgc2NlbmUuYWRkKG1lc2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJ1bmUoY2VudGVyWDogbnVtYmVyLCBjZW50ZXJaOiBudW1iZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCBtXSBvZiBjaHVua3MpIHtcbiAgICAgIGNvbnN0IGR4ID0gdG9DaHVuayhjZW50ZXJYKSAtIG0udXNlckRhdGEuaXg7XG4gICAgICBjb25zdCBkeiA9IHRvQ2h1bmsoY2VudGVyWikgLSBtLnVzZXJEYXRhLml6O1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHopKTtcbiAgICAgIGlmIChkaXN0ID4gQUNUSVZFX1JBRElVU19GQVIpIHtcbiAgICAgICAgLy8gRmFkZSBvdXQgYmVmb3JlIHBydW5lXG4gICAgICAgIG0udXNlckRhdGEudGFyZ2V0T3BhY2l0eSA9IDAuMDtcbiAgICAgICAgbS5tYXRlcmlhbC5vcGFjaXR5ID0gMS4wOyAvLyBTdGFydCBmYWRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChjaHVua3MuaGFzKGspKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUobSk7XG4gICAgICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICAgICAgICBjaHVua3MuZGVsZXRlKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgRkFERV9EVVJBVElPTiAqIDEwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2VDaHVuayhtZXNoOiBUSFJFRS5NZXNoKSB7XG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBkaXNwb3NhbDogR2VvbXMsIG1hdHMgKHNraXAgc2hhcmVkKSwgaW5zdGFuY2VzXG4gICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgY29uc3QgZGVjb3JhdGlvbnMgPSBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID8/IFtdO1xuICAgIGZvciAoY29uc3QgZGVjbyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgbWVzaC5yZW1vdmUoZGVjbyk7XG4gICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgZGVjby5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIGRlY28uZGlzcG9zZSgpOyAvLyBSZWxlYXNlcyBpbnN0YW5jZSBidWZmZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY28udHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgICAgY2hpbGQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdCBvZiBtYXRlcmlhbCkgbWF0LmRpc3Bvc2U/LigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG9uJ3QgZGlzcG9zZSBzaGFyZWQgbWF0ZXJpYWxzIGhlcmVcbiAgfVxuXG4gIC8vIFVwZGF0ZSBmYWRlcyBhbmQgcHJvY2VzcyBMT0QgcXVldWVcbiAgZnVuY3Rpb24gdXBkYXRlRmFkZXNBbmRMT0QoZHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG5vdyA9IGNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG5cbiAgICAvLyBQcm9jZXNzIExPRCBxdWV1ZVxuICAgIGZvciAoY29uc3QgW2ssIHF1ZXVlZF0gb2YgbG9kUXVldWUpIHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBxdWV1ZWQuc3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWQgPj0gRkFERV9EVVJBVElPTikge1xuICAgICAgICAvLyBGYWRlIGNvbXBsZXRlOiBSZW1vdmUgb2xkLCBhZGQgbmV3XG4gICAgICAgIHNjZW5lLnJlbW92ZShxdWV1ZWQub2xkTWVzaCk7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhxdWV1ZWQub2xkTWVzaCk7XG4gICAgICAgIGNvbnN0IG5ld01lc2ggPSBidWlsZENodW5rKHF1ZXVlZC5vbGRNZXNoLnVzZXJEYXRhLml4LCBxdWV1ZWQub2xkTWVzaC51c2VyRGF0YS5peiwgcXVldWVkLm5ld0RldGFpbCk7XG4gICAgICAgIG5ld01lc2gudXNlckRhdGEuZmFkZVN0YXJ0ID0gbm93O1xuICAgICAgICBuZXdNZXNoLnBvc2l0aW9uLmNvcHkocXVldWVkLm9sZE1lc2gucG9zaXRpb24pOyAvLyBNYXRjaCBwb3NcbiAgICAgICAgY2h1bmtzLnNldChrLCBuZXdNZXNoKTtcbiAgICAgICAgc2NlbmUuYWRkKG5ld01lc2gpO1xuICAgICAgICBsb2RRdWV1ZS5kZWxldGUoayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWRlIG91dCBvbGRcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBlbGFwc2VkIC8gRkFERV9EVVJBVElPTjtcbiAgICAgICAgcXVldWVkLm9sZE1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhZGUgaW4gbmV3L2V4aXN0aW5nIGNodW5rc1xuICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtLnVzZXJEYXRhLmZhZGVTdGFydCA+IDApIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIG0udXNlckRhdGEuZmFkZVN0YXJ0O1xuICAgICAgICBpZiAoZWxhcHNlZCA8IEZBREVfRFVSQVRJT04pIHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGVsYXBzZWQgLyBGQURFX0RVUkFUSU9OO1xuICAgICAgICAgIG0ubWF0ZXJpYWwub3BhY2l0eSA9IHByb2dyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0ubWF0ZXJpYWwub3BhY2l0eSA9IG0udXNlckRhdGEudGFyZ2V0T3BhY2l0eSB8fCAxLjA7XG4gICAgICAgICAgbS51c2VyRGF0YS5mYWRlU3RhcnQgPSAwOyAvLyBEb25lXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZShwb3M6IFRIUkVFLlZlY3RvcjMsIGR0OiBudW1iZXIpIHtcbiAgICAgIGFuaW1hdGlvblRpbWUgKz0gZHQ7XG5cbiAgICAgIC8vIER5bmFtaWMgcmFkaXVzIGJhc2VkIG9uIGVudkNhY2hlIChlLmcuLCBkZW5zZXIgZm9nID0gc21hbGxlciByYWRpdXMpIC0gcHJvcERlbnNpdHkgb25seSBub3dcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZU5lYXIgPSBNYXRoLm1heCgxLCBBQ1RJVkVfUkFESVVTX05FQVIpO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRmFyID0gTWF0aC5tYXgoMywgQUNUSVZFX1JBRElVU19GQVIgLSBlbnZDYWNoZS5wcm9wRGVuc2l0eSAqIDAuMik7XG5cbiAgICAgIGNvbnN0IGN4ID0gdG9DaHVuayhwb3MueCk7XG4gICAgICBjb25zdCBjeiA9IHRvQ2h1bmsocG9zLnopO1xuXG4gICAgICAvLyBFbnN1cmUgbmVhciBjaHVua3MgKGhpZ2ggZGV0YWlsKVxuICAgICAgZm9yIChsZXQgZHogPSAtZWZmZWN0aXZlTmVhcjsgZHogPD0gZWZmZWN0aXZlTmVhcjsgZHorKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC1lZmZlY3RpdmVOZWFyOyBkeCA8PSBlZmZlY3RpdmVOZWFyOyBkeCsrKSB7XG4gICAgICAgICAgZW5zdXJlKGN4ICsgZHgsIGN6ICsgZHosICduZWFyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGZhciBjaHVua3MgKGxvdyBkZXRhaWwpXG4gICAgICBmb3IgKGxldCBkeiA9IC1lZmZlY3RpdmVGYXI7IGR6IDw9IGVmZmVjdGl2ZUZhcjsgZHorKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC1lZmZlY3RpdmVGYXI7IGR4IDw9IGVmZmVjdGl2ZUZhcjsgZHgrKykge1xuICAgICAgICAgIGlmIChNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR6KSkgPiBlZmZlY3RpdmVOZWFyKSB7XG4gICAgICAgICAgICBlbnN1cmUoY3ggKyBkeCwgY3ogKyBkeiwgJ2ZhcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcnVuZShwb3MueCwgcG9zLnopO1xuXG4gICAgICBpZiAoZW52aXJvbm1lbnREaXJ0eSkge1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgICAgZGVjb3JhdGVDaHVuayhtKTtcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGUgd2luZCBjb2x1bW5zIC0gUmVtb3ZlZFxuICAgICAgdXBkYXRlRmFkZXNBbmRMT0QoZHQpOyAvLyBIYW5kbGUgZmFkZXMgYW5kIExPRCB0cmFuc2l0aW9uc1xuICAgIH0sXG5cbiAgICBxdWVyeUhlaWdodCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgcmV0dXJuIGhlaWdodEF0KHgsIHopO1xuICAgIH0sXG5cbiAgICBxdWVyeU5vcm1hbCh4OiBudW1iZXIsIHo6IG51bWJlcikge1xuICAgICAgY29uc3QgbiA9IG5vcm1hbEF0KHgsIHopO1xuICAgICAgcmV0dXJuIHRtcC5zZXQobi54LCBuLnksIG4ueik7XG4gICAgfSxcblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAvLyAxLiBDbGVhbnVwOiBVbnN1YiwgcHJ1bmUgYWxsLCBkaXNwb3NlIHNoYXJlZCBtYXRzLlxuICAgICAgdW5zdWJzY3JpYmU/LigpO1xuICAgICAgbG9kUXVldWUuY2xlYXIoKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgICAgZGlzcG9zZUNodW5rKG0pO1xuICAgICAgfVxuICAgICAgY2h1bmtzLmNsZWFyKCk7XG5cbiAgICAgIC8vIERpc3Bvc2Ugc2hhcmVkIG1hdGVyaWFscyAoaW5jbC4gdGV4dHVyZSBpZiBsb2FkZWQpXG4gICAgICBPYmplY3QudmFsdWVzKHNoYXJlZE1hdGVyaWFscykuZm9yRWFjaChtYXQgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXQpKSB7XG4gICAgICAgICAgbWF0LmZvckVhY2gobSA9PiBtLmRpc3Bvc2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LmRpc3Bvc2UoKTtcbiAgICAgICAgICBpZiAobWF0Lm1hcCkgbWF0Lm1hcC5kaXNwb3NlKCk7IC8vIEV4cGxpY2l0bHkgZGlzcG9zZSB0ZXh0dXJlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59Il0sIm5hbWVzIjpbIlRIUkVFIiwiaGVpZ2h0QXQiLCJub3JtYWxBdCIsImdldERpZmZpY3VsdHlTdGF0ZSIsIm9uRGlmZmljdWx0eUNoYW5nZSIsIkNIVU5LX1NJWkUiLCJWRVJUU19ORUFSIiwiVkVSVFNfRkFSIiwiSEFMRiIsIkFDVElWRV9SQURJVVNfTkVBUiIsIkFDVElWRV9SQURJVVNfRkFSIiwiRkFERV9EVVJBVElPTiIsImtleSIsIml4IiwiaXoiLCJ0b0NodW5rIiwieCIsIk1hdGgiLCJmbG9vciIsImVudkNhY2hlIiwiZW52aXJvbm1lbnQiLCJzaGFyZWRNYXRlcmlhbHMiLCJ0ZXJyYWluIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJjb2xvciIsInJvdWdobmVzcyIsIm1ldGFsbmVzcyIsIm1hcCIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsInJvY2siLCJidWlsZENodW5rIiwiZGV0YWlsTGV2ZWwiLCJ2ZXJ0cyIsImciLCJQbGFuZUdlb21ldHJ5Iiwicm90YXRlWCIsIlBJIiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaSIsImNvdW50IiwidngiLCJnZXRYIiwidnoiLCJnZXRaIiwiaCIsInNldFkiLCJuZWVkc1VwZGF0ZSIsImNvbXB1dGVWZXJ0ZXhOb3JtYWxzIiwidXYiLCJzZXRYWSIsImdldFkiLCJtZXNoIiwiTWVzaCIsInNldCIsInJlY2VpdmVTaGFkb3ciLCJjYXN0U2hhZG93IiwidXNlckRhdGEiLCJkZWNvcmF0aW9ucyIsImluc3RhbmNlQ291bnRzIiwicm9ja3MiLCJ3aW5kcyIsImZhZGVTdGFydCIsInRhcmdldE9wYWNpdHkiLCJtYXRlcmlhbCIsImRlY29yYXRlQ2h1bmsiLCJwcmV2aW91cyIsIm9iaiIsInJlbW92ZSIsInRyYXZlcnNlIiwiY2hpbGQiLCJnZW9tZXRyeSIsImRpc3Bvc2UiLCJBcnJheSIsImlzQXJyYXkiLCJtYXQiLCJwcm9wRGVuc2l0eSIsInByb3BDb3VudCIsIm1heCIsInJvdW5kIiwid2luZENvdW50Iiwicm9ja0dlbyIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJyYW5kb20iLCJyb2NrSW5zdGFuY2VzIiwiSW5zdGFuY2VkTWVzaCIsInJvY2tNYXRyaXgiLCJNYXRyaXg0IiwidG1wUG9zIiwiVmVjdG9yMyIsInRtcFF1YXQiLCJRdWF0ZXJuaW9uIiwidG1wU2NhbGUiLCJsb2NhbFgiLCJsb2NhbFoiLCJ3b3JsZFgiLCJ3b3JsZFoiLCJiYXNlSGVpZ2h0IiwieSIsIm5vcm0iLCJ1cCIsIm5vcm1hbFZlYyIsInoiLCJub3JtYWxpemUiLCJhbGlnbm1lbnRRdWF0Iiwic2V0RnJvbVVuaXRWZWN0b3JzIiwicmFuZG9tRXVsZXIiLCJFdWxlciIsInJhbmRvbVF1YXQiLCJzZXRGcm9tRXVsZXIiLCJjb3B5IiwibXVsdGlwbHkiLCJzY2FsZSIsImNvbXBvc2UiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4IiwiYWRkIiwicHVzaCIsImZvZ0dlbyIsImZvZ01hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwic2lkZSIsIkRvdWJsZVNpZGUiLCJmb2ciLCJyb3RhdGlvbiIsImNyZWF0ZVN0cmVhbWVyIiwic2NlbmUiLCJjaHVua3MiLCJNYXAiLCJ0bXAiLCJlbnZpcm9ubWVudERpcnR5IiwiYW5pbWF0aW9uVGltZSIsImNsb2NrIiwiQ2xvY2siLCJsb2FkZXIiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsInRleHR1cmUiLCJ3cmFwUyIsIlJlcGVhdFdyYXBwaW5nIiwid3JhcFQiLCJhbmlzb3Ryb3B5IiwiZW5jb2RpbmciLCJzUkdCRW5jb2RpbmciLCJzaXplIiwibSIsInZhbHVlcyIsImNvbnNvbGUiLCJsb2ciLCJwcm9ncmVzcyIsImxvYWRlZCIsInRvdGFsIiwiZXJyb3IiLCJ1bnN1YnNjcmliZSIsInN0YXRlIiwibG9kUXVldWUiLCJlbnN1cmUiLCJrIiwiZXhpc3RpbmciLCJnZXQiLCJvbGRNZXNoIiwibmV3RGV0YWlsIiwic3RhcnRUaW1lIiwiZ2V0RWxhcHNlZFRpbWUiLCJwcnVuZSIsImNlbnRlclgiLCJjZW50ZXJaIiwiZHgiLCJkeiIsImRpc3QiLCJhYnMiLCJzZXRUaW1lb3V0IiwiaGFzIiwiZGlzcG9zZUNodW5rIiwiZGVsZXRlIiwiZGVjbyIsInVwZGF0ZUZhZGVzQW5kTE9EIiwiZHQiLCJub3ciLCJxdWV1ZWQiLCJlbGFwc2VkIiwibmV3TWVzaCIsInVwZGF0ZSIsImVmZmVjdGl2ZU5lYXIiLCJlZmZlY3RpdmVGYXIiLCJjeCIsImN6IiwicXVlcnlIZWlnaHQiLCJxdWVyeU5vcm1hbCIsIm4iLCJjbGVhciIsIk9iamVjdCIsImZvckVhY2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});