"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 512;\nconst VERTS = 100; // Fixed medium detail - DISABLE LOD to eliminate switches/flashing\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS = 5; // Increased for more overlap, less boundary issues\nconst FADE_DURATION = 1.0; // Longer fade for smoother transitions\nconst SKIRT_HEIGHT = -10; // Depth for skirt to hide seams\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0,\n        // Texture added: Load a grass/terrain texture for detail\n        map: null,\n        transparent: true,\n        opacity: 1.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    })\n};\nfunction buildChunk(ix, iz) {\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, VERTS, VERTS);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // UV scaling for texture tiling - Increased tiling for seamless repeat\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 8, uv.getY(i) * 8); // Tile 8x for finer detail/variety\n    }\n    uv.needsUpdate = true;\n    // Recompute normals after UV to ensure lighting consistency\n    g.computeVertexNormals();\n    // Add skirt geometry to hide chunk seams\n    const skirtGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n    const skirtPositions = [];\n    const skirtUVs = [];\n    const skirtIndices = [];\n    const segmentWidth = CHUNK_SIZE / (VERTS - 1);\n    const segmentHeight = CHUNK_SIZE / (VERTS - 1);\n    // Top and bottom skirts (Z edges)\n    for(let seg = 0; seg < VERTS; seg++){\n        const x = seg * segmentWidth - HALF;\n        const zTop = HALF;\n        const zBot = -HALF;\n        // Top skirt verts\n        skirtPositions.push(x, SKIRT_HEIGHT, zTop);\n        skirtPositions.push(x + segmentWidth, SKIRT_HEIGHT, zTop);\n        skirtUVs.push(x / CHUNK_SIZE, 1.0);\n        skirtUVs.push((x + segmentWidth) / CHUNK_SIZE, 1.0);\n        // Bottom skirt verts\n        skirtPositions.push(x, SKIRT_HEIGHT, zBot);\n        skirtPositions.push(x + segmentWidth, SKIRT_HEIGHT, zBot);\n        skirtUVs.push(x / CHUNK_SIZE, 0.0);\n        skirtUVs.push((x + segmentWidth) / CHUNK_SIZE, 0.0);\n    }\n    // Left and right skirts (X edges)\n    for(let seg = 0; seg < VERTS; seg++){\n        const z = seg * segmentHeight - HALF;\n        const xLeft = -HALF;\n        const xRight = HALF;\n        // Left skirt verts\n        skirtPositions.push(xLeft, SKIRT_HEIGHT, z);\n        skirtPositions.push(xLeft, SKIRT_HEIGHT, z + segmentHeight);\n        skirtUVs.push(0.0, z / CHUNK_SIZE);\n        skirtUVs.push(0.0, (z + segmentHeight) / CHUNK_SIZE);\n        // Right skirt verts\n        skirtPositions.push(xRight, SKIRT_HEIGHT, z);\n        skirtPositions.push(xRight, SKIRT_HEIGHT, z + segmentHeight);\n        skirtUVs.push(1.0, z / CHUNK_SIZE);\n        skirtUVs.push(1.0, (z + segmentHeight) / CHUNK_SIZE);\n    }\n    // Indices for quads (4 verts per quad)\n    for(let i = 0; i < VERTS * 2 * 2; i += 2){\n        const base = i * 2;\n        skirtIndices.push(base, base + 1, base + 2);\n        skirtIndices.push(base + 1, base + 3, base + 2);\n    }\n    skirtGeometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(skirtPositions, 3));\n    skirtGeometry.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(skirtUVs, 2));\n    skirtGeometry.setIndex(skirtIndices);\n    skirtGeometry.computeVertexNormals();\n    // Merge main geometry with skirt\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometryUtils().mergeBufferGeometries([\n        g,\n        skirtGeometry\n    ]);\n    mergedGeometry.computeVertexNormals();\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(mergedGeometry, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false; // Terrain doesn't cast\n    mesh.frustumCulled = false; // Prevent culling artifacts at edges\n    mesh.userData = {\n        ix,\n        iz,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        },\n        fadeStart: 0,\n        targetOpacity: 1.0\n    };\n    mesh.material.opacity = 0.0; // Start faded for smooth entry\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations idempotently with proper disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        obj.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                child.geometry.dispose();\n                const material = child.material;\n                if (Array.isArray(material)) {\n                    var _mat_dispose;\n                    for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                } else {\n                    var _material_dispose;\n                    (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                }\n            }\n        });\n    }\n    mesh.userData.decorations = [];\n    const { propDensity } = envCache; // windStrength no longer used\n    const propCount = Math.max(0, Math.round(propDensity * 16)); // Increased density for richness\n    const windCount = 0; // Always 0 - wind removed\n    // Rocks: Use InstancedMesh for batching (perf win for many props)\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1); // Slight detail\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5; // Slight elevation var\n            tmpPos.set(localX, y, localZ);\n            // Alignment quaternion (up vector to normal)\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, normalVec);\n            // Random rotation quaternion (on top of alignment)\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            // Compose matrix\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        rockInstances.frustumCulled = false; // Prevent rock culling issues\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Removed entirely\n    // Add subtle fog plane for atmospheric depth (per chunk, low poly) - Adjusted opacity without wind\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0; // No longer used for wind\n    const clock = new three__WEBPACK_IMPORTED_MODULE_2__.Clock(); // For fade timing\n    // Load texture asynchronously - Specific path for your PNG\n    const loader = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader();\n    loader.load('/textures/32d4a6ff-3da1-4c7c-a742-1d1fa759e394.png', (texture)=>{\n        // Set wrap modes for seamless tiling\n        texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        texture.anisotropy = 16; // Sharper mipmaps under grazing angles\n        texture.encoding = three__WEBPACK_IMPORTED_MODULE_2__.sRGBEncoding; // For color accuracy\n        // Apply to shared material\n        sharedMaterials.terrain.map = texture;\n        sharedMaterials.terrain.needsUpdate = true;\n        // Rebuild all existing chunks on load to apply texture\n        if (chunks.size > 0) {\n            for (const m of chunks.values()){\n                decorateChunk(m); // Triggers material update\n            }\n        }\n        console.log('Terrain texture loaded and applied');\n    }, (progress)=>{\n        console.log(\"Loading texture: \".concat(progress.loaded / progress.total * 100 | 0, \"%\"));\n    }, (error)=>{\n        console.error('Error loading terrain texture:', error);\n    // Fallback: Keep solid color\n    });\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        // 1. Mark dirty on env change; rebuild decorations next update.\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    function ensure(ix, iz) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) return;\n        // New chunk: Create and fade in\n        const mesh = buildChunk(ix, iz);\n        mesh.userData.fadeStart = clock.getElapsedTime();\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > ACTIVE_RADIUS) {\n                // Fade out before prune\n                m.userData.targetOpacity = 0.0;\n                setTimeout(()=>{\n                    if (chunks.has(k)) {\n                        scene.remove(m);\n                        disposeChunk(m);\n                        chunks.delete(k);\n                    }\n                }, FADE_DURATION * 1000);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        // Comprehensive disposal: Geoms, mats (skip shared), instances\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            mesh.remove(deco);\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose(); // Releases instance buffer\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    // Don't dispose shared materials here\n    }\n    // Update fades\n    function updateFades(dt) {\n        const now = clock.getElapsedTime();\n        // Fade in new/existing chunks\n        for (const m of chunks.values()){\n            if (m.userData.fadeStart > 0) {\n                const elapsed = now - m.userData.fadeStart;\n                if (elapsed < FADE_DURATION) {\n                    const progress = elapsed / FADE_DURATION;\n                    m.material.opacity = progress;\n                } else {\n                    m.material.opacity = m.userData.targetOpacity || 1.0;\n                    m.userData.fadeStart = 0; // Done\n                }\n            }\n        }\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            // Dynamic radius based on envCache - propDensity only now\n            const effectiveRadius = Math.max(4, ACTIVE_RADIUS - envCache.propDensity * 0.2);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // Ensure chunks\n            for(let dz = -effectiveRadius; dz <= effectiveRadius; dz++){\n                for(let dx = -effectiveRadius; dx <= effectiveRadius; dx++){\n                    ensure(cx + dx, cz + dz);\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                }\n                environmentDirty = false;\n            }\n            // Animate wind columns - Removed\n            updateFades(dt); // Handle fades\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            // 1. Cleanup: Unsub, prune all, dispose shared mats.\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            // Dispose shared materials (incl. texture if loaded)\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                    if (mat.map) mat.map.dispose(); // Explicitly dispose texture\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLFFBQVEsS0FBSyxtRUFBbUU7QUFDdEYsTUFBTUMsT0FBT0YsYUFBYTtBQUMxQixNQUFNRyxnQkFBZ0IsR0FBRyxtREFBbUQ7QUFDNUUsTUFBTUMsZ0JBQWdCLEtBQUssdUNBQXVDO0FBQ2xFLE1BQU1DLGVBQWUsQ0FBQyxJQUFJLGdDQUFnQztBQUUxRCxTQUFTQyxJQUFJQyxFQUFVLEVBQUVDLEVBQVU7SUFBSSxPQUFPLEdBQVNBLE9BQU5ELElBQUcsS0FBTSxPQUFIQztBQUFNO0FBQzdELFNBQVNDLFFBQVFDLENBQVM7SUFBSSxPQUFPQyxLQUFLQyxLQUFLLENBQUNGLElBQUlWO0FBQWE7QUFFakUsSUFBSWEsV0FBV2Ysc0VBQWtCQSxHQUFHZ0IsV0FBVztBQUUvQyxpRUFBaUU7QUFDakUsTUFBTUMsa0JBQWtCO0lBQ3RCQyxTQUFTLElBQUlyQix1REFBMEIsQ0FBQztRQUN0Q3VCLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO1FBQ1gseURBQXlEO1FBQ3pEQyxLQUFLO1FBQ0xDLGFBQWE7UUFDYkMsU0FBUztJQUNYO0lBQ0FDLE1BQU0sSUFBSTdCLHVEQUEwQixDQUFDO1FBQ25DdUIsT0FBTztRQUNQQyxXQUFXO1FBQ1hDLFdBQVc7SUFDYjtBQUVGO0FBRUEsU0FBU0ssV0FBV2xCLEVBQVUsRUFBRUMsRUFBVTtJQUN4QyxNQUFNa0IsSUFBSSxJQUFJL0IsZ0RBQW1CLENBQUNLLFlBQVlBLFlBQVlDLE9BQU9BO0lBQ2pFeUIsRUFBRUUsT0FBTyxDQUFDLENBQUNqQixLQUFLa0IsRUFBRSxHQUFHO0lBRXJCLE1BQU1DLE1BQU1KLEVBQUVLLFVBQVUsQ0FBQ0MsUUFBUTtJQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsSUFBSUksS0FBSyxF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Q0UscURBQXFEO1lBQ3JEK0Usd0JBQUFBLGtDQUFBQTtZQUNBLEtBQUssTUFBTVIsS0FBS2xCLE9BQU9tQixNQUFNLEdBQUk7Z0JBQy9CcUIsYUFBYXRCO1lBQ2Y7WUFDQWxCLE9BQU9zRCxLQUFLO1lBRVoscURBQXFEO1lBQ3JEQyxPQUFPcEMsTUFBTSxDQUFDakosaUJBQWlCc0wsT0FBTyxDQUFDMUcsQ0FBQUE7Z0JBQ3JDLElBQUlGLE1BQU1DLE9BQU8sQ0FBQ0MsTUFBTTtvQkFDdEJBLElBQUkwRyxPQUFPLENBQUN0QyxDQUFBQSxJQUFLQSxFQUFFdkUsT0FBTztnQkFDNUIsT0FBTztvQkFDTEcsSUFBSUgsT0FBTztvQkFDWCxJQUFJRyxJQUFJdEUsR0FBRyxFQUFFc0UsSUFBSXRFLEdBQUcsQ0FBQ21FLE9BQU8sSUFBSSw2QkFBNkI7Z0JBQy9EO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9hcHAvc3JjL3dvcmxkL2NodW5rcy9zdHJlYW1lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBoZWlnaHRBdCwgbm9ybWFsQXQgfSBmcm9tICcuL2dlbmVyYXRlSGVpZ2h0JztcbmltcG9ydCB7IGdldERpZmZpY3VsdHlTdGF0ZSwgb25EaWZmaWN1bHR5Q2hhbmdlIH0gZnJvbSAnQC9lbmdpbmUvZGlmZmljdWx0eSc7XG5cbmNvbnN0IENIVU5LX1NJWkUgPSA1MTI7XG5jb25zdCBWRVJUUyA9IDEwMDsgLy8gRml4ZWQgbWVkaXVtIGRldGFpbCAtIERJU0FCTEUgTE9EIHRvIGVsaW1pbmF0ZSBzd2l0Y2hlcy9mbGFzaGluZ1xuY29uc3QgSEFMRiA9IENIVU5LX1NJWkUgLyAyO1xuY29uc3QgQUNUSVZFX1JBRElVUyA9IDU7IC8vIEluY3JlYXNlZCBmb3IgbW9yZSBvdmVybGFwLCBsZXNzIGJvdW5kYXJ5IGlzc3Vlc1xuY29uc3QgRkFERV9EVVJBVElPTiA9IDEuMDsgLy8gTG9uZ2VyIGZhZGUgZm9yIHNtb290aGVyIHRyYW5zaXRpb25zXG5jb25zdCBTS0lSVF9IRUlHSFQgPSAtMTA7IC8vIERlcHRoIGZvciBza2lydCB0byBoaWRlIHNlYW1zXG5cbmZ1bmN0aW9uIGtleShpeDogbnVtYmVyLCBpejogbnVtYmVyKSB7IHJldHVybiBgJHtpeH0sJHtpen1gOyB9XG5mdW5jdGlvbiB0b0NodW5rKHg6IG51bWJlcikgeyByZXR1cm4gTWF0aC5mbG9vcih4IC8gQ0hVTktfU0laRSk7IH1cblxubGV0IGVudkNhY2hlID0gZ2V0RGlmZmljdWx0eVN0YXRlKCkuZW52aXJvbm1lbnQ7XG5cbi8vIFNoYXJlZCBtYXRlcmlhbHMgZm9yIGVmZmljaWVuY3kgKGRpc3Bvc2Ugb24gc3RyZWFtZXIgdGVhcmRvd24pXG5jb25zdCBzaGFyZWRNYXRlcmlhbHMgPSB7XG4gIHRlcnJhaW46IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4NTA2YTUyLFxuICAgIHJvdWdobmVzczogMC45NSxcbiAgICBtZXRhbG5lc3M6IDAuMCxcbiAgICAvLyBUZXh0dXJlIGFkZGVkOiBMb2FkIGEgZ3Jhc3MvdGVycmFpbiB0ZXh0dXJlIGZvciBkZXRhaWxcbiAgICBtYXA6IG51bGwsIC8vIFdpbGwgYmUgc2V0IGFmdGVyIGxvYWRpbmdcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSwgLy8gRW5hYmxlIGZvciBmYWRlXG4gICAgb3BhY2l0eTogMS4wLFxuICB9KSxcbiAgcm9jazogbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICBjb2xvcjogMHg0YTRmNDQsXG4gICAgcm91Z2huZXNzOiAwLjgsXG4gICAgbWV0YWxuZXNzOiAwLjEsXG4gIH0pLFxuICAvLyB3aW5kOiBSZW1vdmVkIC0gbm8gbG9uZ2VyIG5lZWRlZFxufTtcblxuZnVuY3Rpb24gYnVpbGRDaHVuayhpeDogbnVtYmVyLCBpejogbnVtYmVyKSB7XG4gIGNvbnN0IGcgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShDSFVOS19TSVpFLCBDSFVOS19TSVpFLCBWRVJUUywgVkVSVFMpO1xuICBnLnJvdGF0ZVgoLU1hdGguUEkgLyAyKTtcblxuICBjb25zdCBwb3MgPSBnLmF0dHJpYnV0ZXMucG9zaXRpb24gYXMgVEhSRUUuQnVmZmVyQXR0cmlidXRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvcy5jb3VudDsgaSsrKSB7XG4gICAgY29uc3QgdnggPSBwb3MuZ2V0WChpKSArIGl4ICogQ0hVTktfU0laRTtcbiAgICBjb25zdCB2eiA9IHBvcy5nZXRaKGkpICsgaXogKiBDSFVOS19TSVpFO1xuICAgIGNvbnN0IGggPSBoZWlnaHRBdCh2eCwgdnopO1xuICAgIHBvcy5zZXRZKGksIGgpO1xuICB9XG4gIHBvcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIGcuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAvLyBVViBzY2FsaW5nIGZvciB0ZXh0dXJlIHRpbGluZyAtIEluY3JlYXNlZCB0aWxpbmcgZm9yIHNlYW1sZXNzIHJlcGVhdFxuICBjb25zdCB1diA9IGcuYXR0cmlidXRlcy51diBhcyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgIHV2LnNldFhZKGksIHV2LmdldFgoaSkgKiA4LCB1di5nZXRZKGkpICogOCk7IC8vIFRpbGUgOHggZm9yIGZpbmVyIGRldGFpbC92YXJpZXR5XG4gIH1cbiAgdXYubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gIC8vIFJlY29tcHV0ZSBub3JtYWxzIGFmdGVyIFVWIHRvIGVuc3VyZSBsaWdodGluZyBjb25zaXN0ZW5jeVxuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gQWRkIHNraXJ0IGdlb21ldHJ5IHRvIGhpZGUgY2h1bmsgc2VhbXNcbiAgY29uc3Qgc2tpcnRHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBjb25zdCBza2lydFBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBza2lydFVWcyA9IFtdO1xuICBjb25zdCBza2lydEluZGljZXMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudFdpZHRoID0gQ0hVTktfU0laRSAvIChWRVJUUyAtIDEpO1xuICBjb25zdCBzZWdtZW50SGVpZ2h0ID0gQ0hVTktfU0laRSAvIChWRVJUUyAtIDEpO1xuXG4gIC8vIFRvcCBhbmQgYm90dG9tIHNraXJ0cyAoWiBlZGdlcylcbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgVkVSVFM7IHNlZysrKSB7XG4gICAgY29uc3QgeCA9IHNlZyAqIHNlZ21lbnRXaWR0aCAtIEhBTEY7XG4gICAgY29uc3QgelRvcCA9IEhBTEY7XG4gICAgY29uc3QgekJvdCA9IC1IQUxGO1xuXG4gICAgLy8gVG9wIHNraXJ0IHZlcnRzXG4gICAgc2tpcnRQb3NpdGlvbnMucHVzaCh4LCBTS0lSVF9IRUlHSFQsIHpUb3ApO1xuICAgIHNraXJ0UG9zaXRpb25zLnB1c2goeCArIHNlZ21lbnRXaWR0aCwgU0tJUlRfSEVJR0hULCB6VG9wKTtcbiAgICBza2lydFVWcy5wdXNoKHggLyBDSFVOS19TSVpFLCAxLjApO1xuICAgIHNraXJ0VVZzLnB1c2goKHggKyBzZWdtZW50V2lkdGgpIC8gQ0hVTktfU0laRSwgMS4wKTtcblxuICAgIC8vIEJvdHRvbSBza2lydCB2ZXJ0c1xuICAgIHNraXJ0UG9zaXRpb25zLnB1c2goeCwgU0tJUlRfSEVJR0hULCB6Qm90KTtcbiAgICBza2lydFBvc2l0aW9ucy5wdXNoKHggKyBzZWdtZW50V2lkdGgsIFNLSVJUX0hFSUdIVCwgekJvdCk7XG4gICAgc2tpcnRVVnMucHVzaCh4IC8gQ0hVTktfU0laRSwgMC4wKTtcbiAgICBza2lydFVWcy5wdXNoKCh4ICsgc2VnbWVudFdpZHRoKSAvIENIVU5LX1NJWkUsIDAuMCk7XG4gIH1cblxuICAvLyBMZWZ0IGFuZCByaWdodCBza2lydHMgKFggZWRnZXMpXG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IFZFUlRTOyBzZWcrKykge1xuICAgIGNvbnN0IHogPSBzZWcgKiBzZWdtZW50SGVpZ2h0IC0gSEFMRjtcbiAgICBjb25zdCB4TGVmdCA9IC1IQUxGO1xuICAgIGNvbnN0IHhSaWdodCA9IEhBTEY7XG5cbiAgICAvLyBMZWZ0IHNraXJ0IHZlcnRzXG4gICAgc2tpcnRQb3NpdGlvbnMucHVzaCh4TGVmdCwgU0tJUlRfSEVJR0hULCB6KTtcbiAgICBza2lydFBvc2l0aW9ucy5wdXNoKHhMZWZ0LCBTS0lSVF9IRUlHSFQsIHogKyBzZWdtZW50SGVpZ2h0KTtcbiAgICBza2lydFVWcy5wdXNoKDAuMCwgeiAvIENIVU5LX1NJWkUpO1xuICAgIHNraXJ0VVZzLnB1c2goMC4wLCAoeiArIHNlZ21lbnRIZWlnaHQpIC8gQ0hVTktfU0laRSk7XG5cbiAgICAvLyBSaWdodCBza2lydCB2ZXJ0c1xuICAgIHNraXJ0UG9zaXRpb25zLnB1c2goeFJpZ2h0LCBTS0lSVF9IRUlHSFQsIHopO1xuICAgIHNraXJ0UG9zaXRpb25zLnB1c2goeFJpZ2h0LCBTS0lSVF9IRUlHSFQsIHogKyBzZWdtZW50SGVpZ2h0KTtcbiAgICBza2lydFVWcy5wdXNoKDEuMCwgeiAvIENIVU5LX1NJWkUpO1xuICAgIHNraXJ0VVZzLnB1c2goMS4wLCAoeiArIHNlZ21lbnRIZWlnaHQpIC8gQ0hVTktfU0laRSk7XG4gIH1cblxuICAvLyBJbmRpY2VzIGZvciBxdWFkcyAoNCB2ZXJ0cyBwZXIgcXVhZClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBWRVJUUyAqIDIgKiAyOyBpICs9IDIpIHsgLy8gNCBlZGdlcyAqIFZFUlRTIHNlZ21lbnRzICogMiAodG9wL2JvdCBvciBsZWZ0L3JpZ2h0KVxuICAgIGNvbnN0IGJhc2UgPSBpICogMjtcbiAgICBza2lydEluZGljZXMucHVzaChiYXNlLCBiYXNlICsgMSwgYmFzZSArIDIpO1xuICAgIHNraXJ0SW5kaWNlcy5wdXNoKGJhc2UgKyAxLCBiYXNlICsgMywgYmFzZSArIDIpO1xuICB9XG5cbiAgc2tpcnRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoc2tpcnRQb3NpdGlvbnMsIDMpKTtcbiAgc2tpcnRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoc2tpcnRVVnMsIDIpKTtcbiAgc2tpcnRHZW9tZXRyeS5zZXRJbmRleChza2lydEluZGljZXMpO1xuICBza2lydEdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gTWVyZ2UgbWFpbiBnZW9tZXRyeSB3aXRoIHNraXJ0XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMoKS5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoW2csIHNraXJ0R2VvbWV0cnldKTtcbiAgbWVyZ2VkR2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2gobWVyZ2VkR2VvbWV0cnksIHNoYXJlZE1hdGVyaWFscy50ZXJyYWluKTtcbiAgbWVzaC5wb3NpdGlvbi5zZXQoaXggKiBDSFVOS19TSVpFLCAwLCBpeiAqIENIVU5LX1NJWkUpO1xuICBtZXNoLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICBtZXNoLmNhc3RTaGFkb3cgPSBmYWxzZTsgLy8gVGVycmFpbiBkb2Vzbid0IGNhc3RcbiAgbWVzaC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7IC8vIFByZXZlbnQgY3VsbGluZyBhcnRpZmFjdHMgYXQgZWRnZXNcbiAgbWVzaC51c2VyRGF0YSA9IHtcbiAgICBpeCxcbiAgICBpeixcbiAgICBkZWNvcmF0aW9uczogW10gYXMgVEhSRUUuT2JqZWN0M0RbXSxcbiAgICBpbnN0YW5jZUNvdW50czogeyByb2NrczogMCwgd2luZHM6IDAgfSwgLy8gRm9yIGluc3RhbmNlZCBjbGVhbnVwXG4gICAgZmFkZVN0YXJ0OiAwLCAvLyBUaW1lc3RhbXAgZm9yIGZhZGUtaW5cbiAgICB0YXJnZXRPcGFjaXR5OiAxLjAsXG4gIH07XG4gIG1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IDAuMDsgLy8gU3RhcnQgZmFkZWQgZm9yIHNtb290aCBlbnRyeVxuXG4gIGRlY29yYXRlQ2h1bmsobWVzaCk7XG4gIHJldHVybiBtZXNoO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZUNodW5rKG1lc2g6IFRIUkVFLk1lc2gpIHtcbiAgLy8gMS4gQ2xlYXIgZXhpc3RpbmcgZGVjb3JhdGlvbnMgaWRlbXBvdGVudGx5IHdpdGggcHJvcGVyIGRpc3Bvc2FsLlxuICBjb25zdCBwcmV2aW91cyA9IG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPz8gW107XG4gIGZvciAoY29uc3Qgb2JqIG9mIHByZXZpb3VzKSB7XG4gICAgbWVzaC5yZW1vdmUob2JqKTtcbiAgICBvYmoudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXQgb2YgbWF0ZXJpYWwpIG1hdC5kaXNwb3NlPy4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlPy4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPSBbXTtcblxuICBjb25zdCB7IHByb3BEZW5zaXR5IH0gPSBlbnZDYWNoZTsgLy8gd2luZFN0cmVuZ3RoIG5vIGxvbmdlciB1c2VkXG4gIGNvbnN0IHByb3BDb3VudCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQocHJvcERlbnNpdHkgKiAxNikpOyAvLyBJbmNyZWFzZWQgZGVuc2l0eSBmb3IgcmljaG5lc3NcbiAgY29uc3Qgd2luZENvdW50ID0gMDsgLy8gQWx3YXlzIDAgLSB3aW5kIHJlbW92ZWRcblxuICAvLyBSb2NrczogVXNlIEluc3RhbmNlZE1lc2ggZm9yIGJhdGNoaW5nIChwZXJmIHdpbiBmb3IgbWFueSBwcm9wcylcbiAgaWYgKHByb3BDb3VudCA+IDApIHtcbiAgICBjb25zdCByb2NrR2VvID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoMS41ICsgTWF0aC5yYW5kb20oKSAqIDIuNSwgMSk7IC8vIFNsaWdodCBkZXRhaWxcbiAgICBjb25zdCByb2NrSW5zdGFuY2VzID0gbmV3IFRIUkVFLkluc3RhbmNlZE1lc2gocm9ja0dlbywgc2hhcmVkTWF0ZXJpYWxzLnJvY2ssIHByb3BDb3VudCk7XG4gICAgY29uc3Qgcm9ja01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgY29uc3QgdG1wUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0bXBRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICBjb25zdCB0bXBTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBsb2NhbFggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBDSFVOS19TSVpFO1xuICAgICAgY29uc3QgbG9jYWxaID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRTtcbiAgICAgIGNvbnN0IHdvcmxkWCA9IG1lc2gudXNlckRhdGEuaXggKiBDSFVOS19TSVpFICsgbG9jYWxYO1xuICAgICAgY29uc3Qgd29ybGRaID0gbWVzaC51c2VyRGF0YS5peiAqIENIVU5LX1NJWkUgKyBsb2NhbFo7XG4gICAgICBjb25zdCBiYXNlSGVpZ2h0ID0gaGVpZ2h0QXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3QgeSA9IGJhc2VIZWlnaHQgLSBtZXNoLnBvc2l0aW9uLnkgKyAxICsgTWF0aC5yYW5kb20oKSAqIDAuNTsgLy8gU2xpZ2h0IGVsZXZhdGlvbiB2YXJcbiAgICAgIHRtcFBvcy5zZXQobG9jYWxYLCB5LCBsb2NhbFopO1xuXG4gICAgICAvLyBBbGlnbm1lbnQgcXVhdGVybmlvbiAodXAgdmVjdG9yIHRvIG5vcm1hbClcbiAgICAgIGNvbnN0IG5vcm0gPSBub3JtYWxBdCh3b3JsZFgsIHdvcmxkWik7XG4gICAgICBjb25zdCB1cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICAgICAgY29uc3Qgbm9ybWFsVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMobm9ybS54LCBub3JtLnksIG5vcm0ueikubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnRRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnModXAsIG5vcm1hbFZlYyk7XG5cbiAgICAgIC8vIFJhbmRvbSByb3RhdGlvbiBxdWF0ZXJuaW9uIChvbiB0b3Agb2YgYWxpZ25tZW50KVxuICAgICAgY29uc3QgcmFuZG9tRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICdYWVonXG4gICAgICApO1xuICAgICAgY29uc3QgcmFuZG9tUXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKHJhbmRvbUV1bGVyKTtcbiAgICAgIHRtcFF1YXQuY29weShhbGlnbm1lbnRRdWF0KS5tdWx0aXBseShyYW5kb21RdWF0KTtcblxuICAgICAgLy8gU2NhbGVcbiAgICAgIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDtcbiAgICAgIHRtcFNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcblxuICAgICAgLy8gQ29tcG9zZSBtYXRyaXhcbiAgICAgIHJvY2tNYXRyaXguY29tcG9zZSh0bXBQb3MsIHRtcFF1YXQsIHRtcFNjYWxlKTtcbiAgICAgIHJvY2tJbnN0YW5jZXMuc2V0TWF0cml4QXQoaSwgcm9ja01hdHJpeCk7XG4gICAgfVxuICAgIHJvY2tJbnN0YW5jZXMuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJvY2tJbnN0YW5jZXMuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgcm9ja0luc3RhbmNlcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG4gICAgcm9ja0luc3RhbmNlcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7IC8vIFByZXZlbnQgcm9jayBjdWxsaW5nIGlzc3Vlc1xuICAgIG1lc2guYWRkKHJvY2tJbnN0YW5jZXMpO1xuICAgIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMucHVzaChyb2NrSW5zdGFuY2VzKTtcbiAgICBtZXNoLnVzZXJEYXRhLmluc3RhbmNlQ291bnRzLnJvY2tzID0gcHJvcENvdW50O1xuICB9XG5cbiAgLy8gV2luZCBjb2x1bW5zOiBSZW1vdmVkIGVudGlyZWx5XG5cbiAgLy8gQWRkIHN1YnRsZSBmb2cgcGxhbmUgZm9yIGF0bW9zcGhlcmljIGRlcHRoIChwZXIgY2h1bmssIGxvdyBwb2x5KSAtIEFkanVzdGVkIG9wYWNpdHkgd2l0aG91dCB3aW5kXG4gIGNvbnN0IGZvZ0dlbyA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KENIVU5LX1NJWkUgKiAxLjIsIENIVU5LX1NJWkUgKiAxLjIsIDEsIDEpO1xuICBjb25zdCBmb2dNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDg4Y2NmZixcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBvcGFjaXR5OiAwLjA1LCAvLyBGaXhlZCBsb3cgdmFsdWUsIG5vIHdpbmQgdGllLWluXG4gICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcbiAgfSk7XG4gIGNvbnN0IGZvZyA9IG5ldyBUSFJFRS5NZXNoKGZvZ0dlbywgZm9nTWF0KTtcbiAgZm9nLnBvc2l0aW9uLnNldCgwLCAyMCwgMCk7XG4gIGZvZy5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICBtZXNoLmFkZChmb2cpO1xuICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zLnB1c2goZm9nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWVyKHNjZW5lOiBUSFJFRS5TY2VuZSkge1xuICBjb25zdCBjaHVua3MgPSBuZXcgTWFwPHN0cmluZywgVEhSRUUuTWVzaD4oKTtcbiAgY29uc3QgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgbGV0IGVudmlyb25tZW50RGlydHkgPSBmYWxzZTtcbiAgbGV0IGFuaW1hdGlvblRpbWUgPSAwOyAvLyBObyBsb25nZXIgdXNlZCBmb3Igd2luZFxuICBjb25zdCBjbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpOyAvLyBGb3IgZmFkZSB0aW1pbmdcblxuICAvLyBMb2FkIHRleHR1cmUgYXN5bmNocm9ub3VzbHkgLSBTcGVjaWZpYyBwYXRoIGZvciB5b3VyIFBOR1xuICBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuICBsb2FkZXIubG9hZChcbiAgICAnL3RleHR1cmVzLzMyZDRhNmZmLTNkYTEtNGM3Yy1hNzQyLTFkMWZhNzU5ZTM5NC5wbmcnLCAvLyBQdWJsaWMgcGF0aCAoZnJvbSAvcHVibGljL3RleHR1cmVzLylcbiAgICAodGV4dHVyZSkgPT4ge1xuICAgICAgLy8gU2V0IHdyYXAgbW9kZXMgZm9yIHNlYW1sZXNzIHRpbGluZ1xuICAgICAgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7IC8vIFNoYXJwZXIgbWlwbWFwcyB1bmRlciBncmF6aW5nIGFuZ2xlc1xuICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IFRIUkVFLnNSR0JFbmNvZGluZzsgLy8gRm9yIGNvbG9yIGFjY3VyYWN5XG5cbiAgICAgIC8vIEFwcGx5IHRvIHNoYXJlZCBtYXRlcmlhbFxuICAgICAgc2hhcmVkTWF0ZXJpYWxzLnRlcnJhaW4ubWFwID0gdGV4dHVyZTtcbiAgICAgIHNoYXJlZE1hdGVyaWFscy50ZXJyYWluLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgLy8gUmVidWlsZCBhbGwgZXhpc3RpbmcgY2h1bmtzIG9uIGxvYWQgdG8gYXBwbHkgdGV4dHVyZVxuICAgICAgaWYgKGNodW5rcy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgICAgZGVjb3JhdGVDaHVuayhtKTsgLy8gVHJpZ2dlcnMgbWF0ZXJpYWwgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdUZXJyYWluIHRleHR1cmUgbG9hZGVkIGFuZCBhcHBsaWVkJyk7XG4gICAgfSxcbiAgICAocHJvZ3Jlc3MpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBMb2FkaW5nIHRleHR1cmU6ICR7KHByb2dyZXNzLmxvYWRlZCAvIHByb2dyZXNzLnRvdGFsICogMTAwIHwgMCl9JWApO1xuICAgIH0sXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRlcnJhaW4gdGV4dHVyZTonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjazogS2VlcCBzb2xpZCBjb2xvclxuICAgIH1cbiAgKTtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9IG9uRGlmZmljdWx0eUNoYW5nZSgoc3RhdGUpID0+IHtcbiAgICAvLyAxLiBNYXJrIGRpcnR5IG9uIGVudiBjaGFuZ2U7IHJlYnVpbGQgZGVjb3JhdGlvbnMgbmV4dCB1cGRhdGUuXG4gICAgZW52Q2FjaGUgPSBzdGF0ZS5lbnZpcm9ubWVudDtcbiAgICBlbnZpcm9ubWVudERpcnR5ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5zdXJlKGl4OiBudW1iZXIsIGl6OiBudW1iZXIpIHtcbiAgICBjb25zdCBrID0ga2V5KGl4LCBpeik7XG4gICAgaWYgKGNodW5rcy5oYXMoaykpIHJldHVybjtcblxuICAgIC8vIE5ldyBjaHVuazogQ3JlYXRlIGFuZCBmYWRlIGluXG4gICAgY29uc3QgbWVzaCA9IGJ1aWxkQ2h1bmsoaXgsIGl6KTtcbiAgICBtZXNoLnVzZXJEYXRhLmZhZGVTdGFydCA9IGNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgY2h1bmtzLnNldChrLCBtZXNoKTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZShjZW50ZXJYOiBudW1iZXIsIGNlbnRlclo6IG51bWJlcikge1xuICAgIGZvciAoY29uc3QgW2ssIG1dIG9mIGNodW5rcykge1xuICAgICAgY29uc3QgZHggPSB0b0NodW5rKGNlbnRlclgpIC0gbS51c2VyRGF0YS5peDtcbiAgICAgIGNvbnN0IGR6ID0gdG9DaHVuayhjZW50ZXJaKSAtIG0udXNlckRhdGEuaXo7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeikpO1xuICAgICAgaWYgKGRpc3QgPiBBQ1RJVkVfUkFESVVTKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0IGJlZm9yZSBwcnVuZVxuICAgICAgICBtLnVzZXJEYXRhLnRhcmdldE9wYWNpdHkgPSAwLjA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChjaHVua3MuaGFzKGspKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUobSk7XG4gICAgICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICAgICAgICBjaHVua3MuZGVsZXRlKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgRkFERV9EVVJBVElPTiAqIDEwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2VDaHVuayhtZXNoOiBUSFJFRS5NZXNoKSB7XG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBkaXNwb3NhbDogR2VvbXMsIG1hdHMgKHNraXAgc2hhcmVkKSwgaW5zdGFuY2VzXG4gICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgY29uc3QgZGVjb3JhdGlvbnMgPSBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID8/IFtdO1xuICAgIGZvciAoY29uc3QgZGVjbyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgbWVzaC5yZW1vdmUoZGVjbyk7XG4gICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgZGVjby5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIGRlY28uZGlzcG9zZSgpOyAvLyBSZWxlYXNlcyBpbnN0YW5jZSBidWZmZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY28udHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgICAgY2hpbGQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdCBvZiBtYXRlcmlhbCkgbWF0LmRpc3Bvc2U/LigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG9uJ3QgZGlzcG9zZSBzaGFyZWQgbWF0ZXJpYWxzIGhlcmVcbiAgfVxuXG4gIC8vIFVwZGF0ZSBmYWRlc1xuICBmdW5jdGlvbiB1cGRhdGVGYWRlcyhkdDogbnVtYmVyKSB7XG4gICAgY29uc3Qgbm93ID0gY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcblxuICAgIC8vIEZhZGUgaW4gbmV3L2V4aXN0aW5nIGNodW5rc1xuICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtLnVzZXJEYXRhLmZhZGVTdGFydCA+IDApIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIG0udXNlckRhdGEuZmFkZVN0YXJ0O1xuICAgICAgICBpZiAoZWxhcHNlZCA8IEZBREVfRFVSQVRJT04pIHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGVsYXBzZWQgLyBGQURFX0RVUkFUSU9OO1xuICAgICAgICAgIG0ubWF0ZXJpYWwub3BhY2l0eSA9IHByb2dyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0ubWF0ZXJpYWwub3BhY2l0eSA9IG0udXNlckRhdGEudGFyZ2V0T3BhY2l0eSB8fCAxLjA7XG4gICAgICAgICAgbS51c2VyRGF0YS5mYWRlU3RhcnQgPSAwOyAvLyBEb25lXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZShwb3M6IFRIUkVFLlZlY3RvcjMsIGR0OiBudW1iZXIpIHtcbiAgICAgIGFuaW1hdGlvblRpbWUgKz0gZHQ7XG5cbiAgICAgIC8vIER5bmFtaWMgcmFkaXVzIGJhc2VkIG9uIGVudkNhY2hlIC0gcHJvcERlbnNpdHkgb25seSBub3dcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVJhZGl1cyA9IE1hdGgubWF4KDQsIEFDVElWRV9SQURJVVMgLSBlbnZDYWNoZS5wcm9wRGVuc2l0eSAqIDAuMik7XG4gICAgICBjb25zdCBjeCA9IHRvQ2h1bmsocG9zLngpO1xuICAgICAgY29uc3QgY3ogPSB0b0NodW5rKHBvcy56KTtcblxuICAgICAgLy8gRW5zdXJlIGNodW5rc1xuICAgICAgZm9yIChsZXQgZHogPSAtZWZmZWN0aXZlUmFkaXVzOyBkeiA8PSBlZmZlY3RpdmVSYWRpdXM7IGR6KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtZWZmZWN0aXZlUmFkaXVzOyBkeCA8PSBlZmZlY3RpdmVSYWRpdXM7IGR4KyspIHtcbiAgICAgICAgICBlbnN1cmUoY3ggKyBkeCwgY3ogKyBkeik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJ1bmUocG9zLngsIHBvcy56KTtcblxuICAgICAgaWYgKGVudmlyb25tZW50RGlydHkpIHtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICAgIGRlY29yYXRlQ2h1bmsobSk7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBbmltYXRlIHdpbmQgY29sdW1ucyAtIFJlbW92ZWRcbiAgICAgIHVwZGF0ZUZhZGVzKGR0KTsgLy8gSGFuZGxlIGZhZGVzXG4gICAgfSxcblxuICAgIHF1ZXJ5SGVpZ2h0KHg6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgICByZXR1cm4gaGVpZ2h0QXQoeCwgeik7XG4gICAgfSxcblxuICAgIHF1ZXJ5Tm9ybWFsKHg6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgICBjb25zdCBuID0gbm9ybWFsQXQoeCwgeik7XG4gICAgICByZXR1cm4gdG1wLnNldChuLngsIG4ueSwgbi56KTtcbiAgICB9LFxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIC8vIDEuIENsZWFudXA6IFVuc3ViLCBwcnVuZSBhbGwsIGRpc3Bvc2Ugc2hhcmVkIG1hdHMuXG4gICAgICB1bnN1YnNjcmliZT8uKCk7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhtKTtcbiAgICAgIH1cbiAgICAgIGNodW5rcy5jbGVhcigpO1xuXG4gICAgICAvLyBEaXNwb3NlIHNoYXJlZCBtYXRlcmlhbHMgKGluY2wuIHRleHR1cmUgaWYgbG9hZGVkKVxuICAgICAgT2JqZWN0LnZhbHVlcyhzaGFyZWRNYXRlcmlhbHMpLmZvckVhY2gobWF0ID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0KSkge1xuICAgICAgICAgIG1hdC5mb3JFYWNoKG0gPT4gbS5kaXNwb3NlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdC5kaXNwb3NlKCk7XG4gICAgICAgICAgaWYgKG1hdC5tYXApIG1hdC5tYXAuZGlzcG9zZSgpOyAvLyBFeHBsaWNpdGx5IGRpc3Bvc2UgdGV4dHVyZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSJdLCJuYW1lcyI6WyJUSFJFRSIsImhlaWdodEF0Iiwibm9ybWFsQXQiLCJnZXREaWZmaWN1bHR5U3RhdGUiLCJvbkRpZmZpY3VsdHlDaGFuZ2UiLCJDSFVOS19TSVpFIiwiVkVSVFMiLCJIQUxGIiwiQUNUSVZFX1JBRElVUyIsIkZBREVfRFVSQVRJT04iLCJTS0lSVF9IRUlHSFQiLCJrZXkiLCJpeCIsIml6IiwidG9DaHVuayIsIngiLCJNYXRoIiwiZmxvb3IiLCJlbnZDYWNoZSIsImVudmlyb25tZW50Iiwic2hhcmVkTWF0ZXJpYWxzIiwidGVycmFpbiIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiY29sb3IiLCJyb3VnaG5lc3MiLCJtZXRhbG5lc3MiLCJtYXAiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJyb2NrIiwiYnVpbGRDaHVuayIsImciLCJQbGFuZUdlb21ldHJ5Iiwicm90YXRlWCIsIlBJIiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaSIsImNvdW50IiwidngiLCJnZXRYIiwidnoiLCJnZXRaIiwiaCIsInNldFkiLCJuZWVkc1VwZGF0ZSIsImNvbXB1dGVWZXJ0ZXhOb3JtYWxzIiwidXYiLCJzZXRYWSIsImdldFkiLCJza2lydEdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJza2lydFBvc2l0aW9ucyIsInNraXJ0VVZzIiwic2tpcnRJbmRpY2VzIiwic2VnbWVudFdpZHRoIiwic2VnbWVudEhlaWdodCIsInNlZyIsInpUb3AiLCJ6Qm90IiwicHVzaCIsInoiLCJ4TGVmdCIsInhSaWdodCIsImJhc2UiLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwic2V0SW5kZXgiLCJtZXJnZWRHZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5VXRpbHMiLCJtZXJnZUJ1ZmZlckdlb21ldHJpZXMiLCJtZXNoIiwiTWVzaCIsInNldCIsInJlY2VpdmVTaGFkb3ciLCJjYXN0U2hhZG93IiwiZnJ1c3R1bUN1bGxlZCIsInVzZXJEYXRhIiwiZGVjb3JhdGlvbnMiLCJpbnN0YW5jZUNvdW50cyIsInJvY2tzIiwid2luZHMiLCJmYWRlU3RhcnQiLCJ0YXJnZXRPcGFjaXR5IiwibWF0ZXJpYWwiLCJkZWNvcmF0ZUNodW5rIiwicHJldmlvdXMiLCJvYmoiLCJyZW1vdmUiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwiQXJyYXkiLCJpc0FycmF5IiwibWF0IiwicHJvcERlbnNpdHkiLCJwcm9wQ291bnQiLCJtYXgiLCJyb3VuZCIsIndpbmRDb3VudCIsInJvY2tHZW8iLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwicmFuZG9tIiwicm9ja0luc3RhbmNlcyIsIkluc3RhbmNlZE1lc2giLCJyb2NrTWF0cml4IiwiTWF0cml4NCIsInRtcFBvcyIsIlZlY3RvcjMiLCJ0bXBRdWF0IiwiUXVhdGVybmlvbiIsInRtcFNjYWxlIiwibG9jYWxYIiwibG9jYWxaIiwid29ybGRYIiwid29ybGRaIiwiYmFzZUhlaWdodCIsInkiLCJub3JtIiwidXAiLCJub3JtYWxWZWMiLCJub3JtYWxpemUiLCJhbGlnbm1lbnRRdWF0Iiwic2V0RnJvbVVuaXRWZWN0b3JzIiwicmFuZG9tRXVsZXIiLCJFdWxlciIsInJhbmRvbVF1YXQiLCJzZXRGcm9tRXVsZXIiLCJjb3B5IiwibXVsdGlwbHkiLCJzY2FsZSIsImNvbXBvc2UiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4IiwiYWRkIiwiZm9nR2VvIiwiZm9nTWF0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzaWRlIiwiRG91YmxlU2lkZSIsImZvZyIsInJvdGF0aW9uIiwiY3JlYXRlU3RyZWFtZXIiLCJzY2VuZSIsImNodW5rcyIsIk1hcCIsInRtcCIsImVudmlyb25tZW50RGlydHkiLCJhbmltYXRpb25UaW1lIiwiY2xvY2siLCJDbG9jayIsImxvYWRlciIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwidGV4dHVyZSIsIndyYXBTIiwiUmVwZWF0V3JhcHBpbmciLCJ3cmFwVCIsImFuaXNvdHJvcHkiLCJlbmNvZGluZyIsInNSR0JFbmNvZGluZyIsInNpemUiLCJtIiwidmFsdWVzIiwiY29uc29sZSIsImxvZyIsInByb2dyZXNzIiwibG9hZGVkIiwidG90YWwiLCJlcnJvciIsInVuc3Vic2NyaWJlIiwic3RhdGUiLCJlbnN1cmUiLCJrIiwiaGFzIiwiZ2V0RWxhcHNlZFRpbWUiLCJwcnVuZSIsImNlbnRlclgiLCJjZW50ZXJaIiwiZHgiLCJkeiIsImRpc3QiLCJhYnMiLCJzZXRUaW1lb3V0IiwiZGlzcG9zZUNodW5rIiwiZGVsZXRlIiwiZGVjbyIsInVwZGF0ZUZhZGVzIiwiZHQiLCJub3ciLCJlbGFwc2VkIiwidXBkYXRlIiwiZWZmZWN0aXZlUmFkaXVzIiwiY3giLCJjeiIsInF1ZXJ5SGVpZ2h0IiwicXVlcnlOb3JtYWwiLCJuIiwiY2xlYXIiLCJPYmplY3QiLCJmb3JFYWNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});