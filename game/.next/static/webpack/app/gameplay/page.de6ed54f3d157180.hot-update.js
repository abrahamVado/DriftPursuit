"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 128;\nconst VERTS = 48; // Fixed medium detail to avoid LOD pop/flicker; balance perf & smooth\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS = 4; // Increased for better preloading, less pop-in\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    }),\n    wind: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.18,\n        blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending,\n        depthWrite: false\n    })\n};\n// Global fade helper for chunks (prevents \"neon\" flicker on load/prune)\nconst FADE_DURATION = 0.5; // Sec for smooth in/out\nfunction buildChunk(ix, iz) {\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, VERTS, VERTS);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // Optional: UV scaling for texture tiling\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 4, uv.getY(i) * 4); // Tile 4x\n    }\n    uv.needsUpdate = true;\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(g, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false;\n    mesh.userData = {\n        ix,\n        iz,\n        loadTime: 0,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        }\n    };\n    mesh.material.transparent = true; // Enable for fade\n    mesh.material.opacity = 0; // Start invisible, fade in\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations with disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        if (obj instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n            obj.geometry.dispose();\n            obj.dispose();\n        } else {\n            obj.traverse((child)=>{\n                if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                    child.geometry.dispose();\n                    const material = child.material;\n                    if (Array.isArray(material)) {\n                        var _mat_dispose;\n                        for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                    } else {\n                        var _material_dispose;\n                        (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                    }\n                }\n            });\n        }\n    }\n    mesh.userData.decorations = [];\n    const { propDensity, windStrength } = envCache;\n    const propCount = Math.max(0, Math.round(propDensity * 16));\n    const windCount = Math.max(1, Math.round(windStrength * 2));\n    // Rocks: Instanced for perf\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1);\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5;\n            tmpPos.set(localX, y, localZ);\n            // Normal alignment\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0), normalVec);\n            // Random rotation\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Slower pulse to avoid neon flicker\n    if (windCount > 0) {\n        for(let i = 0; i < windCount; i++){\n            const radius = 2 + windStrength * 2;\n            const height = 60 + windStrength * 20;\n            const segments = 16;\n            const windGeo = new three__WEBPACK_IMPORTED_MODULE_2__.CylinderGeometry(radius, radius * 0.6, height, segments, 4, true);\n            windGeo.rotateX(Math.PI / 2);\n            // Twist for vortex\n            const pos = windGeo.attributes.position;\n            for(let j = 0; j < pos.count; j++){\n                const y = pos.getY(j);\n                const twistAngle = y / height * Math.PI * 4 * windStrength;\n                const x = pos.getX(j);\n                const z = pos.getZ(j);\n                pos.setX(j, x * Math.cos(twistAngle) - z * Math.sin(twistAngle));\n                pos.setZ(j, x * Math.sin(twistAngle) + z * Math.cos(twistAngle));\n            }\n            pos.needsUpdate = true;\n            windGeo.computeVertexNormals();\n            const column = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(windGeo, sharedMaterials.wind);\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE * 0.8;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE * 0.8;\n            column.position.set(localX, height / 2, localZ);\n            column.userData = {\n                time: Math.random() * Math.PI * 2\n            };\n            // Start with base opacity, no initial flicker\n            column.material.opacity = 0.15 + windStrength * 0.03;\n            mesh.add(column);\n            mesh.userData.decorations.push(column);\n        }\n    }\n    // Fog plane: Static, low opacity to avoid flicker\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05 + windStrength * 0.05,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0;\n    const clock = new three__WEBPACK_IMPORTED_MODULE_2__.Clock(); // For fade timing\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    function ensure(ix, iz) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) return;\n        const mesh = buildChunk(ix, iz);\n        mesh.userData.loadTime = clock.getElapsedTime();\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            if (Math.abs(dx) > ACTIVE_RADIUS || Math.abs(dz) > ACTIVE_RADIUS) {\n                // Fade out before remove\n                m.material.opacity = 0;\n                scene.remove(m);\n                disposeChunk(m);\n                chunks.delete(k);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose();\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    }\n    // Fade update helper\n    function updateFades() {\n        const now = clock.getElapsedTime();\n        for (const m of chunks.values()){\n            const elapsed = now - m.userData.loadTime;\n            const fadeProgress = Math.min(1, elapsed / FADE_DURATION);\n            m.material.opacity = fadeProgress; // Smooth in\n            // Decorations fade with terrain\n            m.children.forEach((child)=>{\n                if (child.material && child.material.transparent) {\n                    child.material.opacity = fadeProgress * (0.15 + envCache.windStrength * 0.03);\n                }\n            });\n        }\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            clock.start(); // Tick clock\n            // Dynamic radius tweak for env\n            const effectiveRadius = Math.max(3, ACTIVE_RADIUS - envCache.windStrength * 0.3);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            for(let dz = -effectiveRadius; dz <= effectiveRadius; dz++){\n                for(let dx = -effectiveRadius; dx <= effectiveRadius; dx++){\n                    ensure(cx + dx, cz + dz);\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                    m.userData.loadTime = clock.getElapsedTime(); // Reset fade on redecorate\n                }\n                environmentDirty = false;\n            }\n            updateFades(); // Smooth transitions\n            // Animate wind: Slower for less flicker\n            for (const m of chunks.values()){\n                m.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh && child.userData.time !== undefined) {\n                        child.userData.time += dt * (0.5 + envCache.windStrength * 0.5); // Slower base\n                        child.material.opacity = 0.15 + Math.sin(child.userData.time) * 0.05 + envCache.windStrength * 0.03;\n                        child.rotation.y += dt * envCache.windStrength * 0.2; // Gentler sway\n                    }\n                });\n            }\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLFFBQVEsSUFBSSxzRUFBc0U7QUFDeEYsTUFBTUMsT0FBT0YsYUFBYTtBQUMxQixNQUFNRyxnQkFBZ0IsR0FBRywrQ0FBK0M7QUFFeEUsU0FBU0MsSUFBSUMsRUFBVSxFQUFFQyxFQUFVO0lBQUksT0FBTyxHQUFTQSxPQUFORCxJQUFHLEtBQU0sT0FBSEM7QUFBTTtBQUM3RCxTQUFTQyxRQUFRQyxDQUFTO0lBQUksT0FBT0MsS0FBS0MsS0FBSyxDQUFDRixJQUFJUjtBQUFhO0FBRWpFLElBQUlXLFdBQVdiLHNFQUFrQkEsR0FBR2MsV0FBVztBQUUvQyxpRUFBaUU7QUFDakUsTUFBTUMsa0JBQWtCO0lBQ3RCQyxTQUFTLElBQUluQix1REFBMEIsQ0FBQztRQUN0Q3FCLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO0lBRWI7SUFDQUMsTUFBTSxJQUFJeEIsdURBQTBCLENBQUM7UUFDbkNxQixPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsV0FBVztJQUNiO0lBQ0FFLE1BQU0sSUFBSXpCLHVEQUEwQixDQUFDO1FBQ25DcUIsT0FBTztRQUNQSyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsVUFBVTVCLG1EQUFzQjtRQUNoQzhCLFlBQVk7SUFDZDtBQUNGO0FBRUEsd0VBQXdFO0FBQ3hFLE1BQU1DLGdCQUFnQixLQUFLLHdCQUF3QjtBQUVuRCxTQUFTQyxXQUFXdEIsRUFBVSxFQUFFQyxFQUFVO0lBQ3hDLE1BQU1zQixJQUFJLElBQUlqQyxnREFBbUIsQ0FBQ0ssWUFBWUEsWUFBWUMsT0FBT0E7SUFDakUyQixFQUFFRSxPQUFPLENBQUMsQ0FBQ3JCLEtBQUtzQixFQUFFLEdBQUc7SUFFckIsTUFBTUMsTUFBTUosRUFBRUssVUFBVSxDQUFDQyxRQUFRO0lBQ2pDLElBQUss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eURBQVFBLENBQUNXLEdBQUd5RjtZQUN0QixPQUFPd0MsSUFBSXZGLEdBQUcsQ0FBQzZILEVBQUV2SyxDQUFDLEVBQUV1SyxFQUFFakYsQ0FBQyxFQUFFaUYsRUFBRTlFLENBQUM7UUFDOUI7UUFFQS9CO1lBQ0U0RSx3QkFBQUEsa0NBQUFBO1lBQ0EsS0FBSyxNQUFNUyxLQUFLaEIsT0FBT3lCLE1BQU0sR0FBSTtnQkFDL0JMLGFBQWFKO1lBQ2Y7WUFDQWhCLE9BQU95QyxLQUFLO1lBQ1pDLE9BQU9qQixNQUFNLENBQUNuSixpQkFBaUJ3SixPQUFPLENBQUM5RixDQUFBQTtnQkFDckMsSUFBSUYsTUFBTUMsT0FBTyxDQUFDQyxNQUFNO29CQUN0QkEsSUFBSThGLE9BQU8sQ0FBQ2QsQ0FBQUEsSUFBS0EsRUFBRXJGLE9BQU87Z0JBQzVCLE9BQU87b0JBQ0xLLElBQUlMLE9BQU87Z0JBQ2I7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2FwcC9zcmMvd29ybGQvY2h1bmtzL3N0cmVhbWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGhlaWdodEF0LCBub3JtYWxBdCB9IGZyb20gJy4vZ2VuZXJhdGVIZWlnaHQnO1xuaW1wb3J0IHsgZ2V0RGlmZmljdWx0eVN0YXRlLCBvbkRpZmZpY3VsdHlDaGFuZ2UgfSBmcm9tICdAL2VuZ2luZS9kaWZmaWN1bHR5JztcblxuY29uc3QgQ0hVTktfU0laRSA9IDEyODtcbmNvbnN0IFZFUlRTID0gNDg7IC8vIEZpeGVkIG1lZGl1bSBkZXRhaWwgdG8gYXZvaWQgTE9EIHBvcC9mbGlja2VyOyBiYWxhbmNlIHBlcmYgJiBzbW9vdGhcbmNvbnN0IEhBTEYgPSBDSFVOS19TSVpFIC8gMjtcbmNvbnN0IEFDVElWRV9SQURJVVMgPSA0OyAvLyBJbmNyZWFzZWQgZm9yIGJldHRlciBwcmVsb2FkaW5nLCBsZXNzIHBvcC1pblxuXG5mdW5jdGlvbiBrZXkoaXg6IG51bWJlciwgaXo6IG51bWJlcikgeyByZXR1cm4gYCR7aXh9LCR7aXp9YDsgfVxuZnVuY3Rpb24gdG9DaHVuayh4OiBudW1iZXIpIHsgcmV0dXJuIE1hdGguZmxvb3IoeCAvIENIVU5LX1NJWkUpOyB9XG5cbmxldCBlbnZDYWNoZSA9IGdldERpZmZpY3VsdHlTdGF0ZSgpLmVudmlyb25tZW50O1xuXG4vLyBTaGFyZWQgbWF0ZXJpYWxzIGZvciBlZmZpY2llbmN5IChkaXNwb3NlIG9uIHN0cmVhbWVyIHRlYXJkb3duKVxuY29uc3Qgc2hhcmVkTWF0ZXJpYWxzID0ge1xuICB0ZXJyYWluOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDUwNmE1MixcbiAgICByb3VnaG5lc3M6IDAuOTUsXG4gICAgbWV0YWxuZXNzOiAwLjAsXG4gICAgLy8gT3B0aW9uYWw6IEFkZCBtYXAvdGV4dHVyZSBpZiBhdmFpbGFibGU6IG1hcDogdGVycmFpblRleHR1cmUsXG4gIH0pLFxuICByb2NrOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDRhNGY0NCxcbiAgICByb3VnaG5lc3M6IDAuOCxcbiAgICBtZXRhbG5lc3M6IDAuMSxcbiAgfSksXG4gIHdpbmQ6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4ODhjY2ZmLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIG9wYWNpdHk6IDAuMTgsXG4gICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsIC8vIEV0aGVyZWFsIGdsb3dcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgfSksXG59O1xuXG4vLyBHbG9iYWwgZmFkZSBoZWxwZXIgZm9yIGNodW5rcyAocHJldmVudHMgXCJuZW9uXCIgZmxpY2tlciBvbiBsb2FkL3BydW5lKVxuY29uc3QgRkFERV9EVVJBVElPTiA9IDAuNTsgLy8gU2VjIGZvciBzbW9vdGggaW4vb3V0XG5cbmZ1bmN0aW9uIGJ1aWxkQ2h1bmsoaXg6IG51bWJlciwgaXo6IG51bWJlcikge1xuICBjb25zdCBnID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ0hVTktfU0laRSwgQ0hVTktfU0laRSwgVkVSVFMsIFZFUlRTKTtcbiAgZy5yb3RhdGVYKC1NYXRoLlBJIC8gMik7XG5cbiAgY29uc3QgcG9zID0gZy5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHZ4ID0gcG9zLmdldFgoaSkgKyBpeCAqIENIVU5LX1NJWkU7XG4gICAgY29uc3QgdnogPSBwb3MuZ2V0WihpKSArIGl6ICogQ0hVTktfU0laRTtcbiAgICBjb25zdCBoID0gaGVpZ2h0QXQodngsIHZ6KTtcbiAgICBwb3Muc2V0WShpLCBoKTtcbiAgfVxuICBwb3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy8gT3B0aW9uYWw6IFVWIHNjYWxpbmcgZm9yIHRleHR1cmUgdGlsaW5nXG4gIGNvbnN0IHV2ID0gZy5hdHRyaWJ1dGVzLnV2IGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1di5jb3VudDsgaSsrKSB7XG4gICAgdXYuc2V0WFkoaSwgdXYuZ2V0WChpKSAqIDQsIHV2LmdldFkoaSkgKiA0KTsgLy8gVGlsZSA0eFxuICB9XG4gIHV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZywgc2hhcmVkTWF0ZXJpYWxzLnRlcnJhaW4pO1xuICBtZXNoLnBvc2l0aW9uLnNldChpeCAqIENIVU5LX1NJWkUsIDAsIGl6ICogQ0hVTktfU0laRSk7XG4gIG1lc2gucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gIG1lc2guY2FzdFNoYWRvdyA9IGZhbHNlO1xuICBtZXNoLnVzZXJEYXRhID0ge1xuICAgIGl4LFxuICAgIGl6LFxuICAgIGxvYWRUaW1lOiAwLCAvLyBGb3IgZmFkZS1pbiB0cmFja2luZ1xuICAgIGRlY29yYXRpb25zOiBbXSBhcyBUSFJFRS5PYmplY3QzRFtdLFxuICAgIGluc3RhbmNlQ291bnRzOiB7IHJvY2tzOiAwLCB3aW5kczogMCB9LFxuICB9O1xuICBtZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTsgLy8gRW5hYmxlIGZvciBmYWRlXG4gIG1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IDA7IC8vIFN0YXJ0IGludmlzaWJsZSwgZmFkZSBpblxuXG4gIGRlY29yYXRlQ2h1bmsobWVzaCk7XG4gIHJldHVybiBtZXNoO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZUNodW5rKG1lc2g6IFRIUkVFLk1lc2gpIHtcbiAgLy8gMS4gQ2xlYXIgZXhpc3RpbmcgZGVjb3JhdGlvbnMgd2l0aCBkaXNwb3NhbC5cbiAgY29uc3QgcHJldmlvdXMgPSBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID8/IFtdO1xuICBmb3IgKGNvbnN0IG9iaiBvZiBwcmV2aW91cykge1xuICAgIG1lc2gucmVtb3ZlKG9iaik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZE1lc2gpIHtcbiAgICAgIG9iai5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICBvYmouZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmoudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjaGlsZC5tYXRlcmlhbDtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLmRpc3Bvc2U/LigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPSBbXTtcblxuICBjb25zdCB7IHByb3BEZW5zaXR5LCB3aW5kU3RyZW5ndGggfSA9IGVudkNhY2hlO1xuICBjb25zdCBwcm9wQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHByb3BEZW5zaXR5ICogMTYpKTtcbiAgY29uc3Qgd2luZENvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZCh3aW5kU3RyZW5ndGggKiAyKSk7XG5cbiAgLy8gUm9ja3M6IEluc3RhbmNlZCBmb3IgcGVyZlxuICBpZiAocHJvcENvdW50ID4gMCkge1xuICAgIGNvbnN0IHJvY2tHZW8gPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSgxLjUgKyBNYXRoLnJhbmRvbSgpICogMi41LCAxKTtcbiAgICBjb25zdCByb2NrSW5zdGFuY2VzID0gbmV3IFRIUkVFLkluc3RhbmNlZE1lc2gocm9ja0dlbywgc2hhcmVkTWF0ZXJpYWxzLnJvY2ssIHByb3BDb3VudCk7XG4gICAgY29uc3Qgcm9ja01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgY29uc3QgdG1wUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0bXBRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICBjb25zdCB0bXBTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBsb2NhbFggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBDSFVOS19TSVpFO1xuICAgICAgY29uc3QgbG9jYWxaID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRTtcbiAgICAgIGNvbnN0IHdvcmxkWCA9IG1lc2gudXNlckRhdGEuaXggKiBDSFVOS19TSVpFICsgbG9jYWxYO1xuICAgICAgY29uc3Qgd29ybGRaID0gbWVzaC51c2VyRGF0YS5peiAqIENIVU5LX1NJWkUgKyBsb2NhbFo7XG4gICAgICBjb25zdCBiYXNlSGVpZ2h0ID0gaGVpZ2h0QXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3QgeSA9IGJhc2VIZWlnaHQgLSBtZXNoLnBvc2l0aW9uLnkgKyAxICsgTWF0aC5yYW5kb20oKSAqIDAuNTtcbiAgICAgIHRtcFBvcy5zZXQobG9jYWxYLCB5LCBsb2NhbFopO1xuXG4gICAgICAvLyBOb3JtYWwgYWxpZ25tZW50XG4gICAgICBjb25zdCBub3JtID0gbm9ybWFsQXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3Qgbm9ybWFsVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMobm9ybS54LCBub3JtLnksIG5vcm0ueikubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnRRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMobmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksIG5vcm1hbFZlYyk7XG5cbiAgICAgIC8vIFJhbmRvbSByb3RhdGlvblxuICAgICAgY29uc3QgcmFuZG9tRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMiwgJ1hZWicpO1xuICAgICAgY29uc3QgcmFuZG9tUXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKHJhbmRvbUV1bGVyKTtcbiAgICAgIHRtcFF1YXQuY29weShhbGlnbm1lbnRRdWF0KS5tdWx0aXBseShyYW5kb21RdWF0KTtcblxuICAgICAgLy8gU2NhbGVcbiAgICAgIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDtcbiAgICAgIHRtcFNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcblxuICAgICAgcm9ja01hdHJpeC5jb21wb3NlKHRtcFBvcywgdG1wUXVhdCwgdG1wU2NhbGUpO1xuICAgICAgcm9ja0luc3RhbmNlcy5zZXRNYXRyaXhBdChpLCByb2NrTWF0cml4KTtcbiAgICB9XG4gICAgcm9ja0luc3RhbmNlcy5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcm9ja0luc3RhbmNlcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICByb2NrSW5zdGFuY2VzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcbiAgICBtZXNoLmFkZChyb2NrSW5zdGFuY2VzKTtcbiAgICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zLnB1c2gocm9ja0luc3RhbmNlcyk7XG4gICAgbWVzaC51c2VyRGF0YS5pbnN0YW5jZUNvdW50cy5yb2NrcyA9IHByb3BDb3VudDtcbiAgfVxuXG4gIC8vIFdpbmQgY29sdW1uczogU2xvd2VyIHB1bHNlIHRvIGF2b2lkIG5lb24gZmxpY2tlclxuICBpZiAod2luZENvdW50ID4gMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IDIgKyB3aW5kU3RyZW5ndGggKiAyO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gNjAgKyB3aW5kU3RyZW5ndGggKiAyMDtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gMTY7XG4gICAgICBjb25zdCB3aW5kR2VvID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkocmFkaXVzLCByYWRpdXMgKiAwLjYsIGhlaWdodCwgc2VnbWVudHMsIDQsIHRydWUpO1xuICAgICAgd2luZEdlby5yb3RhdGVYKE1hdGguUEkgLyAyKTtcblxuICAgICAgLy8gVHdpc3QgZm9yIHZvcnRleFxuICAgICAgY29uc3QgcG9zID0gd2luZEdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9zLmNvdW50OyBqKyspIHtcbiAgICAgICAgY29uc3QgeSA9IHBvcy5nZXRZKGopO1xuICAgICAgICBjb25zdCB0d2lzdEFuZ2xlID0gKHkgLyBoZWlnaHQpICogTWF0aC5QSSAqIDQgKiB3aW5kU3RyZW5ndGg7XG4gICAgICAgIGNvbnN0IHggPSBwb3MuZ2V0WChqKTtcbiAgICAgICAgY29uc3QgeiA9IHBvcy5nZXRaKGopO1xuICAgICAgICBwb3Muc2V0WChqLCB4ICogTWF0aC5jb3ModHdpc3RBbmdsZSkgLSB6ICogTWF0aC5zaW4odHdpc3RBbmdsZSkpO1xuICAgICAgICBwb3Muc2V0WihqLCB4ICogTWF0aC5zaW4odHdpc3RBbmdsZSkgKyB6ICogTWF0aC5jb3ModHdpc3RBbmdsZSkpO1xuICAgICAgfVxuICAgICAgcG9zLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHdpbmRHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgICAgY29uc3QgY29sdW1uID0gbmV3IFRIUkVFLk1lc2god2luZEdlbywgc2hhcmVkTWF0ZXJpYWxzLndpbmQpO1xuICAgICAgY29uc3QgbG9jYWxYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRSAqIDAuODtcbiAgICAgIGNvbnN0IGxvY2FsWiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIENIVU5LX1NJWkUgKiAwLjg7XG4gICAgICBjb2x1bW4ucG9zaXRpb24uc2V0KGxvY2FsWCwgaGVpZ2h0IC8gMiwgbG9jYWxaKTtcbiAgICAgIGNvbHVtbi51c2VyRGF0YSA9IHsgdGltZTogTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyIH07XG5cbiAgICAgIC8vIFN0YXJ0IHdpdGggYmFzZSBvcGFjaXR5LCBubyBpbml0aWFsIGZsaWNrZXJcbiAgICAgIGNvbHVtbi5tYXRlcmlhbC5vcGFjaXR5ID0gMC4xNSArIHdpbmRTdHJlbmd0aCAqIDAuMDM7XG5cbiAgICAgIG1lc2guYWRkKGNvbHVtbik7XG4gICAgICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zLnB1c2goY29sdW1uKTtcbiAgICB9XG4gIH1cblxuICAvLyBGb2cgcGxhbmU6IFN0YXRpYywgbG93IG9wYWNpdHkgdG8gYXZvaWQgZmxpY2tlclxuICBjb25zdCBmb2dHZW8gPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShDSFVOS19TSVpFICogMS4yLCBDSFVOS19TSVpFICogMS4yLCAxLCAxKTtcbiAgY29uc3QgZm9nTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBjb2xvcjogMHg4OGNjZmYsXG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgb3BhY2l0eTogMC4wNSArIHdpbmRTdHJlbmd0aCAqIDAuMDUsIC8vIExvd2VyIHB1bHNlIHRpZS1pblxuICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXG4gIH0pO1xuICBjb25zdCBmb2cgPSBuZXcgVEhSRUUuTWVzaChmb2dHZW8sIGZvZ01hdCk7XG4gIGZvZy5wb3NpdGlvbi5zZXQoMCwgMjAsIDApO1xuICBmb2cucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgbWVzaC5hZGQoZm9nKTtcbiAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucy5wdXNoKGZvZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1lcihzY2VuZTogVEhSRUUuU2NlbmUpIHtcbiAgY29uc3QgY2h1bmtzID0gbmV3IE1hcDxzdHJpbmcsIFRIUkVFLk1lc2g+KCk7XG4gIGNvbnN0IHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGxldCBlbnZpcm9ubWVudERpcnR5ID0gZmFsc2U7XG4gIGxldCBhbmltYXRpb25UaW1lID0gMDtcbiAgY29uc3QgY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTsgLy8gRm9yIGZhZGUgdGltaW5nXG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBvbkRpZmZpY3VsdHlDaGFuZ2UoKHN0YXRlKSA9PiB7XG4gICAgZW52Q2FjaGUgPSBzdGF0ZS5lbnZpcm9ubWVudDtcbiAgICBlbnZpcm9ubWVudERpcnR5ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5zdXJlKGl4OiBudW1iZXIsIGl6OiBudW1iZXIpIHtcbiAgICBjb25zdCBrID0ga2V5KGl4LCBpeik7XG4gICAgaWYgKGNodW5rcy5oYXMoaykpIHJldHVybjtcblxuICAgIGNvbnN0IG1lc2ggPSBidWlsZENodW5rKGl4LCBpeik7XG4gICAgbWVzaC51c2VyRGF0YS5sb2FkVGltZSA9IGNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgY2h1bmtzLnNldChrLCBtZXNoKTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZShjZW50ZXJYOiBudW1iZXIsIGNlbnRlclo6IG51bWJlcikge1xuICAgIGZvciAoY29uc3QgW2ssIG1dIG9mIGNodW5rcykge1xuICAgICAgY29uc3QgZHggPSB0b0NodW5rKGNlbnRlclgpIC0gbS51c2VyRGF0YS5peDtcbiAgICAgIGNvbnN0IGR6ID0gdG9DaHVuayhjZW50ZXJaKSAtIG0udXNlckRhdGEuaXo7XG4gICAgICBpZiAoTWF0aC5hYnMoZHgpID4gQUNUSVZFX1JBRElVUyB8fCBNYXRoLmFicyhkeikgPiBBQ1RJVkVfUkFESVVTKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0IGJlZm9yZSByZW1vdmVcbiAgICAgICAgbS5tYXRlcmlhbC5vcGFjaXR5ID0gMDtcbiAgICAgICAgc2NlbmUucmVtb3ZlKG0pO1xuICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICAgIGNodW5rcy5kZWxldGUoayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcG9zZUNodW5rKG1lc2g6IFRIUkVFLk1lc2gpIHtcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBjb25zdCBkZWNvcmF0aW9ucyA9IG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPz8gW107XG4gICAgZm9yIChjb25zdCBkZWNvIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgZGVjby5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIGRlY28uZGlzcG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjby50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZhZGUgdXBkYXRlIGhlbHBlclxuICBmdW5jdGlvbiB1cGRhdGVGYWRlcygpIHtcbiAgICBjb25zdCBub3cgPSBjbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSAobS51c2VyRGF0YS5sb2FkVGltZSBhcyBudW1iZXIpO1xuICAgICAgY29uc3QgZmFkZVByb2dyZXNzID0gTWF0aC5taW4oMSwgZWxhcHNlZCAvIEZBREVfRFVSQVRJT04pO1xuICAgICAgbS5tYXRlcmlhbC5vcGFjaXR5ID0gZmFkZVByb2dyZXNzOyAvLyBTbW9vdGggaW5cblxuICAgICAgLy8gRGVjb3JhdGlvbnMgZmFkZSB3aXRoIHRlcnJhaW5cbiAgICAgIG0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5tYXRlcmlhbCAmJiAoY2hpbGQubWF0ZXJpYWwgYXMgYW55KS50cmFuc3BhcmVudCkge1xuICAgICAgICAgIChjaGlsZC5tYXRlcmlhbCBhcyBhbnkpLm9wYWNpdHkgPSBmYWRlUHJvZ3Jlc3MgKiAoMC4xNSArIGVudkNhY2hlLndpbmRTdHJlbmd0aCAqIDAuMDMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZShwb3M6IFRIUkVFLlZlY3RvcjMsIGR0OiBudW1iZXIpIHtcbiAgICAgIGFuaW1hdGlvblRpbWUgKz0gZHQ7XG4gICAgICBjbG9jay5zdGFydCgpOyAvLyBUaWNrIGNsb2NrXG5cbiAgICAgIC8vIER5bmFtaWMgcmFkaXVzIHR3ZWFrIGZvciBlbnZcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVJhZGl1cyA9IE1hdGgubWF4KDMsIEFDVElWRV9SQURJVVMgLSBlbnZDYWNoZS53aW5kU3RyZW5ndGggKiAwLjMpO1xuXG4gICAgICBjb25zdCBjeCA9IHRvQ2h1bmsocG9zLngpO1xuICAgICAgY29uc3QgY3ogPSB0b0NodW5rKHBvcy56KTtcblxuICAgICAgZm9yIChsZXQgZHogPSAtZWZmZWN0aXZlUmFkaXVzOyBkeiA8PSBlZmZlY3RpdmVSYWRpdXM7IGR6KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtZWZmZWN0aXZlUmFkaXVzOyBkeCA8PSBlZmZlY3RpdmVSYWRpdXM7IGR4KyspIHtcbiAgICAgICAgICBlbnN1cmUoY3ggKyBkeCwgY3ogKyBkeik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJ1bmUocG9zLngsIHBvcy56KTtcblxuICAgICAgaWYgKGVudmlyb25tZW50RGlydHkpIHtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICAgIGRlY29yYXRlQ2h1bmsobSk7XG4gICAgICAgICAgbS51c2VyRGF0YS5sb2FkVGltZSA9IGNsb2NrLmdldEVsYXBzZWRUaW1lKCk7IC8vIFJlc2V0IGZhZGUgb24gcmVkZWNvcmF0ZVxuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50RGlydHkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlRmFkZXMoKTsgLy8gU21vb3RoIHRyYW5zaXRpb25zXG5cbiAgICAgIC8vIEFuaW1hdGUgd2luZDogU2xvd2VyIGZvciBsZXNzIGZsaWNrZXJcbiAgICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIHtcbiAgICAgICAgbS50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICYmIChjaGlsZC51c2VyRGF0YSBhcyBhbnkpLnRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKGNoaWxkLnVzZXJEYXRhIGFzIGFueSkudGltZSArPSBkdCAqICgwLjUgKyBlbnZDYWNoZS53aW5kU3RyZW5ndGggKiAwLjUpOyAvLyBTbG93ZXIgYmFzZVxuICAgICAgICAgICAgKGNoaWxkLm1hdGVyaWFsIGFzIGFueSkub3BhY2l0eSA9IDAuMTUgKyBNYXRoLnNpbigoY2hpbGQudXNlckRhdGEgYXMgYW55KS50aW1lKSAqIDAuMDUgKyBlbnZDYWNoZS53aW5kU3RyZW5ndGggKiAwLjAzO1xuICAgICAgICAgICAgY2hpbGQucm90YXRpb24ueSArPSBkdCAqIGVudkNhY2hlLndpbmRTdHJlbmd0aCAqIDAuMjsgLy8gR2VudGxlciBzd2F5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcXVlcnlIZWlnaHQoeDogbnVtYmVyLCB6OiBudW1iZXIpIHtcbiAgICAgIHJldHVybiBoZWlnaHRBdCh4LCB6KTtcbiAgICB9LFxuXG4gICAgcXVlcnlOb3JtYWwoeDogbnVtYmVyLCB6OiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IG4gPSBub3JtYWxBdCh4LCB6KTtcbiAgICAgIHJldHVybiB0bXAuc2V0KG4ueCwgbi55LCBuLnopO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdW5zdWJzY3JpYmU/LigpO1xuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICBkaXNwb3NlQ2h1bmsobSk7XG4gICAgICB9XG4gICAgICBjaHVua3MuY2xlYXIoKTtcbiAgICAgIE9iamVjdC52YWx1ZXMoc2hhcmVkTWF0ZXJpYWxzKS5mb3JFYWNoKG1hdCA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdCkpIHtcbiAgICAgICAgICBtYXQuZm9yRWFjaChtID0+IG0uZGlzcG9zZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSJdLCJuYW1lcyI6WyJUSFJFRSIsImhlaWdodEF0Iiwibm9ybWFsQXQiLCJnZXREaWZmaWN1bHR5U3RhdGUiLCJvbkRpZmZpY3VsdHlDaGFuZ2UiLCJDSFVOS19TSVpFIiwiVkVSVFMiLCJIQUxGIiwiQUNUSVZFX1JBRElVUyIsImtleSIsIml4IiwiaXoiLCJ0b0NodW5rIiwieCIsIk1hdGgiLCJmbG9vciIsImVudkNhY2hlIiwiZW52aXJvbm1lbnQiLCJzaGFyZWRNYXRlcmlhbHMiLCJ0ZXJyYWluIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJjb2xvciIsInJvdWdobmVzcyIsIm1ldGFsbmVzcyIsInJvY2siLCJ3aW5kIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsIkZBREVfRFVSQVRJT04iLCJidWlsZENodW5rIiwiZyIsIlBsYW5lR2VvbWV0cnkiLCJyb3RhdGVYIiwiUEkiLCJwb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJpIiwiY291bnQiLCJ2eCIsImdldFgiLCJ2eiIsImdldFoiLCJoIiwic2V0WSIsIm5lZWRzVXBkYXRlIiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJ1diIsInNldFhZIiwiZ2V0WSIsIm1lc2giLCJNZXNoIiwic2V0IiwicmVjZWl2ZVNoYWRvdyIsImNhc3RTaGFkb3ciLCJ1c2VyRGF0YSIsImxvYWRUaW1lIiwiZGVjb3JhdGlvbnMiLCJpbnN0YW5jZUNvdW50cyIsInJvY2tzIiwid2luZHMiLCJtYXRlcmlhbCIsImRlY29yYXRlQ2h1bmsiLCJwcmV2aW91cyIsIm9iaiIsInJlbW92ZSIsIkluc3RhbmNlZE1lc2giLCJnZW9tZXRyeSIsImRpc3Bvc2UiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiQXJyYXkiLCJpc0FycmF5IiwibWF0IiwicHJvcERlbnNpdHkiLCJ3aW5kU3RyZW5ndGgiLCJwcm9wQ291bnQiLCJtYXgiLCJyb3VuZCIsIndpbmRDb3VudCIsInJvY2tHZW8iLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwicmFuZG9tIiwicm9ja0luc3RhbmNlcyIsInJvY2tNYXRyaXgiLCJNYXRyaXg0IiwidG1wUG9zIiwiVmVjdG9yMyIsInRtcFF1YXQiLCJRdWF0ZXJuaW9uIiwidG1wU2NhbGUiLCJsb2NhbFgiLCJsb2NhbFoiLCJ3b3JsZFgiLCJ3b3JsZFoiLCJiYXNlSGVpZ2h0IiwieSIsIm5vcm0iLCJub3JtYWxWZWMiLCJ6Iiwibm9ybWFsaXplIiwiYWxpZ25tZW50UXVhdCIsInNldEZyb21Vbml0VmVjdG9ycyIsInJhbmRvbUV1bGVyIiwiRXVsZXIiLCJyYW5kb21RdWF0Iiwic2V0RnJvbUV1bGVyIiwiY29weSIsIm11bHRpcGx5Iiwic2NhbGUiLCJjb21wb3NlIiwic2V0TWF0cml4QXQiLCJpbnN0YW5jZU1hdHJpeCIsImFkZCIsInB1c2giLCJyYWRpdXMiLCJoZWlnaHQiLCJzZWdtZW50cyIsIndpbmRHZW8iLCJDeWxpbmRlckdlb21ldHJ5IiwiaiIsInR3aXN0QW5nbGUiLCJzZXRYIiwiY29zIiwic2luIiwic2V0WiIsImNvbHVtbiIsInRpbWUiLCJmb2dHZW8iLCJmb2dNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNpZGUiLCJEb3VibGVTaWRlIiwiZm9nIiwicm90YXRpb24iLCJjcmVhdGVTdHJlYW1lciIsInNjZW5lIiwiY2h1bmtzIiwiTWFwIiwidG1wIiwiZW52aXJvbm1lbnREaXJ0eSIsImFuaW1hdGlvblRpbWUiLCJjbG9jayIsIkNsb2NrIiwidW5zdWJzY3JpYmUiLCJzdGF0ZSIsImVuc3VyZSIsImsiLCJoYXMiLCJnZXRFbGFwc2VkVGltZSIsInBydW5lIiwiY2VudGVyWCIsImNlbnRlcloiLCJtIiwiZHgiLCJkeiIsImFicyIsImRpc3Bvc2VDaHVuayIsImRlbGV0ZSIsImRlY28iLCJ1cGRhdGVGYWRlcyIsIm5vdyIsInZhbHVlcyIsImVsYXBzZWQiLCJmYWRlUHJvZ3Jlc3MiLCJtaW4iLCJjaGlsZHJlbiIsImZvckVhY2giLCJ1cGRhdGUiLCJkdCIsInN0YXJ0IiwiZWZmZWN0aXZlUmFkaXVzIiwiY3giLCJjeiIsInVuZGVmaW5lZCIsInF1ZXJ5SGVpZ2h0IiwicXVlcnlOb3JtYWwiLCJuIiwiY2xlYXIiLCJPYmplY3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});