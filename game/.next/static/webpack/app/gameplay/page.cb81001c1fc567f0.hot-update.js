"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n\n\n\nconst CHUNK_SIZE = 512;\nconst VERTS_NEAR = 64; // High detail for close chunks\nconst VERTS_FAR = 32; // Low detail for distant chunks\nconst HALF = CHUNK_SIZE / 2;\nconst ACTIVE_RADIUS_NEAR = 2; // High-detail ring\nconst ACTIVE_RADIUS_FAR = 4; // Low-detail outer ring\nfunction key(ix, iz) {\n    return \"\".concat(ix, \",\").concat(iz);\n}\nfunction toChunk(x) {\n    return Math.floor(x / CHUNK_SIZE);\n}\nlet envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Shared materials for efficiency (dispose on streamer teardown)\nconst sharedMaterials = {\n    terrain: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0.0\n    }),\n    rock: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    }),\n    wind: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.18,\n        blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending,\n        depthWrite: false\n    })\n};\nfunction buildChunk(ix, iz, detailLevel) {\n    const verts = detailLevel === 'near' ? VERTS_NEAR : VERTS_FAR;\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, verts, verts);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        const h = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz);\n        pos.setY(i, h);\n    }\n    pos.needsUpdate = true;\n    g.computeVertexNormals();\n    // Optional: UV scaling or noise for texture tiling\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * 4, uv.getY(i) * 4); // Tile texture 4x for variety\n    }\n    uv.needsUpdate = true;\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(g, sharedMaterials.terrain);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.castShadow = false; // Terrain doesn't cast\n    mesh.userData = {\n        ix,\n        iz,\n        detailLevel,\n        decorations: [],\n        instanceCounts: {\n            rocks: 0,\n            winds: 0\n        }\n    };\n    decorateChunk(mesh);\n    return mesh;\n}\nfunction decorateChunk(mesh) {\n    var _mesh_userData_decorations;\n    // 1. Clear existing decorations idempotently with proper disposal.\n    const previous = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n    for (const obj of previous){\n        mesh.remove(obj);\n        obj.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                child.geometry.dispose();\n                const material = child.material;\n                if (Array.isArray(material)) {\n                    var _mat_dispose;\n                    for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                } else {\n                    var _material_dispose;\n                    (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                }\n            }\n        });\n    }\n    mesh.userData.decorations = [];\n    const { propDensity, windStrength } = envCache;\n    const propCount = Math.max(0, Math.round(propDensity * 16)); // Increased density for richness\n    const windCount = Math.max(1, Math.round(windStrength * 2)); // Scaled to strength\n    // Rocks: Use InstancedMesh for batching (perf win for many props)\n    if (propCount > 0) {\n        const rockGeo = new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(1.5 + Math.random() * 2.5, 1); // Slight detail\n        const rockInstances = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(rockGeo, sharedMaterials.rock, propCount);\n        const rockMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        const tmpPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n        const tmpScale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        for(let i = 0; i < propCount; i++){\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE;\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE;\n            const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n            const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n            const baseHeight = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n            const y = baseHeight - mesh.position.y + 1 + Math.random() * 0.5; // Slight elevation var\n            tmpPos.set(localX, y, localZ);\n            // Alignment quaternion (up vector to normal)\n            const norm = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n            const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            const normalVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(norm.x, norm.y, norm.z).normalize();\n            const alignmentQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, normalVec);\n            // Random rotation quaternion (on top of alignment)\n            const randomEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, 'XYZ');\n            const randomQuat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromEuler(randomEuler);\n            tmpQuat.copy(alignmentQuat).multiply(randomQuat);\n            // Scale\n            const scale = 0.8 + Math.random() * 0.4;\n            tmpScale.set(scale, scale, scale);\n            // Compose matrix\n            rockMatrix.compose(tmpPos, tmpQuat, tmpScale);\n            rockInstances.setMatrixAt(i, rockMatrix);\n        }\n        rockInstances.instanceMatrix.needsUpdate = true;\n        rockInstances.castShadow = true;\n        rockInstances.receiveShadow = false;\n        mesh.add(rockInstances);\n        mesh.userData.decorations.push(rockInstances);\n        mesh.userData.instanceCounts.rocks = propCount;\n    }\n    // Wind columns: Animated, semi-transparent funnels with particle-like twist\n    if (windCount > 0) {\n        for(let i = 0; i < windCount; i++){\n            const radius = 2 + windStrength * 2;\n            const height = 60 + windStrength * 20;\n            const segments = 16; // Smoother curve\n            const windGeo = new three__WEBPACK_IMPORTED_MODULE_2__.CylinderGeometry(radius, radius * 0.6, height, segments, 4, true); // Tapered, open\n            windGeo.rotateX(Math.PI / 2);\n            // Twist geometry for vortex effect\n            const pos = windGeo.attributes.position;\n            for(let j = 0; j < pos.count; j++){\n                const y = pos.getY(j);\n                const twistAngle = y / height * Math.PI * 4 * windStrength;\n                const x = pos.getX(j);\n                const z = pos.getZ(j);\n                pos.setX(j, x * Math.cos(twistAngle) - z * Math.sin(twistAngle));\n                pos.setZ(j, x * Math.sin(twistAngle) + z * Math.cos(twistAngle));\n            }\n            pos.needsUpdate = true;\n            windGeo.computeVertexNormals();\n            const column = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(windGeo, sharedMaterials.wind);\n            const localX = (Math.random() - 0.5) * CHUNK_SIZE * 0.8; // Avoid edges\n            const localZ = (Math.random() - 0.5) * CHUNK_SIZE * 0.8;\n            column.position.set(localX, height / 2, localZ);\n            column.userData = {\n                time: Math.random() * Math.PI * 2\n            }; // For animation offset\n            mesh.add(column);\n            mesh.userData.decorations.push(column);\n        }\n    }\n    // Add subtle fog plane for atmospheric depth (per chunk, low poly)\n    const fogGeo = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE * 1.2, CHUNK_SIZE * 1.2, 1, 1);\n    const fogMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n        color: 0x88ccff,\n        transparent: true,\n        opacity: 0.05 + windStrength * 0.1,\n        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n    });\n    const fog = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(fogGeo, fogMat);\n    fog.position.set(0, 20, 0);\n    fog.rotation.x = -Math.PI / 2;\n    mesh.add(fog);\n    mesh.userData.decorations.push(fog);\n}\nfunction createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    let environmentDirty = false;\n    let animationTime = 0; // For wind animation\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        // 1. Mark dirty on env change; rebuild decorations next update.\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    function ensure(ix, iz, detailLevel) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) {\n            // Upgrade/downgrade detail if needed\n            const existing = chunks.get(k);\n            if (existing.userData.detailLevel !== detailLevel) {\n                scene.remove(existing);\n                disposeChunk(existing);\n                chunks.delete(k);\n            } else {\n                return;\n            }\n        }\n        const mesh = buildChunk(ix, iz, detailLevel);\n        chunks.set(k, mesh);\n        scene.add(mesh);\n    }\n    function prune(centerX, centerZ) {\n        for (const [k, m] of chunks){\n            const dx = toChunk(centerX) - m.userData.ix;\n            const dz = toChunk(centerZ) - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > ACTIVE_RADIUS_FAR) {\n                scene.remove(m);\n                disposeChunk(m);\n                chunks.delete(k);\n            }\n        }\n    }\n    function disposeChunk(mesh) {\n        // Comprehensive disposal: Geoms, mats (skip shared), instances\n        mesh.geometry.dispose();\n        var _mesh_userData_decorations;\n        const decorations = (_mesh_userData_decorations = mesh.userData.decorations) !== null && _mesh_userData_decorations !== void 0 ? _mesh_userData_decorations : [];\n        for (const deco of decorations){\n            mesh.remove(deco);\n            if (deco instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                deco.geometry.dispose();\n                deco.dispose(); // Releases instance buffer\n            } else {\n                deco.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n                        child.geometry.dispose();\n                        const material = child.material;\n                        if (Array.isArray(material)) {\n                            var _mat_dispose;\n                            for (const mat of material)(_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                        } else {\n                            var _material_dispose;\n                            (_material_dispose = material.dispose) === null || _material_dispose === void 0 ? void 0 : _material_dispose.call(material);\n                        }\n                    }\n                });\n            }\n        }\n    // Don't dispose shared materials here\n    }\n    return {\n        update (pos, dt) {\n            animationTime += dt;\n            // Dynamic radius based on envCache (e.g., denser fog = smaller radius)\n            const effectiveNear = Math.max(1, ACTIVE_RADIUS_NEAR - envCache.windStrength * 0.5);\n            const effectiveFar = Math.max(3, ACTIVE_RADIUS_FAR - envCache.propDensity * 0.2);\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // Ensure near chunks (high detail)\n            for(let dz = -effectiveNear; dz <= effectiveNear; dz++){\n                for(let dx = -effectiveNear; dx <= effectiveNear; dx++){\n                    ensure(cx + dx, cz + dz, 'near');\n                }\n            }\n            // Ensure far chunks (low detail)\n            for(let dz = -effectiveFar; dz <= effectiveFar; dz++){\n                for(let dx = -effectiveFar; dx <= effectiveFar; dx++){\n                    if (Math.max(Math.abs(dx), Math.abs(dz)) > effectiveNear) {\n                        ensure(cx + dx, cz + dz, 'far');\n                    }\n                }\n            }\n            prune(pos.x, pos.z);\n            if (environmentDirty) {\n                for (const m of chunks.values()){\n                    decorateChunk(m);\n                }\n                environmentDirty = false;\n            }\n            // Animate wind columns\n            for (const m of chunks.values()){\n                m.traverse((child)=>{\n                    if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh && child.userData.time !== undefined) {\n                        child.userData.time += dt * (1 + envCache.windStrength);\n                        child.material.opacity = 0.1 + Math.sin(child.userData.time * 2) * 0.1 + envCache.windStrength * 0.08;\n                        child.rotation.y += dt * envCache.windStrength * 0.5; // Gentle sway\n                    }\n                });\n            }\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            // 1. Cleanup: Unsub, prune all, dispose shared mats.\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values()){\n                disposeChunk(m);\n            }\n            chunks.clear();\n            // Dispose shared materials\n            Object.values(sharedMaterials).forEach((mat)=>{\n                if (Array.isArray(mat)) {\n                    mat.forEach((m)=>m.dispose());\n                } else {\n                    mat.dispose();\n                }\n            });\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUN1QjtBQUN1QjtBQUU3RSxNQUFNSyxhQUFhO0FBQ25CLE1BQU1DLGFBQWEsSUFBSSwrQkFBK0I7QUFDdEQsTUFBTUMsWUFBWSxJQUFJLGdDQUFnQztBQUN0RCxNQUFNQyxPQUFPSCxhQUFhO0FBQzFCLE1BQU1JLHFCQUFxQixHQUFHLG1CQUFtQjtBQUNqRCxNQUFNQyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFFckQsU0FBU0MsSUFBSUMsRUFBVSxFQUFFQyxFQUFVO0lBQUksT0FBTyxHQUFTQSxPQUFORCxJQUFHLEtBQU0sT0FBSEM7QUFBTTtBQUM3RCxTQUFTQyxRQUFRQyxDQUFTO0lBQUksT0FBT0MsS0FBS0MsS0FBSyxDQUFDRixJQUFJVjtBQUFhO0FBRWpFLElBQUlhLFdBQVdmLHNFQUFrQkEsR0FBR2dCLFdBQVc7QUFFL0MsaUVBQWlFO0FBQ2pFLE1BQU1DLGtCQUFrQjtJQUN0QkMsU0FBUyxJQUFJckIsdURBQTBCLENBQUM7UUFDdEN1QixPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsV0FBVztJQUViO0lBQ0FDLE1BQU0sSUFBSTFCLHVEQUEwQixDQUFDO1FBQ25DdUIsT0FBTztRQUNQQyxXQUFXO1FBQ1hDLFdBQVc7SUFDYjtJQUNBRSxNQUFNLElBQUkzQix1REFBMEIsQ0FBQztRQUNuQ3VCLE9BQU87UUFDUEssYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLFVBQVU5QixtREFBc0I7UUFDaENnQyxZQUFZO0lBQ2Q7QUFDRjtBQUVBLFNBQVNDLFdBQVdyQixFQUFVLEVBQUVDLEVBQVUsRUFBRXFCLFdBQTJCO0lBQ3JFLE1BQU1DLFFBQVFELGdCQUFnQixTQUFTNUIsYUFBYUM7SUFDcEQsTUFBTTZCLElBQUksSUFBSXBDLGdEQUFtQixDQUFDSyxZQUFZQSxZQUFZOEIsT0FBT0E7SUFDakVDLEVBQUVFLE9BQU8sQ0FBQyxDQUFDdEIs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QzlCO1FBRUFoQztZQUNFLHFEQUFxRDtZQUNyRDJFLHdCQUFBQSxrQ0FBQUE7WUFDQSxLQUFLLE1BQU1ZLEtBQUtqQixPQUFPNkIsTUFBTSxHQUFJO2dCQUMvQmpCLGFBQWFLO1lBQ2Y7WUFDQWpCLE9BQU9rQyxLQUFLO1lBRVosMkJBQTJCO1lBQzNCQyxPQUFPTixNQUFNLENBQUN4SixpQkFBaUIrSixPQUFPLENBQUN0RyxDQUFBQTtnQkFDckMsSUFBSUYsTUFBTUMsT0FBTyxDQUFDQyxNQUFNO29CQUN0QkEsSUFBSXNHLE9BQU8sQ0FBQ25CLENBQUFBLElBQUtBLEVBQUV2RixPQUFPO2dCQUM1QixPQUFPO29CQUNMSSxJQUFJSixPQUFPO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9hcHAvc3JjL3dvcmxkL2NodW5rcy9zdHJlYW1lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBoZWlnaHRBdCwgbm9ybWFsQXQgfSBmcm9tICcuL2dlbmVyYXRlSGVpZ2h0JztcbmltcG9ydCB7IGdldERpZmZpY3VsdHlTdGF0ZSwgb25EaWZmaWN1bHR5Q2hhbmdlIH0gZnJvbSAnQC9lbmdpbmUvZGlmZmljdWx0eSc7XG5cbmNvbnN0IENIVU5LX1NJWkUgPSA1MTI7XG5jb25zdCBWRVJUU19ORUFSID0gNjQ7IC8vIEhpZ2ggZGV0YWlsIGZvciBjbG9zZSBjaHVua3NcbmNvbnN0IFZFUlRTX0ZBUiA9IDMyOyAvLyBMb3cgZGV0YWlsIGZvciBkaXN0YW50IGNodW5rc1xuY29uc3QgSEFMRiA9IENIVU5LX1NJWkUgLyAyO1xuY29uc3QgQUNUSVZFX1JBRElVU19ORUFSID0gMjsgLy8gSGlnaC1kZXRhaWwgcmluZ1xuY29uc3QgQUNUSVZFX1JBRElVU19GQVIgPSA0OyAvLyBMb3ctZGV0YWlsIG91dGVyIHJpbmdcblxuZnVuY3Rpb24ga2V5KGl4OiBudW1iZXIsIGl6OiBudW1iZXIpIHsgcmV0dXJuIGAke2l4fSwke2l6fWA7IH1cbmZ1bmN0aW9uIHRvQ2h1bmsoeDogbnVtYmVyKSB7IHJldHVybiBNYXRoLmZsb29yKHggLyBDSFVOS19TSVpFKTsgfVxuXG5sZXQgZW52Q2FjaGUgPSBnZXREaWZmaWN1bHR5U3RhdGUoKS5lbnZpcm9ubWVudDtcblxuLy8gU2hhcmVkIG1hdGVyaWFscyBmb3IgZWZmaWNpZW5jeSAoZGlzcG9zZSBvbiBzdHJlYW1lciB0ZWFyZG93bilcbmNvbnN0IHNoYXJlZE1hdGVyaWFscyA9IHtcbiAgdGVycmFpbjogbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICBjb2xvcjogMHg1MDZhNTIsXG4gICAgcm91Z2huZXNzOiAwLjk1LFxuICAgIG1ldGFsbmVzczogMC4wLFxuICAgIC8vIE9wdGlvbmFsOiBBZGQgbWFwL3RleHR1cmUgaWYgYXZhaWxhYmxlOiBtYXA6IHRlcnJhaW5UZXh0dXJlLFxuICB9KSxcbiAgcm9jazogbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICBjb2xvcjogMHg0YTRmNDQsXG4gICAgcm91Z2huZXNzOiAwLjgsXG4gICAgbWV0YWxuZXNzOiAwLjEsXG4gIH0pLFxuICB3aW5kOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDg4Y2NmZixcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBvcGFjaXR5OiAwLjE4LFxuICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLCAvLyBFdGhlcmVhbCBnbG93XG4gICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gIH0pLFxufTtcblxuZnVuY3Rpb24gYnVpbGRDaHVuayhpeDogbnVtYmVyLCBpejogbnVtYmVyLCBkZXRhaWxMZXZlbDogJ25lYXInIHwgJ2ZhcicpIHtcbiAgY29uc3QgdmVydHMgPSBkZXRhaWxMZXZlbCA9PT0gJ25lYXInID8gVkVSVFNfTkVBUiA6IFZFUlRTX0ZBUjtcbiAgY29uc3QgZyA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KENIVU5LX1NJWkUsIENIVU5LX1NJWkUsIHZlcnRzLCB2ZXJ0cyk7XG4gIGcucm90YXRlWCgtTWF0aC5QSSAvIDIpO1xuXG4gIGNvbnN0IHBvcyA9IGcuYXR0cmlidXRlcy5wb3NpdGlvbiBhcyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zLmNvdW50OyBpKyspIHtcbiAgICBjb25zdCB2eCA9IHBvcy5nZXRYKGkpICsgaXggKiBDSFVOS19TSVpFO1xuICAgIGNvbnN0IHZ6ID0gcG9zLmdldFooaSkgKyBpeiAqIENIVU5LX1NJWkU7XG4gICAgY29uc3QgaCA9IGhlaWdodEF0KHZ4LCB2eik7XG4gICAgcG9zLnNldFkoaSwgaCk7XG4gIH1cbiAgcG9zLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgZy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gIC8vIE9wdGlvbmFsOiBVViBzY2FsaW5nIG9yIG5vaXNlIGZvciB0ZXh0dXJlIHRpbGluZ1xuICBjb25zdCB1diA9IGcuYXR0cmlidXRlcy51diBhcyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgIHV2LnNldFhZKGksIHV2LmdldFgoaSkgKiA0LCB1di5nZXRZKGkpICogNCk7IC8vIFRpbGUgdGV4dHVyZSA0eCBmb3IgdmFyaWV0eVxuICB9XG4gIHV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZywgc2hhcmVkTWF0ZXJpYWxzLnRlcnJhaW4pO1xuICBtZXNoLnBvc2l0aW9uLnNldChpeCAqIENIVU5LX1NJWkUsIDAsIGl6ICogQ0hVTktfU0laRSk7XG4gIG1lc2gucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gIG1lc2guY2FzdFNoYWRvdyA9IGZhbHNlOyAvLyBUZXJyYWluIGRvZXNuJ3QgY2FzdFxuICBtZXNoLnVzZXJEYXRhID0ge1xuICAgIGl4LFxuICAgIGl6LFxuICAgIGRldGFpbExldmVsLFxuICAgIGRlY29yYXRpb25zOiBbXSBhcyBUSFJFRS5PYmplY3QzRFtdLFxuICAgIGluc3RhbmNlQ291bnRzOiB7IHJvY2tzOiAwLCB3aW5kczogMCB9LCAvLyBGb3IgaW5zdGFuY2VkIGNsZWFudXBcbiAgfTtcblxuICBkZWNvcmF0ZUNodW5rKG1lc2gpO1xuICByZXR1cm4gbWVzaDtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVDaHVuayhtZXNoOiBUSFJFRS5NZXNoKSB7XG4gIC8vIDEuIENsZWFyIGV4aXN0aW5nIGRlY29yYXRpb25zIGlkZW1wb3RlbnRseSB3aXRoIHByb3BlciBkaXNwb3NhbC5cbiAgY29uc3QgcHJldmlvdXMgPSBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID8/IFtdO1xuICBmb3IgKGNvbnN0IG9iaiBvZiBwcmV2aW91cykge1xuICAgIG1lc2gucmVtb3ZlKG9iaik7XG4gICAgb2JqLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdGVyaWFsKSBtYXQuZGlzcG9zZT8uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ZXJpYWwuZGlzcG9zZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID0gW107XG5cbiAgY29uc3QgeyBwcm9wRGVuc2l0eSwgd2luZFN0cmVuZ3RoIH0gPSBlbnZDYWNoZTtcbiAgY29uc3QgcHJvcENvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChwcm9wRGVuc2l0eSAqIDE2KSk7IC8vIEluY3JlYXNlZCBkZW5zaXR5IGZvciByaWNobmVzc1xuICBjb25zdCB3aW5kQ291bnQgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHdpbmRTdHJlbmd0aCAqIDIpKTsgLy8gU2NhbGVkIHRvIHN0cmVuZ3RoXG5cbiAgLy8gUm9ja3M6IFVzZSBJbnN0YW5jZWRNZXNoIGZvciBiYXRjaGluZyAocGVyZiB3aW4gZm9yIG1hbnkgcHJvcHMpXG4gIGlmIChwcm9wQ291bnQgPiAwKSB7XG4gICAgY29uc3Qgcm9ja0dlbyA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KDEuNSArIE1hdGgucmFuZG9tKCkgKiAyLjUsIDEpOyAvLyBTbGlnaHQgZGV0YWlsXG4gICAgY29uc3Qgcm9ja0luc3RhbmNlcyA9IG5ldyBUSFJFRS5JbnN0YW5jZWRNZXNoKHJvY2tHZW8sIHNoYXJlZE1hdGVyaWFscy5yb2NrLCBwcm9wQ291bnQpO1xuICAgIGNvbnN0IHJvY2tNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIGNvbnN0IHRtcFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdG1wUXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgY29uc3QgdG1wU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbG9jYWxYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRTtcbiAgICAgIGNvbnN0IGxvY2FsWiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIENIVU5LX1NJWkU7XG4gICAgICBjb25zdCB3b3JsZFggPSBtZXNoLnVzZXJEYXRhLml4ICogQ0hVTktfU0laRSArIGxvY2FsWDtcbiAgICAgIGNvbnN0IHdvcmxkWiA9IG1lc2gudXNlckRhdGEuaXogKiBDSFVOS19TSVpFICsgbG9jYWxaO1xuICAgICAgY29uc3QgYmFzZUhlaWdodCA9IGhlaWdodEF0KHdvcmxkWCwgd29ybGRaKTtcbiAgICAgIGNvbnN0IHkgPSBiYXNlSGVpZ2h0IC0gbWVzaC5wb3NpdGlvbi55ICsgMSArIE1hdGgucmFuZG9tKCkgKiAwLjU7IC8vIFNsaWdodCBlbGV2YXRpb24gdmFyXG4gICAgICB0bXBQb3Muc2V0KGxvY2FsWCwgeSwgbG9jYWxaKTtcblxuICAgICAgLy8gQWxpZ25tZW50IHF1YXRlcm5pb24gKHVwIHZlY3RvciB0byBub3JtYWwpXG4gICAgICBjb25zdCBub3JtID0gbm9ybWFsQXQod29ybGRYLCB3b3JsZFopO1xuICAgICAgY29uc3QgdXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTtcbiAgICAgIGNvbnN0IG5vcm1hbFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKG5vcm0ueCwgbm9ybS55LCBub3JtLnopLm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgYWxpZ25tZW50UXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKHVwLCBub3JtYWxWZWMpO1xuXG4gICAgICAvLyBSYW5kb20gcm90YXRpb24gcXVhdGVybmlvbiAob24gdG9wIG9mIGFsaWdubWVudClcbiAgICAgIGNvbnN0IHJhbmRvbUV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKFxuICAgICAgICBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxuICAgICAgICAnWFlaJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhbmRvbVF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21FdWxlcihyYW5kb21FdWxlcik7XG4gICAgICB0bXBRdWF0LmNvcHkoYWxpZ25tZW50UXVhdCkubXVsdGlwbHkocmFuZG9tUXVhdCk7XG5cbiAgICAgIC8vIFNjYWxlXG4gICAgICBjb25zdCBzY2FsZSA9IDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjQ7XG4gICAgICB0bXBTY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cbiAgICAgIC8vIENvbXBvc2UgbWF0cml4XG4gICAgICByb2NrTWF0cml4LmNvbXBvc2UodG1wUG9zLCB0bXBRdWF0LCB0bXBTY2FsZSk7XG4gICAgICByb2NrSW5zdGFuY2VzLnNldE1hdHJpeEF0KGksIHJvY2tNYXRyaXgpO1xuICAgIH1cbiAgICByb2NrSW5zdGFuY2VzLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByb2NrSW5zdGFuY2VzLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgIHJvY2tJbnN0YW5jZXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuICAgIG1lc2guYWRkKHJvY2tJbnN0YW5jZXMpO1xuICAgIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMucHVzaChyb2NrSW5zdGFuY2VzKTtcbiAgICBtZXNoLnVzZXJEYXRhLmluc3RhbmNlQ291bnRzLnJvY2tzID0gcHJvcENvdW50O1xuICB9XG5cbiAgLy8gV2luZCBjb2x1bW5zOiBBbmltYXRlZCwgc2VtaS10cmFuc3BhcmVudCBmdW5uZWxzIHdpdGggcGFydGljbGUtbGlrZSB0d2lzdFxuICBpZiAod2luZENvdW50ID4gMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IDIgKyB3aW5kU3RyZW5ndGggKiAyO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gNjAgKyB3aW5kU3RyZW5ndGggKiAyMDtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gMTY7IC8vIFNtb290aGVyIGN1cnZlXG4gICAgICBjb25zdCB3aW5kR2VvID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkocmFkaXVzLCByYWRpdXMgKiAwLjYsIGhlaWdodCwgc2VnbWVudHMsIDQsIHRydWUpOyAvLyBUYXBlcmVkLCBvcGVuXG4gICAgICB3aW5kR2VvLnJvdGF0ZVgoTWF0aC5QSSAvIDIpO1xuXG4gICAgICAvLyBUd2lzdCBnZW9tZXRyeSBmb3Igdm9ydGV4IGVmZmVjdFxuICAgICAgY29uc3QgcG9zID0gd2luZEdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uIGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9zLmNvdW50OyBqKyspIHtcbiAgICAgICAgY29uc3QgeSA9IHBvcy5nZXRZKGopO1xuICAgICAgICBjb25zdCB0d2lzdEFuZ2xlID0gKHkgLyBoZWlnaHQpICogTWF0aC5QSSAqIDQgKiB3aW5kU3RyZW5ndGg7XG4gICAgICAgIGNvbnN0IHggPSBwb3MuZ2V0WChqKTtcbiAgICAgICAgY29uc3QgeiA9IHBvcy5nZXRaKGopO1xuICAgICAgICBwb3Muc2V0WChqLCB4ICogTWF0aC5jb3ModHdpc3RBbmdsZSkgLSB6ICogTWF0aC5zaW4odHdpc3RBbmdsZSkpO1xuICAgICAgICBwb3Muc2V0WihqLCB4ICogTWF0aC5zaW4odHdpc3RBbmdsZSkgKyB6ICogTWF0aC5jb3ModHdpc3RBbmdsZSkpO1xuICAgICAgfVxuICAgICAgcG9zLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHdpbmRHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgICAgY29uc3QgY29sdW1uID0gbmV3IFRIUkVFLk1lc2god2luZEdlbywgc2hhcmVkTWF0ZXJpYWxzLndpbmQpO1xuICAgICAgY29uc3QgbG9jYWxYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogQ0hVTktfU0laRSAqIDAuODsgLy8gQXZvaWQgZWRnZXNcbiAgICAgIGNvbnN0IGxvY2FsWiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIENIVU5LX1NJWkUgKiAwLjg7XG4gICAgICBjb2x1bW4ucG9zaXRpb24uc2V0KGxvY2FsWCwgaGVpZ2h0IC8gMiwgbG9jYWxaKTtcbiAgICAgIGNvbHVtbi51c2VyRGF0YSA9IHsgdGltZTogTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyIH07IC8vIEZvciBhbmltYXRpb24gb2Zmc2V0XG5cbiAgICAgIG1lc2guYWRkKGNvbHVtbik7XG4gICAgICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zLnB1c2goY29sdW1uKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgc3VidGxlIGZvZyBwbGFuZSBmb3IgYXRtb3NwaGVyaWMgZGVwdGggKHBlciBjaHVuaywgbG93IHBvbHkpXG4gIGNvbnN0IGZvZ0dlbyA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KENIVU5LX1NJWkUgKiAxLjIsIENIVU5LX1NJWkUgKiAxLjIsIDEsIDEpO1xuICBjb25zdCBmb2dNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDg4Y2NmZixcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBvcGFjaXR5OiAwLjA1ICsgd2luZFN0cmVuZ3RoICogMC4xLFxuICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXG4gIH0pO1xuICBjb25zdCBmb2cgPSBuZXcgVEhSRUUuTWVzaChmb2dHZW8sIGZvZ01hdCk7XG4gIGZvZy5wb3NpdGlvbi5zZXQoMCwgMjAsIDApO1xuICBmb2cucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgbWVzaC5hZGQoZm9nKTtcbiAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucy5wdXNoKGZvZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1lcihzY2VuZTogVEhSRUUuU2NlbmUpIHtcbiAgY29uc3QgY2h1bmtzID0gbmV3IE1hcDxzdHJpbmcsIFRIUkVFLk1lc2g+KCk7XG4gIGNvbnN0IHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGxldCBlbnZpcm9ubWVudERpcnR5ID0gZmFsc2U7XG4gIGxldCBhbmltYXRpb25UaW1lID0gMDsgLy8gRm9yIHdpbmQgYW5pbWF0aW9uXG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBvbkRpZmZpY3VsdHlDaGFuZ2UoKHN0YXRlKSA9PiB7XG4gICAgLy8gMS4gTWFyayBkaXJ0eSBvbiBlbnYgY2hhbmdlOyByZWJ1aWxkIGRlY29yYXRpb25zIG5leHQgdXBkYXRlLlxuICAgIGVudkNhY2hlID0gc3RhdGUuZW52aXJvbm1lbnQ7XG4gICAgZW52aXJvbm1lbnREaXJ0eSA9IHRydWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZShpeDogbnVtYmVyLCBpejogbnVtYmVyLCBkZXRhaWxMZXZlbDogJ25lYXInIHwgJ2ZhcicpIHtcbiAgICBjb25zdCBrID0ga2V5KGl4LCBpeik7XG4gICAgaWYgKGNodW5rcy5oYXMoaykpIHtcbiAgICAgIC8vIFVwZ3JhZGUvZG93bmdyYWRlIGRldGFpbCBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gY2h1bmtzLmdldChrKSE7XG4gICAgICBpZiAoZXhpc3RpbmcudXNlckRhdGEuZGV0YWlsTGV2ZWwgIT09IGRldGFpbExldmVsKSB7XG4gICAgICAgIHNjZW5lLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhleGlzdGluZyk7XG4gICAgICAgIGNodW5rcy5kZWxldGUoayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWVzaCA9IGJ1aWxkQ2h1bmsoaXgsIGl6LCBkZXRhaWxMZXZlbCk7XG4gICAgY2h1bmtzLnNldChrLCBtZXNoKTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZShjZW50ZXJYOiBudW1iZXIsIGNlbnRlclo6IG51bWJlcikge1xuICAgIGZvciAoY29uc3QgW2ssIG1dIG9mIGNodW5rcykge1xuICAgICAgY29uc3QgZHggPSB0b0NodW5rKGNlbnRlclgpIC0gbS51c2VyRGF0YS5peDtcbiAgICAgIGNvbnN0IGR6ID0gdG9DaHVuayhjZW50ZXJaKSAtIG0udXNlckRhdGEuaXo7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeikpO1xuICAgICAgaWYgKGRpc3QgPiBBQ1RJVkVfUkFESVVTX0ZBUikge1xuICAgICAgICBzY2VuZS5yZW1vdmUobSk7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhtKTtcbiAgICAgICAgY2h1bmtzLmRlbGV0ZShrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlQ2h1bmsobWVzaDogVEhSRUUuTWVzaCkge1xuICAgIC8vIENvbXByZWhlbnNpdmUgZGlzcG9zYWw6IEdlb21zLCBtYXRzIChza2lwIHNoYXJlZCksIGluc3RhbmNlc1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIGNvbnN0IGRlY29yYXRpb25zID0gbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucyA/PyBbXTtcbiAgICBmb3IgKGNvbnN0IGRlY28gb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIG1lc2gucmVtb3ZlKGRlY28pO1xuICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRNZXNoKSB7XG4gICAgICAgIGRlY28uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICBkZWNvLmRpc3Bvc2UoKTsgLy8gUmVsZWFzZXMgaW5zdGFuY2UgYnVmZmVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNvLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICAgIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXQgb2YgbWF0ZXJpYWwpIG1hdC5kaXNwb3NlPy4oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLmRpc3Bvc2U/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERvbid0IGRpc3Bvc2Ugc2hhcmVkIG1hdGVyaWFscyBoZXJlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZShwb3M6IFRIUkVFLlZlY3RvcjMsIGR0OiBudW1iZXIpIHtcbiAgICAgIGFuaW1hdGlvblRpbWUgKz0gZHQ7XG5cbiAgICAgIC8vIER5bmFtaWMgcmFkaXVzIGJhc2VkIG9uIGVudkNhY2hlIChlLmcuLCBkZW5zZXIgZm9nID0gc21hbGxlciByYWRpdXMpXG4gICAgICBjb25zdCBlZmZlY3RpdmVOZWFyID0gTWF0aC5tYXgoMSwgQUNUSVZFX1JBRElVU19ORUFSIC0gZW52Q2FjaGUud2luZFN0cmVuZ3RoICogMC41KTtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZUZhciA9IE1hdGgubWF4KDMsIEFDVElWRV9SQURJVVNfRkFSIC0gZW52Q2FjaGUucHJvcERlbnNpdHkgKiAwLjIpO1xuXG4gICAgICBjb25zdCBjeCA9IHRvQ2h1bmsocG9zLngpO1xuICAgICAgY29uc3QgY3ogPSB0b0NodW5rKHBvcy56KTtcblxuICAgICAgLy8gRW5zdXJlIG5lYXIgY2h1bmtzIChoaWdoIGRldGFpbClcbiAgICAgIGZvciAobGV0IGR6ID0gLWVmZmVjdGl2ZU5lYXI7IGR6IDw9IGVmZmVjdGl2ZU5lYXI7IGR6KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtZWZmZWN0aXZlTmVhcjsgZHggPD0gZWZmZWN0aXZlTmVhcjsgZHgrKykge1xuICAgICAgICAgIGVuc3VyZShjeCArIGR4LCBjeiArIGR6LCAnbmVhcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBmYXIgY2h1bmtzIChsb3cgZGV0YWlsKVxuICAgICAgZm9yIChsZXQgZHogPSAtZWZmZWN0aXZlRmFyOyBkeiA8PSBlZmZlY3RpdmVGYXI7IGR6KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtZWZmZWN0aXZlRmFyOyBkeCA8PSBlZmZlY3RpdmVGYXI7IGR4KyspIHtcbiAgICAgICAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeikpID4gZWZmZWN0aXZlTmVhcikge1xuICAgICAgICAgICAgZW5zdXJlKGN4ICsgZHgsIGN6ICsgZHosICdmYXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJ1bmUocG9zLngsIHBvcy56KTtcblxuICAgICAgaWYgKGVudmlyb25tZW50RGlydHkpIHtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICAgIGRlY29yYXRlQ2h1bmsobSk7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBbmltYXRlIHdpbmQgY29sdW1uc1xuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICBtLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggJiYgY2hpbGQudXNlckRhdGEudGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZC51c2VyRGF0YS50aW1lICs9IGR0ICogKDEgKyBlbnZDYWNoZS53aW5kU3RyZW5ndGgpO1xuICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwub3BhY2l0eSA9IDAuMSArIE1hdGguc2luKGNoaWxkLnVzZXJEYXRhLnRpbWUgKiAyKSAqIDAuMSArIGVudkNhY2hlLndpbmRTdHJlbmd0aCAqIDAuMDg7XG4gICAgICAgICAgICBjaGlsZC5yb3RhdGlvbi55ICs9IGR0ICogZW52Q2FjaGUud2luZFN0cmVuZ3RoICogMC41OyAvLyBHZW50bGUgc3dheVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHF1ZXJ5SGVpZ2h0KHg6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgICByZXR1cm4gaGVpZ2h0QXQoeCwgeik7XG4gICAgfSxcblxuICAgIHF1ZXJ5Tm9ybWFsKHg6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgICBjb25zdCBuID0gbm9ybWFsQXQoeCwgeik7XG4gICAgICByZXR1cm4gdG1wLnNldChuLngsIG4ueSwgbi56KTtcbiAgICB9LFxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIC8vIDEuIENsZWFudXA6IFVuc3ViLCBwcnVuZSBhbGwsIGRpc3Bvc2Ugc2hhcmVkIG1hdHMuXG4gICAgICB1bnN1YnNjcmliZT8uKCk7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgY2h1bmtzLnZhbHVlcygpKSB7XG4gICAgICAgIGRpc3Bvc2VDaHVuayhtKTtcbiAgICAgIH1cbiAgICAgIGNodW5rcy5jbGVhcigpO1xuXG4gICAgICAvLyBEaXNwb3NlIHNoYXJlZCBtYXRlcmlhbHNcbiAgICAgIE9iamVjdC52YWx1ZXMoc2hhcmVkTWF0ZXJpYWxzKS5mb3JFYWNoKG1hdCA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdCkpIHtcbiAgICAgICAgICBtYXQuZm9yRWFjaChtID0+IG0uZGlzcG9zZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufSJdLCJuYW1lcyI6WyJUSFJFRSIsImhlaWdodEF0Iiwibm9ybWFsQXQiLCJnZXREaWZmaWN1bHR5U3RhdGUiLCJvbkRpZmZpY3VsdHlDaGFuZ2UiLCJDSFVOS19TSVpFIiwiVkVSVFNfTkVBUiIsIlZFUlRTX0ZBUiIsIkhBTEYiLCJBQ1RJVkVfUkFESVVTX05FQVIiLCJBQ1RJVkVfUkFESVVTX0ZBUiIsImtleSIsIml4IiwiaXoiLCJ0b0NodW5rIiwieCIsIk1hdGgiLCJmbG9vciIsImVudkNhY2hlIiwiZW52aXJvbm1lbnQiLCJzaGFyZWRNYXRlcmlhbHMiLCJ0ZXJyYWluIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJjb2xvciIsInJvdWdobmVzcyIsIm1ldGFsbmVzcyIsInJvY2siLCJ3aW5kIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsImJ1aWxkQ2h1bmsiLCJkZXRhaWxMZXZlbCIsInZlcnRzIiwiZyIsIlBsYW5lR2VvbWV0cnkiLCJyb3RhdGVYIiwiUEkiLCJwb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJpIiwiY291bnQiLCJ2eCIsImdldFgiLCJ2eiIsImdldFoiLCJoIiwic2V0WSIsIm5lZWRzVXBkYXRlIiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJ1diIsInNldFhZIiwiZ2V0WSIsIm1lc2giLCJNZXNoIiwic2V0IiwicmVjZWl2ZVNoYWRvdyIsImNhc3RTaGFkb3ciLCJ1c2VyRGF0YSIsImRlY29yYXRpb25zIiwiaW5zdGFuY2VDb3VudHMiLCJyb2NrcyIsIndpbmRzIiwiZGVjb3JhdGVDaHVuayIsInByZXZpb3VzIiwib2JqIiwicmVtb3ZlIiwidHJhdmVyc2UiLCJjaGlsZCIsImdlb21ldHJ5IiwiZGlzcG9zZSIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwibWF0IiwicHJvcERlbnNpdHkiLCJ3aW5kU3RyZW5ndGgiLCJwcm9wQ291bnQiLCJtYXgiLCJyb3VuZCIsIndpbmRDb3VudCIsInJvY2tHZW8iLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwicmFuZG9tIiwicm9ja0luc3RhbmNlcyIsIkluc3RhbmNlZE1lc2giLCJyb2NrTWF0cml4IiwiTWF0cml4NCIsInRtcFBvcyIsIlZlY3RvcjMiLCJ0bXBRdWF0IiwiUXVhdGVybmlvbiIsInRtcFNjYWxlIiwibG9jYWxYIiwibG9jYWxaIiwid29ybGRYIiwid29ybGRaIiwiYmFzZUhlaWdodCIsInkiLCJub3JtIiwidXAiLCJub3JtYWxWZWMiLCJ6Iiwibm9ybWFsaXplIiwiYWxpZ25tZW50UXVhdCIsInNldEZyb21Vbml0VmVjdG9ycyIsInJhbmRvbUV1bGVyIiwiRXVsZXIiLCJyYW5kb21RdWF0Iiwic2V0RnJvbUV1bGVyIiwiY29weSIsIm11bHRpcGx5Iiwic2NhbGUiLCJjb21wb3NlIiwic2V0TWF0cml4QXQiLCJpbnN0YW5jZU1hdHJpeCIsImFkZCIsInB1c2giLCJyYWRpdXMiLCJoZWlnaHQiLCJzZWdtZW50cyIsIndpbmRHZW8iLCJDeWxpbmRlckdlb21ldHJ5IiwiaiIsInR3aXN0QW5nbGUiLCJzZXRYIiwiY29zIiwic2luIiwic2V0WiIsImNvbHVtbiIsInRpbWUiLCJmb2dHZW8iLCJmb2dNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNpZGUiLCJEb3VibGVTaWRlIiwiZm9nIiwicm90YXRpb24iLCJjcmVhdGVTdHJlYW1lciIsInNjZW5lIiwiY2h1bmtzIiwiTWFwIiwidG1wIiwiZW52aXJvbm1lbnREaXJ0eSIsImFuaW1hdGlvblRpbWUiLCJ1bnN1YnNjcmliZSIsInN0YXRlIiwiZW5zdXJlIiwiayIsImhhcyIsImV4aXN0aW5nIiwiZ2V0IiwiZGlzcG9zZUNodW5rIiwiZGVsZXRlIiwicHJ1bmUiLCJjZW50ZXJYIiwiY2VudGVyWiIsIm0iLCJkeCIsImR6IiwiZGlzdCIsImFicyIsImRlY28iLCJ1cGRhdGUiLCJkdCIsImVmZmVjdGl2ZU5lYXIiLCJlZmZlY3RpdmVGYXIiLCJjeCIsImN6IiwidmFsdWVzIiwidW5kZWZpbmVkIiwicXVlcnlIZWlnaHQiLCJxdWVyeU5vcm1hbCIsIm4iLCJjbGVhciIsIk9iamVjdCIsImZvckVhY2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});