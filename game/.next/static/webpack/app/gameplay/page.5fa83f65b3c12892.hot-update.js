"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameplay/page",{

/***/ "(app-pages-browser)/./src/world/chunks/streamer.ts":
/*!**************************************!*\
  !*** ./src/world/chunks/streamer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStreamer: () => (/* binding */ createStreamer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _generateHeight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateHeight */ \"(app-pages-browser)/./src/world/chunks/generateHeight.ts\");\n/* harmony import */ var _engine_difficulty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/difficulty */ \"(app-pages-browser)/./src/engine/difficulty.ts\");\n/* harmony import */ var three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/utils/BufferGeometryUtils.js */ \"(app-pages-browser)/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js\");\n// TerrainStreamer.ts\n\n\n\n// ✅ merge helper must be imported from examples utils (not THREE namespace)\n\n/* ──────────────────────────────────────────────────────────────────────────\n   CONFIG\n   ────────────────────────────────────────────────────────────────────────── */ const CHUNK_SIZE = 512;\nconst GRID_SEGMENTS = 100 // PlaneGeometry(..., wSegs, hSegs)\n;\nconst ACTIVE_RADIUS = 5 // in chunks (Chebyshev distance)\n;\nconst FADE_DURATION = 1.0 // seconds\n;\nconst SKIRT_DROP = 12 // vertical extrusion to hide transient gaps\n;\nconst TILE_REPEAT = 8 // UV tiling for the terrain texture\n;\nconst ROCKS_PER_DENSITY_UNIT = 16 // propDensity × this\n;\n/* ──────────────────────────────────────────────────────────────────────────\n   UTILITIES\n   ────────────────────────────────────────────────────────────────────────── */ const HALF = CHUNK_SIZE / 2;\nconst key = (ix, iz)=>\"\".concat(ix, \",\").concat(iz);\nconst toChunk = (x)=>Math.floor(x / CHUNK_SIZE);\n// Stable seeded RNG so decorations don’t “pop” when re-decorating\nfunction mulberry32(seed) {\n    return function() {\n        let t = seed += 0x6d2b79f5;\n        t = Math.imul(t ^ t >>> 15, t | 1);\n        t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n        return ((t ^ t >>> 14) >>> 0) / 4294967296;\n    };\n}\nconst hash2i = (a, b)=>{\n    // simple 2D int hash → int\n    let h = a | 0;\n    h = Math.imul(h ^ 0x9e3779b1, 0x85ebca6b);\n    h ^= b | 0;\n    h = Math.imul(h ^ 0xc2b2ae35, 0x27d4eb2f);\n    return h >>> 0;\n};\n/* ──────────────────────────────────────────────────────────────────────────\n   SHARED RESOURCES\n   ────────────────────────────────────────────────────────────────────────── */ let envCache = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.getDifficultyState)().environment;\n// Base/shared materials & geometries (cloned where per-mesh state is needed)\nconst shared = {\n    terrainBase: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x506a52,\n        roughness: 0.95,\n        metalness: 0,\n        transparent: true,\n        opacity: 1.0,\n        dithering: true\n    }),\n    rockMat: new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x4a4f44,\n        roughness: 0.8,\n        metalness: 0.1\n    }),\n    rockGeo: new three__WEBPACK_IMPORTED_MODULE_2__.IcosahedronGeometry(2.0, 1)\n};\n/* ──────────────────────────────────────────────────────────────────────────\n   GEOMETRY BUILDERS\n   ────────────────────────────────────────────────────────────────────────── */ // 1) Build the main height-mapped plane\nfunction buildTerrainPlane(ix, iz) {\n    // Note: wSegs/hSegs === GRID_SEGMENTS → (GRID_SEGMENTS+1)^2 vertices\n    const g = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);\n    g.rotateX(-Math.PI / 2);\n    const pos = g.attributes.position;\n    for(let i = 0; i < pos.count; i++){\n        const vx = pos.getX(i) + ix * CHUNK_SIZE;\n        const vz = pos.getZ(i) + iz * CHUNK_SIZE;\n        pos.setY(i, (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(vx, vz));\n    }\n    pos.needsUpdate = true;\n    // UV tiling for the color map\n    const uv = g.attributes.uv;\n    for(let i = 0; i < uv.count; i++){\n        uv.setXY(i, uv.getX(i) * TILE_REPEAT, uv.getY(i) * TILE_REPEAT);\n    }\n    uv.needsUpdate = true;\n    g.computeVertexNormals();\n    return g;\n}\n// 2) Build a vertical “skirt” ring around the chunk edges, welded to the top edge\nfunction buildSkirt(ix, iz) {\n    // Each side has GRID_SEGMENTS segments ⇒ GRID_SEGMENTS+1 edge vertices\n    const edgeVerts = GRID_SEGMENTS + 1;\n    const seg = CHUNK_SIZE / GRID_SEGMENTS;\n    // We’ll create 4 sides, each with a strip of (edgeVerts) quads = (edgeVerts-1)*2 triangles\n    const positions = [];\n    const uvs = [];\n    const indices = [];\n    // helper to push a vertical pair (top,bottom) and return the index of the TOP\n    const pushPair = (xLocal, zLocal)=>{\n        const worldX = ix * CHUNK_SIZE + xLocal;\n        const worldZ = iz * CHUNK_SIZE + zLocal;\n        const topY = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ);\n        const bottomY = topY - SKIRT_DROP;\n        const baseIdx = positions.length / 3;\n        // top\n        positions.push(xLocal, topY, zLocal);\n        uvs.push((xLocal + HALF) / CHUNK_SIZE, (zLocal + HALF) / CHUNK_SIZE);\n        // bottom\n        positions.push(xLocal, bottomY, zLocal);\n        uvs.push((xLocal + HALF) / CHUNK_SIZE, (zLocal + HALF) / CHUNK_SIZE);\n        return baseIdx // index of the top; bottom is baseIdx+1\n        ;\n    };\n    // helper to connect two consecutive pairs as a vertical quad\n    const pushQuad = (iTopA, iTopB)=>{\n        const iBotA = iTopA + 1;\n        const iBotB = iTopB + 1;\n        indices.push(iTopA, iTopB, iBotB);\n        indices.push(iTopA, iBotB, iBotA);\n    };\n    // top edge (z = +HALF), left→right\n    let prevTop = pushPair(-HALF, +HALF);\n    for(let i = 1; i < edgeVerts; i++){\n        const x = -HALF + i * seg;\n        const nextTop = pushPair(x, +HALF);\n        pushQuad(prevTop, nextTop);\n        prevTop = nextTop;\n    }\n    // right edge (x = +HALF), top→bottom\n    prevTop = pushPair(+HALF, +HALF);\n    for(let i = 1; i < edgeVerts; i++){\n        const z = +HALF - i * seg;\n        const nextTop = pushPair(+HALF, z);\n        pushQuad(prevTop, nextTop);\n        prevTop = nextTop;\n    }\n    // bottom edge (z = -HALF), right→left\n    prevTop = pushPair(+HALF, -HALF);\n    for(let i = 1; i < edgeVerts; i++){\n        const x = +HALF - i * seg;\n        const nextTop = pushPair(x, -HALF);\n        pushQuad(prevTop, nextTop);\n        prevTop = nextTop;\n    }\n    // left edge (x = -HALF), bottom→top\n    prevTop = pushPair(-HALF, -HALF);\n    for(let i = 1; i < edgeVerts; i++){\n        const z = -HALF + i * seg;\n        const nextTop = pushPair(-HALF, z);\n        pushQuad(prevTop, nextTop);\n        prevTop = nextTop;\n    }\n    const geo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n    geo.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n    geo.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(uvs, 2));\n    geo.setIndex(indices);\n    geo.computeVertexNormals();\n    return geo;\n}\n// 3) Build a full chunk geometry = terrain plane + skirt\nfunction buildChunkGeometry(ix, iz) {\n    const plane = buildTerrainPlane(ix, iz);\n    const skirt = buildSkirt(ix, iz);\n    const merged = (0,three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.mergeGeometries)([\n        plane,\n        skirt\n    ], false);\n    merged.computeVertexNormals();\n    plane.dispose();\n    skirt.dispose();\n    return merged;\n}\n/* ──────────────────────────────────────────────────────────────────────────\n   DECORATIONS\n   ────────────────────────────────────────────────────────────────────────── */ function decorateChunk(mesh) {\n    // Clear previous decorations (safe dispose)\n    const previous = mesh.userData.decorations;\n    if (previous === null || previous === void 0 ? void 0 : previous.length) {\n        for (const obj of previous){\n            mesh.remove(obj);\n            if (obj instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                obj.geometry.dispose();\n                obj.dispose();\n            } else {\n                obj.traverse((c)=>{\n                    var _m_dispose;\n                    if (c.geometry) c.geometry.dispose();\n                    const m = c.material;\n                    if (Array.isArray(m)) m.forEach((mm)=>{\n                        var _mm_dispose;\n                        return (_mm_dispose = mm.dispose) === null || _mm_dispose === void 0 ? void 0 : _mm_dispose.call(mm);\n                    });\n                    else m === null || m === void 0 ? void 0 : (_m_dispose = m.dispose) === null || _m_dispose === void 0 ? void 0 : _m_dispose.call(m);\n                });\n            }\n        }\n    }\n    mesh.userData.decorations = [];\n    const { propDensity } = envCache;\n    const propCount = Math.max(0, Math.round(propDensity * ROCKS_PER_DENSITY_UNIT));\n    if (propCount === 0) return;\n    // Deterministic scatter per chunk\n    const seed = hash2i(mesh.userData.ix, mesh.userData.iz);\n    const rand = mulberry32(seed);\n    const inst = new three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh(shared.rockGeo, shared.rockMat, propCount);\n    const mat = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n    const p = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    const q = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n    const s = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    const up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n    const n = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    for(let i = 0; i < propCount; i++){\n        const localX = (rand() - 0.5) * CHUNK_SIZE;\n        const localZ = (rand() - 0.5) * CHUNK_SIZE;\n        const worldX = mesh.userData.ix * CHUNK_SIZE + localX;\n        const worldZ = mesh.userData.iz * CHUNK_SIZE + localZ;\n        const y = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(worldX, worldZ) + 0.6 + rand() * 0.4;\n        p.set(localX, y, localZ);\n        const nn = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(worldX, worldZ);\n        n.set(nn.x, nn.y, nn.z).normalize();\n        const align = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromUnitVectors(up, n);\n        // small random rotation around normal\n        q.setFromAxisAngle(n, rand() * Math.PI * 2);\n        q.premultiply(align);\n        const k = 0.8 + rand() * 0.5;\n        s.set(k, k, k);\n        mat.compose(p, q, s);\n        inst.setMatrixAt(i, mat);\n    }\n    inst.instanceMatrix.needsUpdate = true;\n    inst.castShadow = true;\n    inst.frustumCulled = false;\n    mesh.add(inst);\n    mesh.userData.decorations.push(inst);\n}\n/* ──────────────────────────────────────────────────────────────────────────\n   CHUNK BUILDER\n   ────────────────────────────────────────────────────────────────────────── */ function buildChunk(ix, iz, textureMap) {\n    const geo = buildChunkGeometry(ix, iz);\n    // ❗ per-chunk material clone so fades don’t affect *all* chunks\n    const mat = shared.terrainBase.clone();\n    mat.map = textureMap !== null && textureMap !== void 0 ? textureMap : null;\n    mat.needsUpdate = true;\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n    mesh.position.set(ix * CHUNK_SIZE, 0, iz * CHUNK_SIZE);\n    mesh.receiveShadow = true;\n    mesh.frustumCulled = false; // safer for large, deformed tiles\n    mesh.userData = {\n        ix,\n        iz,\n        decorations: [],\n        fade: {\n            t: 0,\n            from: 0,\n            to: 1,\n            start: 0\n        },\n        removing: false\n    };\n    mesh.material.opacity = 0;\n    decorateChunk(mesh);\n    return mesh;\n}\n/* ──────────────────────────────────────────────────────────────────────────\n   STREAMER\n   ────────────────────────────────────────────────────────────────────────── */ function createStreamer(scene) {\n    const chunks = new Map();\n    const tmp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    const clock = new three__WEBPACK_IMPORTED_MODULE_2__.Clock();\n    let environmentDirty = false;\n    // ── Texture load (asynchronously); newly created chunks will receive it immediately\n    let terrainMap = null;\n    new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load('/textures/32d4a6ff-3da1-4c7c-a742-1d1fa759e394.png', (tex)=>{\n        tex.wrapS = tex.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;\n        var _THREE_SRGBColorSpace;\n        tex.colorSpace = (_THREE_SRGBColorSpace = three__WEBPACK_IMPORTED_MODULE_2__.SRGBColorSpace) !== null && _THREE_SRGBColorSpace !== void 0 ? _THREE_SRGBColorSpace : undefined;\n        tex.anisotropy = 8;\n        terrainMap = tex;\n        // Update existing chunk materials to use the map\n        for (const m of chunks.values()){\n            const mm = m.material;\n            mm.map = tex;\n            mm.needsUpdate = true;\n        }\n    }, undefined, (err)=>console.warn('Terrain texture failed to load; using flat color', err));\n    // ── React to difficulty / environment changes\n    const unsubscribe = (0,_engine_difficulty__WEBPACK_IMPORTED_MODULE_1__.onDifficultyChange)((state)=>{\n        envCache = state.environment;\n        environmentDirty = true;\n    });\n    // ── Ensure a chunk exists\n    function ensure(ix, iz) {\n        const k = key(ix, iz);\n        if (chunks.has(k)) return;\n        const mesh = buildChunk(ix, iz, terrainMap);\n        // schedule fade in\n        mesh.userData.fade = {\n            t: 0,\n            from: 0,\n            to: 1,\n            start: clock.getElapsedTime()\n        };\n        scene.add(mesh);\n        chunks.set(k, mesh);\n    }\n    // ── Mark distant chunks to remove (we’ll fade them in update loop)\n    function markForRemoval(centerX, centerZ, radius) {\n        const cx = toChunk(centerX);\n        const cz = toChunk(centerZ);\n        for (const [k, m] of chunks){\n            const dx = cx - m.userData.ix;\n            const dz = cz - m.userData.iz;\n            const dist = Math.max(Math.abs(dx), Math.abs(dz));\n            if (dist > radius && !m.userData.removing) {\n                m.userData.removing = true;\n                m.userData.fade = {\n                    t: 0,\n                    from: m.material.opacity,\n                    to: 0,\n                    start: clock.getElapsedTime()\n                };\n            }\n        }\n    }\n    // ── Fade step (both in & out), and dispose out-faded chunks\n    function stepFades(now) {\n        const toDelete = [];\n        for (const [k, m] of chunks){\n            const f = m.userData.fade;\n            if (!f) continue;\n            const mm = m.material;\n            const elapsed = now - f.start;\n            const t = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(elapsed / FADE_DURATION, 0, 1);\n            mm.opacity = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.lerp(f.from, f.to, t);\n            if (t >= 1) {\n                // if we just faded out, remove & dispose\n                if (m.userData.removing) {\n                    scene.remove(m);\n                    disposeChunk(m);\n                    chunks.delete(k);\n                } else {\n                    // fade-in finished; clear fade marker\n                    m.userData.fade = null;\n                }\n            }\n        }\n    }\n    // ── Dispose a whole chunk safely\n    function disposeChunk(mesh) {\n        mesh.geometry.dispose();\n        // dispose *per-chunk clone* of terrain material\n        const mm = mesh.material;\n        if (mm.map && mm.map !== terrainMap) mm.map.dispose();\n        mm.dispose();\n        // decorations\n        const decos = mesh.userData.decorations;\n        for (const d of decos !== null && decos !== void 0 ? decos : []){\n            if (d instanceof three__WEBPACK_IMPORTED_MODULE_2__.InstancedMesh) {\n                d.geometry.dispose();\n                d.dispose();\n            } else {\n                d.traverse((c)=>{\n                    var _mat_dispose;\n                    if (c.geometry) c.geometry.dispose();\n                    const mat = c.material;\n                    if (Array.isArray(mat)) mat.forEach((m)=>{\n                        var _m_dispose;\n                        return (_m_dispose = m.dispose) === null || _m_dispose === void 0 ? void 0 : _m_dispose.call(m);\n                    });\n                    else mat === null || mat === void 0 ? void 0 : (_mat_dispose = mat.dispose) === null || _mat_dispose === void 0 ? void 0 : _mat_dispose.call(mat);\n                });\n            }\n            mesh.remove(d);\n        }\n        mesh.userData.decorations = [];\n    }\n    return {\n        update (pos, dt) {\n            // radius can adjust with density if you wish; keep simple & stable here\n            const radius = ACTIVE_RADIUS;\n            const cx = toChunk(pos.x);\n            const cz = toChunk(pos.z);\n            // create/keep a square of chunks around the player\n            for(let dz = -radius; dz <= radius; dz++){\n                for(let dx = -radius; dx <= radius; dx++){\n                    ensure(cx + dx, cz + dz);\n                }\n            }\n            // mark far chunks for fade-out/removal\n            markForRemoval(pos.x, pos.z, radius);\n            // re-decorate after env change (seeded → no popping)\n            if (environmentDirty) {\n                for (const m of chunks.values())decorateChunk(m);\n                environmentDirty = false;\n            }\n            // fade step\n            stepFades(clock.getElapsedTime());\n        },\n        queryHeight (x, z) {\n            return (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.heightAt)(x, z);\n        },\n        queryNormal (x, z) {\n            const n = (0,_generateHeight__WEBPACK_IMPORTED_MODULE_0__.normalAt)(x, z);\n            return tmp.set(n.x, n.y, n.z);\n        },\n        dispose () {\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            for (const m of chunks.values())disposeChunk(m);\n            chunks.clear();\n            // shared resources: don’t dispose shared.terrainBase (used as template)\n            shared.rockGeo.dispose();\n            shared.rockMat.dispose();\n            if (terrainMap) {\n                terrainMap.dispose();\n                terrainMap = null;\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy93b3JsZC9jaHVua3Mvc3RyZWFtZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDUztBQUN1QjtBQUN1QjtBQUU1RSw0RUFBNEU7QUFDSztBQUVqRjs7OEVBRThFLEdBQzlFLE1BQU1NLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCLElBQWlCLG1DQUFtQzs7QUFDMUUsTUFBTUMsZ0JBQWdCLEVBQWlCLGlDQUFpQzs7QUFDeEUsTUFBTUMsZ0JBQWdCLElBQWlCLFVBQVU7O0FBQ2pELE1BQU1DLGFBQWEsR0FBb0IsNENBQTRDOztBQUNuRixNQUFNQyxjQUFjLEVBQW1CLG9DQUFvQzs7QUFDM0UsTUFBTUMseUJBQXlCLEdBQVEscUJBQXFCOztBQUU1RDs7OEVBRThFLEdBQzlFLE1BQU1DLE9BQU9QLGFBQWE7QUFDMUIsTUFBTVEsTUFBTSxDQUFDQyxJQUFZQyxLQUFlLEdBQVNBLE9BQU5ELElBQUcsS0FBTSxPQUFIQztBQUNqRCxNQUFNQyxVQUFVLENBQUNDLElBQWNDLEtBQUtDLEtBQUssQ0FBQ0YsSUFBSVo7QUFFOUMsa0VBQWtFO0FBQ2xFLFNBQVNlLFdBQVdDLElBQVk7SUFDOUIsT0FBTztRQUNMLElBQUlDLElBQUtELFFBQVE7UUFDakJDLElBQUlKLEtBQUtLLElBQUksQ0FBQ0QsSUFBS0EsTUFBTSxJQUFLQSxJQUFJO1FBQ2xDQSxLQUFLQSxJQUFJSixLQUFLSyxJQUFJLENBQUNELElBQUtBLE1BQU0sR0FBSUEsSUFBSTtRQUN0QyxPQUFPLENBQUMsQ0FBQ0EsSUFBS0EsTUFBTSxFQUFFLE1BQU8sS0FBSztJQUNwQztBQUNGO0FBQ0EsTUFBTUUsU0FBUyxDQUFDQyxHQUFXQztJQUN6QiwyQkFBMkI7SUFDM0IsSUFBSUMsSUFBSUYsSUFBSTtJQUNaRSxJQUFJVCxLQUFLSyxJQUFJLENBQUNJLElBQUksWUFBWTtJQUM5QkEsS0FBS0QsSUFBSTtJQUNUQyxJQUFJVCxLQUFLSyxJQUFJLENBQUNJ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LENBQUNILFFBQVFHLE1BQU1ILFFBQVFHLEtBQU07b0JBQ3pDVCxPQUFPTyxLQUFLRSxJQUFJRCxLQUFLRTtnQkFDdkI7WUFDRjtZQUVBLHVDQUF1QztZQUN2Q1AsZUFBZXpJLElBQUk5QixDQUFDLEVBQUU4QixJQUFJc0MsQ0FBQyxFQUFFc0c7WUFFN0IscURBQXFEO1lBQ3JELElBQUl4QixrQkFBa0I7Z0JBQ3BCLEtBQUssTUFBTXhELEtBQUttRCxPQUFPaUIsTUFBTSxHQUFJL0UsY0FBY1c7Z0JBQy9Dd0QsbUJBQW1CO1lBQ3JCO1lBRUEsWUFBWTtZQUNaK0IsVUFBVWpDLE1BQU1zQixjQUFjO1FBQ2hDO1FBRUF5QixhQUFZL0wsQ0FBUyxFQUFFb0UsQ0FBUztZQUM5QixPQUFPckYseURBQVFBLENBQUNpQixHQUFHb0U7UUFDckI7UUFFQTRILGFBQVloTSxDQUFTLEVBQUVvRSxDQUFTO1lBQzlCLE1BQU0wQyxJQUFJOUgseURBQVFBLENBQUNnQixHQUFHb0U7WUFDdEIsT0FBTzJFLElBQUk3QixHQUFHLENBQUNKLEVBQUU5RyxDQUFDLEVBQUU4RyxFQUFFRyxDQUFDLEVBQUVILEVBQUUxQyxDQUFDO1FBQzlCO1FBRUFVO1lBQ0VvRix3QkFBQUEsa0NBQUFBO1lBQ0EsS0FBSyxNQUFNeEUsS0FBS21ELE9BQU9pQixNQUFNLEdBQUkyQixhQUFhL0Y7WUFDOUNtRCxPQUFPb0QsS0FBSztZQUVaLHdFQUF3RTtZQUN4RXBMLE9BQU9VLE9BQU8sQ0FBQ3VELE9BQU87WUFDdEJqRSxPQUFPUyxPQUFPLENBQUN3RCxPQUFPO1lBRXRCLElBQUlxRSxZQUFZO2dCQUNkQSxXQUFXckUsT0FBTztnQkFDbEJxRSxhQUFhO1lBQ2Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9hcHAvc3JjL3dvcmxkL2NodW5rcy9zdHJlYW1lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUZXJyYWluU3RyZWFtZXIudHNcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuaW1wb3J0IHsgaGVpZ2h0QXQsIG5vcm1hbEF0IH0gZnJvbSAnLi9nZW5lcmF0ZUhlaWdodCdcbmltcG9ydCB7IGdldERpZmZpY3VsdHlTdGF0ZSwgb25EaWZmaWN1bHR5Q2hhbmdlIH0gZnJvbSAnQC9lbmdpbmUvZGlmZmljdWx0eSdcblxuLy8g4pyFIG1lcmdlIGhlbHBlciBtdXN0IGJlIGltcG9ydGVkIGZyb20gZXhhbXBsZXMgdXRpbHMgKG5vdCBUSFJFRSBuYW1lc3BhY2UpXG5pbXBvcnQgeyBtZXJnZUdlb21ldHJpZXMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcydcblxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG4gICBDT05GSUdcbiAgIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xuY29uc3QgQ0hVTktfU0laRSA9IDUxMlxuY29uc3QgR1JJRF9TRUdNRU5UUyA9IDEwMCAgICAgICAgICAgICAgLy8gUGxhbmVHZW9tZXRyeSguLi4sIHdTZWdzLCBoU2VncylcbmNvbnN0IEFDVElWRV9SQURJVVMgPSA1ICAgICAgICAgICAgICAgIC8vIGluIGNodW5rcyAoQ2hlYnlzaGV2IGRpc3RhbmNlKVxuY29uc3QgRkFERV9EVVJBVElPTiA9IDEuMCAgICAgICAgICAgICAgLy8gc2Vjb25kc1xuY29uc3QgU0tJUlRfRFJPUCA9IDEyICAgICAgICAgICAgICAgICAgLy8gdmVydGljYWwgZXh0cnVzaW9uIHRvIGhpZGUgdHJhbnNpZW50IGdhcHNcbmNvbnN0IFRJTEVfUkVQRUFUID0gOCAgICAgICAgICAgICAgICAgIC8vIFVWIHRpbGluZyBmb3IgdGhlIHRlcnJhaW4gdGV4dHVyZVxuY29uc3QgUk9DS1NfUEVSX0RFTlNJVFlfVU5JVCA9IDE2ICAgICAgLy8gcHJvcERlbnNpdHkgw5cgdGhpc1xuXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbiAgIFVUSUxJVElFU1xuICAg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXG5jb25zdCBIQUxGID0gQ0hVTktfU0laRSAvIDJcbmNvbnN0IGtleSA9IChpeDogbnVtYmVyLCBpejogbnVtYmVyKSA9PiBgJHtpeH0sJHtpen1gXG5jb25zdCB0b0NodW5rID0gKHg6IG51bWJlcikgPT4gTWF0aC5mbG9vcih4IC8gQ0hVTktfU0laRSlcblxuLy8gU3RhYmxlIHNlZWRlZCBSTkcgc28gZGVjb3JhdGlvbnMgZG9u4oCZdCDigJxwb3DigJ0gd2hlbiByZS1kZWNvcmF0aW5nXG5mdW5jdGlvbiBtdWxiZXJyeTMyKHNlZWQ6IG51bWJlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxldCB0ID0gKHNlZWQgKz0gMHg2ZDJiNzlmNSlcbiAgICB0ID0gTWF0aC5pbXVsKHQgXiAodCA+Pj4gMTUpLCB0IHwgMSlcbiAgICB0IF49IHQgKyBNYXRoLmltdWwodCBeICh0ID4+PiA3KSwgdCB8IDYxKVxuICAgIHJldHVybiAoKHQgXiAodCA+Pj4gMTQpKSA+Pj4gMCkgLyA0Mjk0OTY3Mjk2XG4gIH1cbn1cbmNvbnN0IGhhc2gyaSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4ge1xuICAvLyBzaW1wbGUgMkQgaW50IGhhc2gg4oaSIGludFxuICBsZXQgaCA9IGEgfCAwXG4gIGggPSBNYXRoLmltdWwoaCBeIDB4OWUzNzc5YjEsIDB4ODVlYmNhNmIpXG4gIGggXj0gYiB8IDBcbiAgaCA9IE1hdGguaW11bChoIF4gMHhjMmIyYWUzNSwgMHgyN2Q0ZWIyZilcbiAgcmV0dXJuIGggPj4+IDBcbn1cblxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG4gICBTSEFSRUQgUkVTT1VSQ0VTXG4gICDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmxldCBlbnZDYWNoZSA9IGdldERpZmZpY3VsdHlTdGF0ZSgpLmVudmlyb25tZW50XG5cbi8vIEJhc2Uvc2hhcmVkIG1hdGVyaWFscyAmIGdlb21ldHJpZXMgKGNsb25lZCB3aGVyZSBwZXItbWVzaCBzdGF0ZSBpcyBuZWVkZWQpXG5jb25zdCBzaGFyZWQgPSB7XG4gIHRlcnJhaW5CYXNlOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDUwNmE1MixcbiAgICByb3VnaG5lc3M6IDAuOTUsXG4gICAgbWV0YWxuZXNzOiAwLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLCAvLyB3ZSBmYWRlIHBlci1jaHVua1xuICAgIG9wYWNpdHk6IDEuMCxcbiAgICBkaXRoZXJpbmc6IHRydWUsXG4gIH0pLFxuICByb2NrTWF0OiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDRhNGY0NCxcbiAgICByb3VnaG5lc3M6IDAuOCxcbiAgICBtZXRhbG5lc3M6IDAuMSxcbiAgfSksXG4gIHJvY2tHZW86IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KDIuMCwgMSksIC8vIHJldXNlZCBhY3Jvc3MgY2h1bmtzXG59XG5cbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuICAgR0VPTUVUUlkgQlVJTERFUlNcbiAgIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xuXG4vLyAxKSBCdWlsZCB0aGUgbWFpbiBoZWlnaHQtbWFwcGVkIHBsYW5lXG5mdW5jdGlvbiBidWlsZFRlcnJhaW5QbGFuZShpeDogbnVtYmVyLCBpejogbnVtYmVyKSB7XG4gIC8vIE5vdGU6IHdTZWdzL2hTZWdzID09PSBHUklEX1NFR01FTlRTIOKGkiAoR1JJRF9TRUdNRU5UUysxKV4yIHZlcnRpY2VzXG4gIGNvbnN0IGcgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShDSFVOS19TSVpFLCBDSFVOS19TSVpFLCBHUklEX1NFR01FTlRTLCBHUklEX1NFR01FTlRTKVxuICBnLnJvdGF0ZVgoLU1hdGguUEkgLyAyKVxuXG4gIGNvbnN0IHBvcyA9IGcuYXR0cmlidXRlcy5wb3NpdGlvbiBhcyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHZ4ID0gcG9zLmdldFgoaSkgKyBpeCAqIENIVU5LX1NJWkVcbiAgICBjb25zdCB2eiA9IHBvcy5nZXRaKGkpICsgaXogKiBDSFVOS19TSVpFXG4gICAgcG9zLnNldFkoaSwgaGVpZ2h0QXQodngsIHZ6KSlcbiAgfVxuICBwb3MubmVlZHNVcGRhdGUgPSB0cnVlXG5cbiAgLy8gVVYgdGlsaW5nIGZvciB0aGUgY29sb3IgbWFwXG4gIGNvbnN0IHV2ID0gZy5hdHRyaWJ1dGVzLnV2IGFzIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICB1di5zZXRYWShpLCB1di5nZXRYKGkpICogVElMRV9SRVBFQVQsIHV2LmdldFkoaSkgKiBUSUxFX1JFUEVBVClcbiAgfVxuICB1di5uZWVkc1VwZGF0ZSA9IHRydWVcblxuICBnLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKClcbiAgcmV0dXJuIGdcbn1cblxuLy8gMikgQnVpbGQgYSB2ZXJ0aWNhbCDigJxza2lydOKAnSByaW5nIGFyb3VuZCB0aGUgY2h1bmsgZWRnZXMsIHdlbGRlZCB0byB0aGUgdG9wIGVkZ2VcbmZ1bmN0aW9uIGJ1aWxkU2tpcnQoaXg6IG51bWJlciwgaXo6IG51bWJlcikge1xuICAvLyBFYWNoIHNpZGUgaGFzIEdSSURfU0VHTUVOVFMgc2VnbWVudHMg4oeSIEdSSURfU0VHTUVOVFMrMSBlZGdlIHZlcnRpY2VzXG4gIGNvbnN0IGVkZ2VWZXJ0cyA9IEdSSURfU0VHTUVOVFMgKyAxXG4gIGNvbnN0IHNlZyA9IENIVU5LX1NJWkUgLyBHUklEX1NFR01FTlRTXG5cbiAgLy8gV2XigJlsbCBjcmVhdGUgNCBzaWRlcywgZWFjaCB3aXRoIGEgc3RyaXAgb2YgKGVkZ2VWZXJ0cykgcXVhZHMgPSAoZWRnZVZlcnRzLTEpKjIgdHJpYW5nbGVzXG4gIGNvbnN0IHBvc2l0aW9uczogbnVtYmVyW10gPSBbXVxuICBjb25zdCB1dnM6IG51bWJlcltdID0gW11cbiAgY29uc3QgaW5kaWNlczogbnVtYmVyW10gPSBbXVxuXG4gIC8vIGhlbHBlciB0byBwdXNoIGEgdmVydGljYWwgcGFpciAodG9wLGJvdHRvbSkgYW5kIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIFRPUFxuICBjb25zdCBwdXNoUGFpciA9ICh4TG9jYWw6IG51bWJlciwgekxvY2FsOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB3b3JsZFggPSBpeCAqIENIVU5LX1NJWkUgKyB4TG9jYWxcbiAgICBjb25zdCB3b3JsZFogPSBpeiAqIENIVU5LX1NJWkUgKyB6TG9jYWxcbiAgICBjb25zdCB0b3BZID0gaGVpZ2h0QXQod29ybGRYLCB3b3JsZFopXG4gICAgY29uc3QgYm90dG9tWSA9IHRvcFkgLSBTS0lSVF9EUk9QXG5cbiAgICBjb25zdCBiYXNlSWR4ID0gcG9zaXRpb25zLmxlbmd0aCAvIDNcbiAgICAvLyB0b3BcbiAgICBwb3NpdGlvbnMucHVzaCh4TG9jYWwsIHRvcFksIHpMb2NhbClcbiAgICB1dnMucHVzaCgoeExvY2FsICsgSEFMRikgLyBDSFVOS19TSVpFLCAoekxvY2FsICsgSEFMRikgLyBDSFVOS19TSVpFKVxuICAgIC8vIGJvdHRvbVxuICAgIHBvc2l0aW9ucy5wdXNoKHhMb2NhbCwgYm90dG9tWSwgekxvY2FsKVxuICAgIHV2cy5wdXNoKCh4TG9jYWwgKyBIQUxGKSAvIENIVU5LX1NJWkUsICh6TG9jYWwgKyBIQUxGKSAvIENIVU5LX1NJWkUpXG5cbiAgICByZXR1cm4gYmFzZUlkeCAvLyBpbmRleCBvZiB0aGUgdG9wOyBib3R0b20gaXMgYmFzZUlkeCsxXG4gIH1cblxuICAvLyBoZWxwZXIgdG8gY29ubmVjdCB0d28gY29uc2VjdXRpdmUgcGFpcnMgYXMgYSB2ZXJ0aWNhbCBxdWFkXG4gIGNvbnN0IHB1c2hRdWFkID0gKGlUb3BBOiBudW1iZXIsIGlUb3BCOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBpQm90QSA9IGlUb3BBICsgMVxuICAgIGNvbnN0IGlCb3RCID0gaVRvcEIgKyAxXG4gICAgaW5kaWNlcy5wdXNoKGlUb3BBLCBpVG9wQiwgaUJvdEIpXG4gICAgaW5kaWNlcy5wdXNoKGlUb3BBLCBpQm90QiwgaUJvdEEpXG4gIH1cblxuICAvLyB0b3AgZWRnZSAoeiA9ICtIQUxGKSwgbGVmdOKGknJpZ2h0XG4gIGxldCBwcmV2VG9wID0gcHVzaFBhaXIoLUhBTEYsICtIQUxGKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGVkZ2VWZXJ0czsgaSsrKSB7XG4gICAgY29uc3QgeCA9IC1IQUxGICsgaSAqIHNlZ1xuICAgIGNvbnN0IG5leHRUb3AgPSBwdXNoUGFpcih4LCArSEFMRilcbiAgICBwdXNoUXVhZChwcmV2VG9wLCBuZXh0VG9wKVxuICAgIHByZXZUb3AgPSBuZXh0VG9wXG4gIH1cblxuICAvLyByaWdodCBlZGdlICh4ID0gK0hBTEYpLCB0b3DihpJib3R0b21cbiAgcHJldlRvcCA9IHB1c2hQYWlyKCtIQUxGLCArSEFMRilcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBlZGdlVmVydHM7IGkrKykge1xuICAgIGNvbnN0IHogPSArSEFMRiAtIGkgKiBzZWdcbiAgICBjb25zdCBuZXh0VG9wID0gcHVzaFBhaXIoK0hBTEYsIHopXG4gICAgcHVzaFF1YWQocHJldlRvcCwgbmV4dFRvcClcbiAgICBwcmV2VG9wID0gbmV4dFRvcFxuICB9XG5cbiAgLy8gYm90dG9tIGVkZ2UgKHogPSAtSEFMRiksIHJpZ2h04oaSbGVmdFxuICBwcmV2VG9wID0gcHVzaFBhaXIoK0hBTEYsIC1IQUxGKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGVkZ2VWZXJ0czsgaSsrKSB7XG4gICAgY29uc3QgeCA9ICtIQUxGIC0gaSAqIHNlZ1xuICAgIGNvbnN0IG5leHRUb3AgPSBwdXNoUGFpcih4LCAtSEFMRilcbiAgICBwdXNoUXVhZChwcmV2VG9wLCBuZXh0VG9wKVxuICAgIHByZXZUb3AgPSBuZXh0VG9wXG4gIH1cblxuICAvLyBsZWZ0IGVkZ2UgKHggPSAtSEFMRiksIGJvdHRvbeKGknRvcFxuICBwcmV2VG9wID0gcHVzaFBhaXIoLUhBTEYsIC1IQUxGKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGVkZ2VWZXJ0czsgaSsrKSB7XG4gICAgY29uc3QgeiA9IC1IQUxGICsgaSAqIHNlZ1xuICAgIGNvbnN0IG5leHRUb3AgPSBwdXNoUGFpcigtSEFMRiwgeilcbiAgICBwdXNoUXVhZChwcmV2VG9wLCBuZXh0VG9wKVxuICAgIHByZXZUb3AgPSBuZXh0VG9wXG4gIH1cblxuICBjb25zdCBnZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICBnZW8uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG4gIGdlby5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSlcbiAgZ2VvLnNldEluZGV4KGluZGljZXMpXG4gIGdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpXG4gIHJldHVybiBnZW9cbn1cblxuLy8gMykgQnVpbGQgYSBmdWxsIGNodW5rIGdlb21ldHJ5ID0gdGVycmFpbiBwbGFuZSArIHNraXJ0XG5mdW5jdGlvbiBidWlsZENodW5rR2VvbWV0cnkoaXg6IG51bWJlciwgaXo6IG51bWJlcikge1xuICBjb25zdCBwbGFuZSA9IGJ1aWxkVGVycmFpblBsYW5lKGl4LCBpeilcbiAgY29uc3Qgc2tpcnQgPSBidWlsZFNraXJ0KGl4LCBpeilcbiAgY29uc3QgbWVyZ2VkID0gbWVyZ2VHZW9tZXRyaWVzKFtwbGFuZSwgc2tpcnRdLCBmYWxzZSkhXG4gIG1lcmdlZC5jb21wdXRlVmVydGV4Tm9ybWFscygpXG4gIHBsYW5lLmRpc3Bvc2UoKVxuICBza2lydC5kaXNwb3NlKClcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbiAgIERFQ09SQVRJT05TXG4gICDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmZ1bmN0aW9uIGRlY29yYXRlQ2h1bmsobWVzaDogVEhSRUUuTWVzaCkge1xuICAvLyBDbGVhciBwcmV2aW91cyBkZWNvcmF0aW9ucyAoc2FmZSBkaXNwb3NlKVxuICBjb25zdCBwcmV2aW91cyA9IG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgYXMgVEhSRUUuT2JqZWN0M0RbXSB8IHVuZGVmaW5lZFxuICBpZiAocHJldmlvdXM/Lmxlbmd0aCkge1xuICAgIGZvciAoY29uc3Qgb2JqIG9mIHByZXZpb3VzKSB7XG4gICAgICBtZXNoLnJlbW92ZShvYmopXG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkTWVzaCkge1xuICAgICAgICBvYmouZ2VvbWV0cnkuZGlzcG9zZSgpXG4gICAgICAgIG9iai5kaXNwb3NlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai50cmF2ZXJzZSgoYykgPT4ge1xuICAgICAgICAgIGlmICgoYyBhcyBhbnkpLmdlb21ldHJ5KSAoYyBhcyBUSFJFRS5NZXNoKS5nZW9tZXRyeS5kaXNwb3NlKClcbiAgICAgICAgICBjb25zdCBtID0gKGMgYXMgVEhSRUUuTWVzaCkubWF0ZXJpYWxcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtKSkgbS5mb3JFYWNoKChtbSkgPT4gbW0uZGlzcG9zZT8uKCkpXG4gICAgICAgICAgZWxzZSAobSBhcyBhbnkpPy5kaXNwb3NlPy4oKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBtZXNoLnVzZXJEYXRhLmRlY29yYXRpb25zID0gW11cblxuICBjb25zdCB7IHByb3BEZW5zaXR5IH0gPSBlbnZDYWNoZVxuICBjb25zdCBwcm9wQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHByb3BEZW5zaXR5ICogUk9DS1NfUEVSX0RFTlNJVFlfVU5JVCkpXG4gIGlmIChwcm9wQ291bnQgPT09IDApIHJldHVyblxuXG4gIC8vIERldGVybWluaXN0aWMgc2NhdHRlciBwZXIgY2h1bmtcbiAgY29uc3Qgc2VlZCA9IGhhc2gyaShtZXNoLnVzZXJEYXRhLml4LCBtZXNoLnVzZXJEYXRhLml6KVxuICBjb25zdCByYW5kID0gbXVsYmVycnkzMihzZWVkKVxuXG4gIGNvbnN0IGluc3QgPSBuZXcgVEhSRUUuSW5zdGFuY2VkTWVzaChzaGFyZWQucm9ja0dlbywgc2hhcmVkLnJvY2tNYXQsIHByb3BDb3VudClcbiAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKVxuICBjb25zdCBwID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICBjb25zdCBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKVxuICBjb25zdCBzID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICBjb25zdCB1cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApXG4gIGNvbnN0IG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IGxvY2FsWCA9IChyYW5kKCkgLSAwLjUpICogQ0hVTktfU0laRVxuICAgIGNvbnN0IGxvY2FsWiA9IChyYW5kKCkgLSAwLjUpICogQ0hVTktfU0laRVxuICAgIGNvbnN0IHdvcmxkWCA9IG1lc2gudXNlckRhdGEuaXggKiBDSFVOS19TSVpFICsgbG9jYWxYXG4gICAgY29uc3Qgd29ybGRaID0gbWVzaC51c2VyRGF0YS5peiAqIENIVU5LX1NJWkUgKyBsb2NhbFpcbiAgICBjb25zdCB5ID0gaGVpZ2h0QXQod29ybGRYLCB3b3JsZFopICsgMC42ICsgcmFuZCgpICogMC40XG5cbiAgICBwLnNldChsb2NhbFgsIHksIGxvY2FsWilcblxuICAgIGNvbnN0IG5uID0gbm9ybWFsQXQod29ybGRYLCB3b3JsZFopXG4gICAgbi5zZXQobm4ueCwgbm4ueSwgbm4ueikubm9ybWFsaXplKClcbiAgICBjb25zdCBhbGlnbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKHVwLCBuKVxuXG4gICAgLy8gc21hbGwgcmFuZG9tIHJvdGF0aW9uIGFyb3VuZCBub3JtYWxcbiAgICBxLnNldEZyb21BeGlzQW5nbGUobiwgcmFuZCgpICogTWF0aC5QSSAqIDIpXG4gICAgcS5wcmVtdWx0aXBseShhbGlnbilcblxuICAgIGNvbnN0IGsgPSAwLjggKyByYW5kKCkgKiAwLjVcbiAgICBzLnNldChrLCBrLCBrKVxuXG4gICAgbWF0LmNvbXBvc2UocCwgcSwgcylcbiAgICBpbnN0LnNldE1hdHJpeEF0KGksIG1hdClcbiAgfVxuICBpbnN0Lmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZVxuICBpbnN0LmNhc3RTaGFkb3cgPSB0cnVlXG4gIGluc3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlXG5cbiAgbWVzaC5hZGQoaW5zdClcbiAgbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucy5wdXNoKGluc3QpXG59XG5cbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuICAgQ0hVTksgQlVJTERFUlxuICAg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXG5mdW5jdGlvbiBidWlsZENodW5rKGl4OiBudW1iZXIsIGl6OiBudW1iZXIsIHRleHR1cmVNYXA6IFRIUkVFLlRleHR1cmUgfCBudWxsKSB7XG4gIGNvbnN0IGdlbyA9IGJ1aWxkQ2h1bmtHZW9tZXRyeShpeCwgaXopXG5cbiAgLy8g4p2XIHBlci1jaHVuayBtYXRlcmlhbCBjbG9uZSBzbyBmYWRlcyBkb27igJl0IGFmZmVjdCAqYWxsKiBjaHVua3NcbiAgY29uc3QgbWF0ID0gc2hhcmVkLnRlcnJhaW5CYXNlLmNsb25lKClcbiAgbWF0Lm1hcCA9IHRleHR1cmVNYXAgPz8gbnVsbFxuICBtYXQubmVlZHNVcGRhdGUgPSB0cnVlXG5cbiAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KVxuICBtZXNoLnBvc2l0aW9uLnNldChpeCAqIENIVU5LX1NJWkUsIDAsIGl6ICogQ0hVTktfU0laRSlcbiAgbWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICBtZXNoLmZydXN0dW1DdWxsZWQgPSBmYWxzZSAvLyBzYWZlciBmb3IgbGFyZ2UsIGRlZm9ybWVkIHRpbGVzXG5cbiAgbWVzaC51c2VyRGF0YSA9IHtcbiAgICBpeCxcbiAgICBpeixcbiAgICBkZWNvcmF0aW9uczogW10gYXMgVEhSRUUuT2JqZWN0M0RbXSxcbiAgICBmYWRlOiB7IHQ6IDAsIGZyb206IDAsIHRvOiAxLCBzdGFydDogMCB9LCAvLyBwZXItY2h1bmsgZmFkZSBzdGF0ZVxuICAgIHJlbW92aW5nOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRydWUsIGZhZGUgdG8gMCB0aGVuIGRpc3Bvc2VcbiAgfVxuXG4gIC8vIHN0YXJ0IGludmlzaWJsZTsgd2XigJlsbCBmYWRlIGluIGZyb20gMCDihpIgMVxuICA7KG1lc2gubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwpLm9wYWNpdHkgPSAwXG4gIGRlY29yYXRlQ2h1bmsobWVzaClcbiAgcmV0dXJuIG1lc2hcbn1cblxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG4gICBTVFJFQU1FUlxuICAg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtZXIoc2NlbmU6IFRIUkVFLlNjZW5lKSB7XG4gIGNvbnN0IGNodW5rcyA9IG5ldyBNYXA8c3RyaW5nLCBUSFJFRS5NZXNoPigpXG4gIGNvbnN0IHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgY29uc3QgY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKVxuICBsZXQgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlXG5cbiAgLy8g4pSA4pSAIFRleHR1cmUgbG9hZCAoYXN5bmNocm9ub3VzbHkpOyBuZXdseSBjcmVhdGVkIGNodW5rcyB3aWxsIHJlY2VpdmUgaXQgaW1tZWRpYXRlbHlcbiAgbGV0IHRlcnJhaW5NYXA6IFRIUkVFLlRleHR1cmUgfCBudWxsID0gbnVsbFxuICBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoXG4gICAgJy90ZXh0dXJlcy8zMmQ0YTZmZi0zZGExLTRjN2MtYTc0Mi0xZDFmYTc1OWUzOTQucG5nJyxcbiAgICAodGV4KSA9PiB7XG4gICAgICB0ZXgud3JhcFMgPSB0ZXgud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZ1xuICAgICAgLy8gTk9URTogdGhyZWUgcjE1Mis6IHNldCBjb2xvclNwYWNlIG9uIHRleHR1cmUgaW5zdGVhZCBvZiBlbmNvZGluZ1xuICAgICAgOyh0ZXggYXMgYW55KS5jb2xvclNwYWNlID0gKFRIUkVFIGFzIGFueSkuU1JHQkNvbG9yU3BhY2UgPz8gdW5kZWZpbmVkXG4gICAgICB0ZXguYW5pc290cm9weSA9IDhcbiAgICAgIHRlcnJhaW5NYXAgPSB0ZXhcblxuICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNodW5rIG1hdGVyaWFscyB0byB1c2UgdGhlIG1hcFxuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCBtbSA9IG0ubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWxcbiAgICAgICAgbW0ubWFwID0gdGV4XG4gICAgICAgIG1tLm5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIChlcnIpID0+IGNvbnNvbGUud2FybignVGVycmFpbiB0ZXh0dXJlIGZhaWxlZCB0byBsb2FkOyB1c2luZyBmbGF0IGNvbG9yJywgZXJyKSxcbiAgKVxuXG4gIC8vIOKUgOKUgCBSZWFjdCB0byBkaWZmaWN1bHR5IC8gZW52aXJvbm1lbnQgY2hhbmdlc1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG9uRGlmZmljdWx0eUNoYW5nZSgoc3RhdGUpID0+IHtcbiAgICBlbnZDYWNoZSA9IHN0YXRlLmVudmlyb25tZW50XG4gICAgZW52aXJvbm1lbnREaXJ0eSA9IHRydWVcbiAgfSlcblxuICAvLyDilIDilIAgRW5zdXJlIGEgY2h1bmsgZXhpc3RzXG4gIGZ1bmN0aW9uIGVuc3VyZShpeDogbnVtYmVyLCBpejogbnVtYmVyKSB7XG4gICAgY29uc3QgayA9IGtleShpeCwgaXopXG4gICAgaWYgKGNodW5rcy5oYXMoaykpIHJldHVyblxuICAgIGNvbnN0IG1lc2ggPSBidWlsZENodW5rKGl4LCBpeiwgdGVycmFpbk1hcClcbiAgICAvLyBzY2hlZHVsZSBmYWRlIGluXG4gICAgbWVzaC51c2VyRGF0YS5mYWRlID0geyB0OiAwLCBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IGNsb2NrLmdldEVsYXBzZWRUaW1lKCkgfVxuICAgIHNjZW5lLmFkZChtZXNoKVxuICAgIGNodW5rcy5zZXQoaywgbWVzaClcbiAgfVxuXG4gIC8vIOKUgOKUgCBNYXJrIGRpc3RhbnQgY2h1bmtzIHRvIHJlbW92ZSAod2XigJlsbCBmYWRlIHRoZW0gaW4gdXBkYXRlIGxvb3ApXG4gIGZ1bmN0aW9uIG1hcmtGb3JSZW1vdmFsKGNlbnRlclg6IG51bWJlciwgY2VudGVyWjogbnVtYmVyLCByYWRpdXM6IG51bWJlcikge1xuICAgIGNvbnN0IGN4ID0gdG9DaHVuayhjZW50ZXJYKVxuICAgIGNvbnN0IGN6ID0gdG9DaHVuayhjZW50ZXJaKVxuICAgIGZvciAoY29uc3QgW2ssIG1dIG9mIGNodW5rcykge1xuICAgICAgY29uc3QgZHggPSBjeCAtIG0udXNlckRhdGEuaXhcbiAgICAgIGNvbnN0IGR6ID0gY3ogLSBtLnVzZXJEYXRhLml6XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeikpXG4gICAgICBpZiAoZGlzdCA+IHJhZGl1cyAmJiAhbS51c2VyRGF0YS5yZW1vdmluZykge1xuICAgICAgICBtLnVzZXJEYXRhLnJlbW92aW5nID0gdHJ1ZVxuICAgICAgICBtLnVzZXJEYXRhLmZhZGUgPSB7IHQ6IDAsIGZyb206IChtLm1hdGVyaWFsIGFzIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKS5vcGFjaXR5LCB0bzogMCwgc3RhcnQ6IGNsb2NrLmdldEVsYXBzZWRUaW1lKCkgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIOKUgOKUgCBGYWRlIHN0ZXAgKGJvdGggaW4gJiBvdXQpLCBhbmQgZGlzcG9zZSBvdXQtZmFkZWQgY2h1bmtzXG4gIGZ1bmN0aW9uIHN0ZXBGYWRlcyhub3c6IG51bWJlcikge1xuICAgIGNvbnN0IHRvRGVsZXRlOiBzdHJpbmdbXSA9IFtdXG4gICAgZm9yIChjb25zdCBbaywgbV0gb2YgY2h1bmtzKSB7XG4gICAgICBjb25zdCBmID0gbS51c2VyRGF0YS5mYWRlIGFzIHsgdDogbnVtYmVyOyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXI7IHN0YXJ0OiBudW1iZXIgfVxuICAgICAgaWYgKCFmKSBjb250aW51ZVxuICAgICAgY29uc3QgbW0gPSBtLm1hdGVyaWFsIGFzIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsXG5cbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBmLnN0YXJ0XG4gICAgICBjb25zdCB0ID0gVEhSRUUuTWF0aFV0aWxzLmNsYW1wKGVsYXBzZWQgLyBGQURFX0RVUkFUSU9OLCAwLCAxKVxuICAgICAgbW0ub3BhY2l0eSA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKGYuZnJvbSwgZi50bywgdClcblxuICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAvLyBpZiB3ZSBqdXN0IGZhZGVkIG91dCwgcmVtb3ZlICYgZGlzcG9zZVxuICAgICAgICBpZiAobS51c2VyRGF0YS5yZW1vdmluZykge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShtKVxuICAgICAgICAgIGRpc3Bvc2VDaHVuayhtKVxuICAgICAgICAgIGNodW5rcy5kZWxldGUoaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmYWRlLWluIGZpbmlzaGVkOyBjbGVhciBmYWRlIG1hcmtlclxuICAgICAgICAgIG0udXNlckRhdGEuZmFkZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIOKUgOKUgCBEaXNwb3NlIGEgd2hvbGUgY2h1bmsgc2FmZWx5XG4gIGZ1bmN0aW9uIGRpc3Bvc2VDaHVuayhtZXNoOiBUSFJFRS5NZXNoKSB7XG4gICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKClcblxuICAgIC8vIGRpc3Bvc2UgKnBlci1jaHVuayBjbG9uZSogb2YgdGVycmFpbiBtYXRlcmlhbFxuICAgIGNvbnN0IG1tID0gbWVzaC5tYXRlcmlhbCBhcyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbFxuICAgIGlmIChtbS5tYXAgJiYgbW0ubWFwICE9PSB0ZXJyYWluTWFwKSBtbS5tYXAuZGlzcG9zZSgpXG4gICAgbW0uZGlzcG9zZSgpXG5cbiAgICAvLyBkZWNvcmF0aW9uc1xuICAgIGNvbnN0IGRlY29zID0gbWVzaC51c2VyRGF0YS5kZWNvcmF0aW9ucyBhcyBUSFJFRS5PYmplY3QzRFtdIHwgdW5kZWZpbmVkXG4gICAgZm9yIChjb25zdCBkIG9mIGRlY29zID8/IFtdKSB7XG4gICAgICBpZiAoZCBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgZC5nZW9tZXRyeS5kaXNwb3NlKClcbiAgICAgICAgZC5kaXNwb3NlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQudHJhdmVyc2UoKGMpID0+IHtcbiAgICAgICAgICBpZiAoKGMgYXMgYW55KS5nZW9tZXRyeSkgKGMgYXMgVEhSRUUuTWVzaCkuZ2VvbWV0cnkuZGlzcG9zZSgpXG4gICAgICAgICAgY29uc3QgbWF0ID0gKGMgYXMgVEhSRUUuTWVzaCkubWF0ZXJpYWxcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXQpKSBtYXQuZm9yRWFjaCgobSkgPT4gbS5kaXNwb3NlPy4oKSlcbiAgICAgICAgICBlbHNlIChtYXQgYXMgYW55KT8uZGlzcG9zZT8uKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIG1lc2gucmVtb3ZlKGQpXG4gICAgfVxuICAgIG1lc2gudXNlckRhdGEuZGVjb3JhdGlvbnMgPSBbXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGUocG9zOiBUSFJFRS5WZWN0b3IzLCBkdDogbnVtYmVyKSB7XG4gICAgICAvLyByYWRpdXMgY2FuIGFkanVzdCB3aXRoIGRlbnNpdHkgaWYgeW91IHdpc2g7IGtlZXAgc2ltcGxlICYgc3RhYmxlIGhlcmVcbiAgICAgIGNvbnN0IHJhZGl1cyA9IEFDVElWRV9SQURJVVNcbiAgICAgIGNvbnN0IGN4ID0gdG9DaHVuayhwb3MueClcbiAgICAgIGNvbnN0IGN6ID0gdG9DaHVuayhwb3MueilcblxuICAgICAgLy8gY3JlYXRlL2tlZXAgYSBzcXVhcmUgb2YgY2h1bmtzIGFyb3VuZCB0aGUgcGxheWVyXG4gICAgICBmb3IgKGxldCBkeiA9IC1yYWRpdXM7IGR6IDw9IHJhZGl1czsgZHorKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC1yYWRpdXM7IGR4IDw9IHJhZGl1czsgZHgrKykge1xuICAgICAgICAgIGVuc3VyZShjeCArIGR4LCBjeiArIGR6KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1hcmsgZmFyIGNodW5rcyBmb3IgZmFkZS1vdXQvcmVtb3ZhbFxuICAgICAgbWFya0ZvclJlbW92YWwocG9zLngsIHBvcy56LCByYWRpdXMpXG5cbiAgICAgIC8vIHJlLWRlY29yYXRlIGFmdGVyIGVudiBjaGFuZ2UgKHNlZWRlZCDihpIgbm8gcG9wcGluZylcbiAgICAgIGlmIChlbnZpcm9ubWVudERpcnR5KSB7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBjaHVua3MudmFsdWVzKCkpIGRlY29yYXRlQ2h1bmsobSlcbiAgICAgICAgZW52aXJvbm1lbnREaXJ0eSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIGZhZGUgc3RlcFxuICAgICAgc3RlcEZhZGVzKGNsb2NrLmdldEVsYXBzZWRUaW1lKCkpXG4gICAgfSxcblxuICAgIHF1ZXJ5SGVpZ2h0KHg6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgICByZXR1cm4gaGVpZ2h0QXQoeCwgeilcbiAgICB9LFxuXG4gICAgcXVlcnlOb3JtYWwoeDogbnVtYmVyLCB6OiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IG4gPSBub3JtYWxBdCh4LCB6KVxuICAgICAgcmV0dXJuIHRtcC5zZXQobi54LCBuLnksIG4ueilcbiAgICB9LFxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHVuc3Vic2NyaWJlPy4oKVxuICAgICAgZm9yIChjb25zdCBtIG9mIGNodW5rcy52YWx1ZXMoKSkgZGlzcG9zZUNodW5rKG0pXG4gICAgICBjaHVua3MuY2xlYXIoKVxuXG4gICAgICAvLyBzaGFyZWQgcmVzb3VyY2VzOiBkb27igJl0IGRpc3Bvc2Ugc2hhcmVkLnRlcnJhaW5CYXNlICh1c2VkIGFzIHRlbXBsYXRlKVxuICAgICAgc2hhcmVkLnJvY2tHZW8uZGlzcG9zZSgpXG4gICAgICBzaGFyZWQucm9ja01hdC5kaXNwb3NlKClcblxuICAgICAgaWYgKHRlcnJhaW5NYXApIHtcbiAgICAgICAgdGVycmFpbk1hcC5kaXNwb3NlKClcbiAgICAgICAgdGVycmFpbk1hcCA9IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICB9XG59XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJoZWlnaHRBdCIsIm5vcm1hbEF0IiwiZ2V0RGlmZmljdWx0eVN0YXRlIiwib25EaWZmaWN1bHR5Q2hhbmdlIiwibWVyZ2VHZW9tZXRyaWVzIiwiQ0hVTktfU0laRSIsIkdSSURfU0VHTUVOVFMiLCJBQ1RJVkVfUkFESVVTIiwiRkFERV9EVVJBVElPTiIsIlNLSVJUX0RST1AiLCJUSUxFX1JFUEVBVCIsIlJPQ0tTX1BFUl9ERU5TSVRZX1VOSVQiLCJIQUxGIiwia2V5IiwiaXgiLCJpeiIsInRvQ2h1bmsiLCJ4IiwiTWF0aCIsImZsb29yIiwibXVsYmVycnkzMiIsInNlZWQiLCJ0IiwiaW11bCIsImhhc2gyaSIsImEiLCJiIiwiaCIsImVudkNhY2hlIiwiZW52aXJvbm1lbnQiLCJzaGFyZWQiLCJ0ZXJyYWluQmFzZSIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiY29sb3IiLCJyb3VnaG5lc3MiLCJtZXRhbG5lc3MiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJkaXRoZXJpbmciLCJyb2NrTWF0Iiwicm9ja0dlbyIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJidWlsZFRlcnJhaW5QbGFuZSIsImciLCJQbGFuZUdlb21ldHJ5Iiwicm90YXRlWCIsIlBJIiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaSIsImNvdW50IiwidngiLCJnZXRYIiwidnoiLCJnZXRaIiwic2V0WSIsIm5lZWRzVXBkYXRlIiwidXYiLCJzZXRYWSIsImdldFkiLCJjb21wdXRlVmVydGV4Tm9ybWFscyIsImJ1aWxkU2tpcnQiLCJlZGdlVmVydHMiLCJzZWciLCJwb3NpdGlvbnMiLCJ1dnMiLCJpbmRpY2VzIiwicHVzaFBhaXIiLCJ4TG9jYWwiLCJ6TG9jYWwiLCJ3b3JsZFgiLCJ3b3JsZFoiLCJ0b3BZIiwiYm90dG9tWSIsImJhc2VJZHgiLCJsZW5ndGgiLCJwdXNoIiwicHVzaFF1YWQiLCJpVG9wQSIsImlUb3BCIiwiaUJvdEEiLCJpQm90QiIsInByZXZUb3AiLCJuZXh0VG9wIiwieiIsImdlbyIsIkJ1ZmZlckdlb21ldHJ5Iiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsInNldEluZGV4IiwiYnVpbGRDaHVua0dlb21ldHJ5IiwicGxhbmUiLCJza2lydCIsIm1lcmdlZCIsImRpc3Bvc2UiLCJkZWNvcmF0ZUNodW5rIiwibWVzaCIsInByZXZpb3VzIiwidXNlckRhdGEiLCJkZWNvcmF0aW9ucyIsIm9iaiIsInJlbW92ZSIsIkluc3RhbmNlZE1lc2giLCJnZW9tZXRyeSIsInRyYXZlcnNlIiwiYyIsIm0iLCJtYXRlcmlhbCIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJtbSIsInByb3BEZW5zaXR5IiwicHJvcENvdW50IiwibWF4Iiwicm91bmQiLCJyYW5kIiwiaW5zdCIsIm1hdCIsIk1hdHJpeDQiLCJwIiwiVmVjdG9yMyIsInEiLCJRdWF0ZXJuaW9uIiwicyIsInVwIiwibiIsImxvY2FsWCIsImxvY2FsWiIsInkiLCJzZXQiLCJubiIsIm5vcm1hbGl6ZSIsImFsaWduIiwic2V0RnJvbVVuaXRWZWN0b3JzIiwic2V0RnJvbUF4aXNBbmdsZSIsInByZW11bHRpcGx5IiwiayIsImNvbXBvc2UiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4IiwiY2FzdFNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJhZGQiLCJidWlsZENodW5rIiwidGV4dHVyZU1hcCIsImNsb25lIiwibWFwIiwiTWVzaCIsInJlY2VpdmVTaGFkb3ciLCJmYWRlIiwiZnJvbSIsInRvIiwic3RhcnQiLCJyZW1vdmluZyIsImNyZWF0ZVN0cmVhbWVyIiwic2NlbmUiLCJjaHVua3MiLCJNYXAiLCJ0bXAiLCJjbG9jayIsIkNsb2NrIiwiZW52aXJvbm1lbnREaXJ0eSIsInRlcnJhaW5NYXAiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsInRleCIsIndyYXBTIiwid3JhcFQiLCJSZXBlYXRXcmFwcGluZyIsImNvbG9yU3BhY2UiLCJTUkdCQ29sb3JTcGFjZSIsInVuZGVmaW5lZCIsImFuaXNvdHJvcHkiLCJ2YWx1ZXMiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsInVuc3Vic2NyaWJlIiwic3RhdGUiLCJlbnN1cmUiLCJoYXMiLCJnZXRFbGFwc2VkVGltZSIsIm1hcmtGb3JSZW1vdmFsIiwiY2VudGVyWCIsImNlbnRlcloiLCJyYWRpdXMiLCJjeCIsImN6IiwiZHgiLCJkeiIsImRpc3QiLCJhYnMiLCJzdGVwRmFkZXMiLCJub3ciLCJ0b0RlbGV0ZSIsImYiLCJlbGFwc2VkIiwiTWF0aFV0aWxzIiwiY2xhbXAiLCJsZXJwIiwiZGlzcG9zZUNodW5rIiwiZGVsZXRlIiwiZGVjb3MiLCJkIiwidXBkYXRlIiwiZHQiLCJxdWVyeUhlaWdodCIsInF1ZXJ5Tm9ybWFsIiwiY2xlYXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/world/chunks/streamer.ts\n"));

/***/ })

});